<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>SpringBoot(三)</title>
      <link href="/2020/07/03/springboot-san/"/>
      <url>/2020/07/03/springboot-san/</url>
      
        <content type="html"><![CDATA[<h1 id="本文章作为SpringBoot-二-的补充篇，补充了返回JSON格式的数据"><a href="#本文章作为SpringBoot-二-的补充篇，补充了返回JSON格式的数据" class="headerlink" title="本文章作为SpringBoot(二)的补充篇，补充了返回JSON格式的数据"></a>本文章作为SpringBoot(二)的补充篇，补充了返回JSON格式的数据</h1><hr><h2 id="返回JSON数据"><a href="#返回JSON数据" class="headerlink" title="返回JSON数据"></a>返回JSON数据</h2><blockquote><p>在加载了web的Starter模块后返回对象即可转换成JSON格式的字符串</p></blockquote><pre><code>&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><blockquote><p>web默认使用的是jackson-databind转JSON</p></blockquote><h3 id="自定义JSON转换器"><a href="#自定义JSON转换器" class="headerlink" title="自定义JSON转换器"></a>自定义JSON转换器</h3><blockquote><p>自定义fastjson框架</p></blockquote><blockquote><p>先除去jackson-databind依赖，引入fastjson依赖</p></blockquote><pre><code>&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;    &lt;!-- 去除jackson-databind --&gt;    &lt;exclusions&gt;        &lt;exclusion&gt;            &lt;groupId&gt;corn.fasterxrnl.jackson.core&lt;/groupId&gt;            &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;        &lt;/exclusion&gt;    &lt;/exclusions&gt;&lt;/dependency&gt;&lt;!-- 引入fastjson依赖 --&gt;&lt;dependency&gt;    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;    &lt;artifactId&gt;fastjson&lt;/artifactId&gt;    &lt;version&gt;1.2.47&lt;/version&gt;&lt;/dependency&gt;</code></pre><blockquote><p>然后配置fastjson的HttpMessageConverter</p></blockquote><pre><code>@Configurationpublic class MyFastJsonConfig{    @Bean    FastJsonHttpMessageConverter fastJsonHttpMessageConverter() {        FastJsonHttpMessageConverter converter = new FastJsonHttpMessageConverter();        FastJsonConfig config = new FastJsonConfig();        config.setDateFormat(&quot;yyyy-MM-dd&quot;);        config.setCharset(Charset.forName(&quot;UTF-8&quot;));        config.setSerializerFeatures(                SerializerFeature.WriteClassName,                SerializerFeature.WriteMapNullValue,                SerializerFeature.PrettyFormat,                SerializerFeature.WriteNullListAsEmpty,                SerializerFeature.WriteNullStringAsEmpty);        converter.setFastJsonConfig(config);        return converter;    }}</code></pre><blockquote><p>MyFastJsonConfig配置完后还需去配置文件中配置一下响应编码，否则返回的JSON会出中文乱码</p></blockquote><pre><code>spring:  http:  encoding:   force-response: true</code></pre><blockquote><p>注意：扫描方式</p></blockquote><hr><h2 id="静态资源访问"><a href="#静态资源访问" class="headerlink" title="静态资源访问"></a>静态资源访问</h2><blockquote><p>默认配置的路径分别为：classpath:/META-INF/resources；classpath:/resources/；classpath:/static/；classpath:/public/；优先级依次降低。</p></blockquote><h3 id="自定义策略"><a href="#自定义策略" class="headerlink" title="自定义策略"></a>自定义策略</h3><ol><li>在配置文件中定义<pre><code>     spring&quot;:       mvc:        static-path-pattern: /static/** #过滤规则      resources:        static-location: classpath:/static/ #静态资源位置</code></pre></li><li>Java编码定义<blockquote><p>实现WebMvcConfigurer接口，然后实现该接口的addResourcesHandlers方法</p></blockquote><pre><code>     @Configuration     public class MyWebMvcConfig implements WebMbcConfigurer{         @Override         public void addResourcesHandlers(ResourceHandlerRegistry registry){             registry.addResourcesHandler(&quot;/statics/**&quot;).addResourcesLocations(&quot;classpath:/static/&quot;);         }     }</code></pre></li></ol><hr><h2 id="动态资源访问"><a href="#动态资源访问" class="headerlink" title="动态资源访问"></a>动态资源访问</h2><blockquote><p>默认配置的路径分别为：classpath:/templates/，默认的模板后缀为.html.</p></blockquote><h3 id="常见配置"><a href="#常见配置" class="headerlink" title="常见配置"></a>常见配置</h3><blockquote><p>常见配置如下</p></blockquote><pre><code>＃是否开启缓存，开发时可设置为 false ，默认为 truespring.thymeleaf.checktemplate=true ＃检查模板位置是否存在，默认为 truespring.thymeleaf.check-template-location=true ＃模板文件编码sprithymeleaf.encoding=UTF＃模板文件位置spring.thymeleafprefx=classpath/templates/#ContentType配置spring.thymeleaf.servlet.content-type=text/html ＃模板文件后缀spring.thymeleaf.suffix=.html</code></pre><hr><h2 id="配置文件访问"><a href="#配置文件访问" class="headerlink" title="配置文件访问"></a>配置文件访问</h2><blockquote><p>默认配置的路径分别为：项目根路径下的config文件夹(和src同级)；项目根目录下；classpath:/config；classpath:/；优先级依次降低。</p></blockquote><h3 id="自定义访问配置文件"><a href="#自定义访问配置文件" class="headerlink" title="自定义访问配置文件"></a>自定义访问配置文件</h3><blockquote><p>在同一个文件夹内，可用spring-profiles-active=test引用其他配置文件。Spring会自动寻找application-test的配置文件 </p></blockquote><hr><h2 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h2><h3 id="单文件上传"><a href="#单文件上传" class="headerlink" title="单文件上传"></a>单文件上传</h3><p>前端页面</p><pre><code>&lt;form action=&quot;upload&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt;    &lt;input type=&quot;file&quot; name=&quot;multipartFile&quot; value=&quot;文件上传&quot;/&gt;    &lt;input type=&quot;submit&quot; value=&quot;提交&quot;/&gt;&lt;/form&gt;</code></pre><p>控制层</p><pre><code>SimpleDateFormat simpleDateFormat = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);public String upload(MultipartFile multipartFile, HttpServletRequest request){    // 文件上传后存放的位置为:classpath:/uploadFile/    String realPath = request.getSession().getServletContext().getRealPath(&quot;/uploadFile&quot;);    String format = simpleDateFormat.format(new Date());    File file = new File(realPath+format);    // 判断文件夹是否存在，不存在就创建文件夹    if(!file.isDirectory()){        file.mkdirs();    }    // 获取上传名称，生成新的名称。防止重名    String oldName = multipartFile.getOriginalFilename();    String newName = UUID.randomUUID().toString()+oldName.substring(oldName.lastIndexOf(&quot;.&quot;), oldName.length());    try{        // 文件保存        multipartFile.transferTo(new File(file, newName));        //生成上传文件的访问路径        String filePath = request.getScheme()+&quot;://&quot;+request.getServerName()+&quot;:&quot;+request.getServerPort()+&quot;/uploadFile/&quot;+format+newName;        return filePath;    }catch (IOException e) {        e.printStackTrace();    }    return &quot;上传失败&quot;;}</code></pre><blockquote><p>可以通过配置文件对上传文件的细节进行配置</p></blockquote><pre><code>spring.servlet.multipart.enabled=true   //是否开启文件上传，默认为truespring.servlet.multipart.file-size-threshold=0  //文件写入磁盘的阈值，默认为0spring.servlet.multipart.location=E:\\temp  //文件上传的临时保存路径spring.servlet.multipart.max-file-size=1MB  //上传单个文件的最大大小，默认为1MBspring.servlet.multipart.max-request-size=10MB  //上传多个文件的总大小，默认为10MBspring.servlet.multipart.resolve-lazily=false   //是否延迟解析，默认为false</code></pre><hr><h3 id="多文件上传"><a href="#多文件上传" class="headerlink" title="多文件上传"></a>多文件上传</h3><p>前端页面</p><pre><code>&lt;form action=&quot;upload&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt;    &lt;input type=&quot;file&quot; name=&quot;multipartFile&quot; value=&quot;文件上传&quot; multiple/&gt;    &lt;input type=&quot;submit&quot; value=&quot;提交&quot;/&gt;&lt;/form&gt;</code></pre><p>控制层</p><pre><code>SimpleDateFormat simpleDateFormat = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);public String upload(MultipartFile[] multipartFiles, HttpServletRequest request){    //遍历multipartFile    for(MultipartFile multipartFile : multipartFiles){        //和单文件上传一致    }}</code></pre><hr><h2 id="全局数据的处理"><a href="#全局数据的处理" class="headerlink" title="全局数据的处理"></a>全局数据的处理</h2><blockquote><p>@ControllerAdvice是@Controller的增强版，主要用于处理全局的数据。一般配合@ExceptionHandler、@ModelAttribute和@InitBinder使用</p></blockquote><h3 id="全局异常处理"><a href="#全局异常处理" class="headerlink" title="全局异常处理"></a>全局异常处理</h3><blockquote><p>通过@ControllerAdvice和@ExceptionHandler配合即可实现全局的异常处理，如在文件上传时文件大小超出限制后抛出的异常</p></blockquote><pre><code>@ControllerAdvicepublic class test {    @ExceptionHandler(MaxUploadSizeExceededException.class)    public void uploadExceeded(MaxUploadSizeExceededException e, HttpServletResponse response) throws IOException {        ModelAndView modelAndView = new ModelAndView();        modelAndView.addObject(&quot;文件大小超出限制&quot;);        modelAndView.setViewName(&quot;error&quot;);        return modelAndView;    }}</code></pre><blockquote><p>方法参数可为：response，request，Model，异常实例等。返回值可为：JSON，ModelAndView，一个逻辑视图名等。</p></blockquote><h3 id="添加全局数据"><a href="#添加全局数据" class="headerlink" title="添加全局数据"></a>添加全局数据</h3><blockquote><p>可以设置全局数据，通过key获取到对应的value</p></blockquote><pre><code>@ModelAttribute(value = &quot;key&quot;)public Map&lt;String, Object&gt; getInfo(){    Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;();    map.put(&quot;key1&quot;,&quot;value1&quot;);    map.put(&quot;key2&quot;,&quot;value2&quot;);    return map;}</code></pre><blockquote><p>注解的value为表示返回数据的key，方法的返回值为返回数据的value</p></blockquote><hr><h3 id="获取全局数据"><a href="#获取全局数据" class="headerlink" title="获取全局数据"></a>获取全局数据</h3><blockquote><p>通过Model获取所有的key-value</p></blockquote><pre><code>public void test(Model model){    //通过model获取所有的key-value    Map&lt;String Object&gt; map = model.asMap();    //将key存入Set并遍历    Set&lt;String&gt; keySet = map.keySet();    Iterator&lt;String&gt; iterator = keySet.iterator();    while(iterator.hasNext()){        //获取遍历的key        Strign key  = iterator.next();        //根据遍历的key获取value        Object value = map.get(key);    }}</code></pre><hr><h3 id="自定义错误页"><a href="#自定义错误页" class="headerlink" title="自定义错误页"></a>自定义错误页</h3><blockquote><p>Spring Boot默认在静态资源目录的error目录下查找4XX，5XX的文件。如果都找不到则返回默认的error页面。如果error界面都找不到，则会返回默认的两个页面</p></blockquote><h4 id="静态页面"><a href="#静态页面" class="headerlink" title="静态页面"></a>静态页面</h4><blockquote><p>默认目录在静态资源目录(static)的error目录下查找对应的错误码.html，如产生404错误时，优先返回404.html页面。如果找不到404.html则寻找其他的4XX页面。</p></blockquote><hr><h4 id="动态页面"><a href="#动态页面" class="headerlink" title="动态页面"></a>动态页面</h4><blockquote><p>默认在/templates/error目录下寻找4XX.HTML，5XX.HTML文件</p></blockquote><hr><h2 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h2><blockquote><p>添加web依赖，创建一个拦截器类。然后实现HandlerInterceptor接口，重写preHandle，postHandle，afterCompletion方法</p></blockquote><pre><code>public class TestInterceptor implements HandlerInterceptor {    @Override    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {        return false;    }    @Override    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {    }    @Override    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {    }}</code></pre><blockquote><p>拦截器中的方法按照preHandle-Controller-postHandle-afterCompletion的顺序执行。只有当preHandle返回true时才会执行后续的操作</p></blockquote><h3 id="配置拦截器"><a href="#配置拦截器" class="headerlink" title="配置拦截器"></a>配置拦截器</h3><blockquote><p>自定义类实现 WebMvcConfigurer 接口，实现接口中的 addlnterceptors 方法。其中，addPathPattems 表示拦截路径， excludePathPattems 表示排除的路径。</p></blockquote><pre><code>@Configuration public class WebMvcConfig implements WebMvcConfigurer {     Override    public void addinterceptors(InterceptorRegistry registry){        registry.addlnterceptor(new Mylnterceptorl()).addPathPatterns(&quot;/**&quot;).excludePathPatterns(&quot;/hello&quot;);    }}</code></pre><hr><h2 id="路径映射"><a href="#路径映射" class="headerlink" title="路径映射"></a>路径映射</h2><blockquote><p>一般情况下 使用了页面模板后，用户需要通过控制器才能访问页面。有一些页面需要在控制器中加载数据，然后渲染，才能显示出来；还有一些页面在控制器中不需要加载数据，只是完成简单的跳转，对于这种页面，可以直接配置路径映射，提高访问速度。</p></blockquote><pre><code>@Configuration public class WebMvcConf implements WebMvcConf igurer {     Override    public void addViewControllers(ViewControllerRegistry registry){        registry.addViewController(&quot;/login&quot;).setViewName(&quot;login&quot;);         registry.addViewController(&quot;/index&quot;).setViewName(&quot;index&quot;);    }}</code></pre><hr><h2 id="配置AOP"><a href="#配置AOP" class="headerlink" title="配置AOP"></a>配置AOP</h2><blockquote><p>AOP的常见概念</p></blockquote><ul><li>Joinpoint(连接点)<ul><li>类里面需要被增强的方法称为连接点。</li></ul></li><li>Ponintcut(切入点)<ul><li>对连接点进行拦截的定义被称为切入点。</li></ul></li><li>Advie(通知)<ul><li>拦截到连接点后需要做的事就是通知。通知分为前置通知，后置通知，异常通知，最终通知和环绕通知</li></ul></li><li>Aspect(切入面)<ul><li>切入点和通知的集合</li></ul></li><li>Target(目标对象)<ul><li>要增强的对象被称为目标对象</li></ul></li></ul><hr><blockquote><p>引入aop依赖</p></blockquote><pre><code>&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><blockquote><p>创建server类</p></blockquote><pre><code>@Servicepublic void UserService{    public String getUserById(Integer id){        System.out.println(&quot;执行get方法&quot;);        return &quot;user&quot;;    }}</code></pre><blockquote><p>创建切面</p></blockquote><pre><code>@Compoent@Aspectpublic class LogAspect{    @Pointcut (&quot;execution(* org.sang.aop.service.*.*.(..))&quot;）    public void pcl () {     }    @Before(value =&quot;pcl()&quot;)     public void before (JoinPoint jp) {         String name = jp.getSignature().getName();        System.out.println(name ＋&quot;方法开始执行 ．．．&quot; ）；    }     @After(value =&quot;pcl()&quot;)     public void after (JoinPoint jp) {         String name = jp.getSignature ().getName();         System.out.println(name 方法执行结束．．．&quot;）；    }    @AfterReturning(value =&quot;pcl()&quot;,returning =&quot;result&quot;)     public void afterReturning(JoinPoint jp, Object result) {         String name = jp.getSignature().getName();         System.out.println(name ＋&quot;方法返回值为：&quot;＋ result);     }    @AfterThrowing(value = &quot;pcl()&quot;, throwing = &quot;e&quot;)     public void afterThrowing(JoinPoint jp,Exceptio e) {         String name = jp.getSignature().getName();         System.out.println(name + &quot;方法抛异常了，异常是:&quot; + e.getMessage());    }    @Around(&quot;pcl()&quot;)     public Object around(ProceedingJoinPoint pjp) throws Throwable {         return pjp.proceed();     }</code></pre><ul><li>@Aspect注解说明这是一个切面</li><li>@Pointcut表示这是一个切入点。execution的第一个*表示方法返回值可以使任意，第二个*表示为包下的任意类。第三个*表示类中的任意方法，两个点表示方法参数任意</li><li>@Before表示这是一个前置通知。该方法在目标指向前先执行。通过JoinPoint参数可以获取方法名，修饰等信息</li><li>@After表示为后置通知。在方法执行后执行。</li><li>@AfterThrowing表示是一个返回通知，在这个方法中可以获取目标方法的返回值，returning是返回值的变量名。由于result为Object，所以可以处理任何类型。</li><li>@AfterThrowing表示为异常通知。当目标方法发送异常时执行该方法。异常类型表示什么错误进入该方法</li><li>@Around为环绕通知。可以实现前直通知，后直通知。异常通知以及返回通知的功能</li></ul><hr><h2 id="其他自定义"><a href="#其他自定义" class="headerlink" title="其他自定义"></a>其他自定义</h2><hr><h3 id="自定义首页"><a href="#自定义首页" class="headerlink" title="自定义首页"></a>自定义首页</h3><blockquote><p>Spring Boot项目在启动后会去静态资源目录下查找index.html的文件，如果找不到才会去查找动态的index文件作为首页</p></blockquote><blockquote><p>如果想使用静态网页作为首页，只需要在/static/目录创建index.html即可。如果想使用动态网页作为首页，在/templates/目录下创建index.html(Templates模板)，然后在Controller返回index的逻辑视图即可</p></blockquote><pre><code>@RequestMapping (&quot;/index&quot;) public String hello() {     return &quot;index&quot;;}</code></pre><hr><h3 id="自定义网页标签图标"><a href="#自定义网页标签图标" class="headerlink" title="自定义网页标签图标"></a>自定义网页标签图标</h3><blockquote><p>标签左上角的图片(faviocn.ioc)可以放在静态资源路径或者类路径下，静态资源路径下的优先级较高。</p></blockquote><blockquote><p>注意：标签必须为ioc后缀</p></blockquote><hr><h3 id="去除某个自动配置"><a href="#去除某个自动配置" class="headerlink" title="去除某个自动配置"></a>去除某个自动配置</h3><blockquote><p>StringBoot提供了大量的自动化配置。在启动类上面加入注解@EnableAutoConfiguration即可关闭某个自动配置。</p></blockquote><pre><code>@EnableAutoConfiguration(exclude={ErrorMvcAutoConfiguration.class})</code></pre><blockquote><p>同时，可以通过配置文件取消自动配置</p></blockquote><pre><code>spring.autoconfigure.exclude = org.springframework.boot.autoconfigure.web.servlet.error.ErrorMvcAutoConfiguration</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用功能(二)</title>
      <link href="/2020/07/02/chang-yong-gong-neng-er/"/>
      <url>/2020/07/02/chang-yong-gong-neng-er/</url>
      
        <content type="html"><![CDATA[<h2 id="lombok"><a href="#lombok" class="headerlink" title="lombok"></a>lombok</h2><h3 id="引入jar包"><a href="#引入jar包" class="headerlink" title="引入jar包"></a>引入jar包</h3><pre><code>&lt;dependency&gt;    &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;    &lt;artifactId&gt;lombok&lt;/artifactId&gt;    &lt;version&gt;1.18.12&lt;/version&gt;    &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt;</code></pre><hr><h3 id="安装lombok插件"><a href="#安装lombok插件" class="headerlink" title="安装lombok插件"></a>安装lombok插件</h3><blockquote><p>在自己编程的软件内安装即可</p></blockquote><hr><h3 id="lombok常用注解"><a href="#lombok常用注解" class="headerlink" title="lombok常用注解"></a>lombok常用注解</h3><hr><h4 id="实体类常用注解"><a href="#实体类常用注解" class="headerlink" title="实体类常用注解"></a>实体类常用注解</h4><ul><li>@Getter<ul><li>放在类上时，自动生成该类的所有get方法</li><li>放在属性上时，自动生成该属性的get方法</li></ul><hr></li><li>@Settet<ul><li>放在类上时，自动生成该类的所有set方法</li><li>放在属性上时，自动生成该属性的set方法</li></ul><hr></li><li>@ToString<ul><li>放在类上时，自动生成toString()方法</li></ul><hr></li><li>@EqualsAndHashCode<ul><li>放在类上时，覆盖默认的equals和hashCode</li></ul><hr></li><li>@NonNull<ul><li>放在属性上时，属性不能为空，否则抛出空指针异常。</li></ul><hr></li><li>@NoArgsConstructor<ul><li>生成无参构造器</li></ul><hr></li><li>@RequiredArgsConstructor<ul><li>生成包含final和@NonNull注解的成员变量的构造器</li></ul><hr></li><li>@AllArgsConstructor<ul><li>生成全参构造器</li></ul><hr></li><li>@Data<ul><li>作用于类上，是以下注解的集合：@ToString,@EqualsAndHashCode,@Getter,@Setter,@RequiredArgsConstructor</li></ul><hr></li><li>@Builder<ul><li>作用于类上，将类转变为建造者模式</li></ul><hr></li><li>@Log<ul><li>作用于类上，生成日志变量。针对不同的日志实现产品，有不同的注解</li></ul><hr></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> lombok </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot(二)</title>
      <link href="/2020/07/02/springboot-er/"/>
      <url>/2020/07/02/springboot-er/</url>
      
        <content type="html"><![CDATA[<h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><blockquote><p>本文章作为SpringBoot基础配置的补充</p></blockquote><h2 id="SpringBoot的Starter"><a href="#SpringBoot的Starter" class="headerlink" title="SpringBoot的Starter"></a>SpringBoot的Starter</h2><blockquote><p>SpringBoot为了简化配置，提供了很多的Starter。它打包了与常用模块相关的JAR包，并完成了自动配置。然后组装成了Starter，在开发时只需引入Starter即可正常使用功能</p></blockquote><table><thead><tr><th align="center">Starter</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">string-boot-starter-web</td><td align="center">用于构建Web，包含Rest风格框架，SpringMVC和默认的嵌入式容器Tomcat</td></tr><tr><td align="center">string-boot-starter-test</td><td align="center">用于测试</td></tr><tr><td align="center">string-boot-starter-jpa</td><td align="center">带有Hibernate的Spring Date JPA</td></tr><tr><td align="center">string-boot-starter-jdbc</td><td align="center">传统的jdbc，轻量级框架可用。学习成本低，但最好使用JPA或Mybatis</td></tr><tr><td align="center">string-boot-starter-thymeleaf</td><td align="center">支持Thymeleaf模板</td></tr><tr><td align="center">string-boot-starter-mail</td><td align="center">支持Java Mail，Spring Email邮件</td></tr><tr><td align="center">string-boot-starter-integration</td><td align="center">Spring框架创建的一个API，面向企业应用集成(EAI)</td></tr><tr><td align="center">string-boot-starter-mobile</td><td align="center">Spring MVC扩展。用来简化手机上的Web应用程序开发</td></tr><tr><td align="center">string-boot-starter-data-redis</td><td align="center">通过Spring Data Redis、Redis Client使用Redis</td></tr><tr><td align="center">string-boot-starter-validation</td><td align="center">Bean Validation是一个数据验证的规范，Hibernate Validator是一个数据验证框架</td></tr><tr><td align="center">string-boot-starter-websockices</td><td align="center">相对非持久的协议HTTP，Websocker是一个持久的协议</td></tr><tr><td align="center">string-boot-starter-web-services</td><td align="center">SOAP Web Services</td></tr><tr><td align="center">string-boot-starter-hateoas</td><td align="center">为服务添加HATEOAS功能</td></tr><tr><td align="center">string-boot-starter-security</td><td align="center">用Spring Security进行身份验证和授权</td></tr><tr><td align="center">string-boot-starter-data-rest</td><td align="center">用Spring Data REST 公布简单的REST服务</td></tr></tbody></table><hr><h2 id="视图技术"><a href="#视图技术" class="headerlink" title="视图技术"></a>视图技术</h2><blockquote><p>SpringBoot 主要支持Thymeleaf、Freemarker、Mustache、Groovy Templates等模板</p></blockquote><h3 id="Thymeleaf"><a href="#Thymeleaf" class="headerlink" title="Thymeleaf"></a>Thymeleaf</h3><h4>Thymeleaf的基本使用：</h4><pre><code>&lt;p th:text=&quot;${message}?:&#39;text&#39;&quot;&gt;内容&lt;/p&gt;</code></pre><blockquote><p>这个语法表示接收从控制层传递过来的名为message的值并替换掉原有的内容。如果没有传过来，则使用text作为p标签的内容。</p></blockquote><hr><h3 id="使用Thyeleaf"><a href="#使用Thyeleaf" class="headerlink" title="使用Thyeleaf"></a>使用Thyeleaf</h3><h4 id="加入Thymeleaf依赖"><a href="#加入Thymeleaf依赖" class="headerlink" title="加入Thymeleaf依赖"></a>加入Thymeleaf依赖</h4><pre><code>&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><h4 id="在模板文件中加入解析"><a href="#在模板文件中加入解析" class="headerlink" title="在模板文件中加入解析"></a>在模板文件中加入解析</h4><blockquote><p>在HTML文件中加入&lt;html lang=”en” xmlns:th=”<a href="http://www.thymeleaf.org&quot;\&gt;" target="_blank" rel="noopener">http://www.thymeleaf.org&quot;\&gt;</a></p></blockquote><h4 id="配置视图解析器"><a href="#配置视图解析器" class="headerlink" title="配置视图解析器"></a>配置视图解析器</h4><blockquote><p>SpringBoot默认的页面映射路径为:classpath:/templates/*.html;静态文件路径为:classpath:/static/ </p></blockquote><blockquote><p>在配置文件(properties或yml)中进行配置</p></blockquote><pre><code>spring  thymeleaf    mode: HTML5 # 表示Thymeleaf模式为HTML5    encoding: UTF-8 # 表示Thymeleaf编码格式为UTF-8    content-type: text/html # 文档类型为text/html    cache=false # 为了便于测试，在开发过程中将关闭缓存</code></pre><blockquote><p>注意：由于Thymeleaf检查HTML格式严格。如果HTML格式不对，则会报错。如果想禁止这种严格的语法检查模式，可以在配置文件中加入spring.thymeleaf.mode=LEGACYHTML5来解决。</p></blockquote><h3 id="Thymeleaf基础语法"><a href="#Thymeleaf基础语法" class="headerlink" title="Thymeleaf基础语法"></a>Thymeleaf基础语法</h3><h4 id="常用th标签"><a href="#常用th标签" class="headerlink" title="常用th标签"></a>常用th标签</h4><ol><li><strong>th:text</strong><pre><code> &lt;div th:text=&quot;${message}&quot;&gt;&lt;/div&gt;</code></pre><blockquote><p>用于显示控制器传入的值<br>如果message不存在，需要显示默认值可用以下的方式</p></blockquote><pre><code> &lt;div th:text=&quot;${message}?:&#39;默认值&#39;&quot;&gt;&lt;/div&gt;</code></pre><hr></li><li><strong>th:object</strong><pre><code> &lt;div th:object=&quot;${user}&quot;&gt;&lt;/div&gt;</code></pre><blockquote><p>用于接收后台传递过来的对象</p></blockquote><hr></li><li><strong>th:action</strong><pre><code> &lt;form th:action=&quot;@{/article/}+${article.id}&quot; method=&quot;post&quot;&gt;&lt;/form&gt;</code></pre><blockquote><p>用于指定表单提交地址</p></blockquote><hr></li><li><strong>th:value</strong><pre><code> &lt;input type=&quot;text&quot; th:value=&quot;${user.name}&quot; id=&quot;name&quot;/&gt;</code></pre><blockquote><p>将对象的值替换成value的值</p></blockquote><hr></li><li><strong>th:field</strong><pre><code> &lt;input type=&quot;text&quot; th:field=&quot;${user.name}&quot; id=&quot;name&quot;/&gt;</code></pre><blockquote><p>用来绑定后台对象和表单数据</p></blockquote><hr></li></ol><h4 id="URL写法"><a href="#URL写法" class="headerlink" title="URL写法"></a>URL写法</h4><blockquote><p>Thymeleaf是通过语法@{…}来处理URL的。需要使用”th:href”和”th:src”等属性。</p></blockquote><pre><code>&lt;a th:href=&quot;@{/}&quot;&gt;相对路径&lt;/a&gt;&lt;a th:href=&quot;@{http://text.com}&quot;&gt;绝对路径&lt;/a&gt;&lt;a th:href=&quot;@{css/jquery.js}&quot;&gt;默认访问static下的css文件夹内的jquery.js文件&lt;/a&gt;</code></pre><blockquote><p>注意：在通常url路径中，如果要传入多个参数用’&amp;’分隔，但在Thymeleaf中，使用’,’分隔多个参数</p></blockquote><h4 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h4><ol><li><strong>th:if</strong><pre><code> &lt;a th:href=&quot;@{css/js}&quot; th:if=&quot;{user.id == null}&quot;&gt;&lt;/a&gt;</code></pre><blockquote><p>当条件满足时，a标签才显示</p><blockquote><p>if的表达式</p></blockquote></blockquote><ul><li>gt<ul><li>大于</li></ul></li><li>ge<ul><li>大于或等于</li></ul></li><li>eq<ul><li>等于</li></ul></li><li>lt<ul><li>小于</li></ul></li><li>le<ul><li>小于或等于</li></ul></li><li>ne<ul><li>不等于</li></ul></li></ul><hr></li><li><strong>th:unless</strong><pre><code> &lt;a th:href=&quot;@{css/js}&quot; th:unless=&quot;{user.id == null}&quot;&gt;&lt;/a&gt;</code></pre><blockquote><p>当条件不成立时，a标签才显示</p></blockquote><hr></li><li><strong>th:switch</strong><pre><code> &lt;div th:switch=&quot;{user.name}&quot;&gt;   &lt;p th:case=&quot;administrator&quot;&gt;administrator&lt;/p&gt;   &lt;p th:case=&quot;user&quot;&gt;user&lt;/p&gt;   &lt;p th:case=&quot;*&quot;&gt;无匹配&lt;/p&gt; &lt;/div&gt;</code></pre><blockquote><p>当user的name等于administrator时，显示administrator标签。如果所有的值都不满足，则显示’无匹配’。</p></blockquote><hr></li></ol><h4 id="字符串替换"><a href="#字符串替换" class="headerlink" title="字符串替换"></a>字符串替换</h4><blockquote><p>有时需要对文字中的某一处地方进行替换。可以通过字符串拼接操作完成。</p></blockquote><pre><code>&lt;span th:text=&quot;欢迎你登录，&#39;+${name}+&#39;,管理员&quot;&gt;&lt;/span&gt;</code></pre><p>或者</p><pre><code>&lt;span th:text=&quot;欢迎你登录，${name},管理员&quot;&gt;&lt;/span&gt;</code></pre><blockquote><p>第二种形式限制较多，只能包含${}表达式，不能包含其他常量，条件表达式等。</p></blockquote><hr><h4 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h4><blockquote><p>算数运算符</p></blockquote><pre><code>  &lt;span th:text=&quot;1+1&quot;&gt;&lt;/span&gt;</code></pre><blockquote><p>表示将1+1的结果放入span标签内</p></blockquote><hr><h4 id="公用对象"><a href="#公用对象" class="headerlink" title="公用对象"></a>公用对象</h4><blockquote><p>Thymeleaf提供了一系列的公用对象，通过’#’访问</p></blockquote><ul><li>格式化时间<pre><code>  &lt;td th:text=&quot;${#dates.format(item.createTime,&#39;yyyy-MM-dd HH:mm:ss&#39;)}&quot;&gt;格式化时间&lt;/td&gt;</code></pre></li><li>判断是不是空字符<pre><code>  &lt;td th:if=&quot;${#strings.isEmpty(name)}&quot;&gt;空的&lt;/td&gt;</code></pre></li><li>是否包含(区分大小写)<pre><code>  &lt;td th:if=&quot;${#strings.contains(name,&#39;张三&#39;)}&quot;&gt;包含张三&lt;/td&gt;</code></pre></li></ul><hr><h4 id="遍历循环"><a href="#遍历循环" class="headerlink" title="遍历循环"></a>遍历循环</h4><hr><h5 id="遍历对象"><a href="#遍历对象" class="headerlink" title="遍历对象"></a>遍历对象</h5><pre><code>    &lt;ul th:each=&quot;User:${Users}&quot;&gt;      &lt;li th:text=&quot;${User.id}}&quot;&gt;&lt;/li&gt;      &lt;li th:text=&quot;${User.name}}&quot;&gt;&lt;/li&gt;    &lt;/ul&gt;</code></pre><blockquote><p>可以通过’th:each=”Object:${Object}”‘标签来遍历。</p></blockquote><h5 id="遍历分页"><a href="#遍历分页" class="headerlink" title="遍历分页"></a>遍历分页</h5><pre><code>    &lt;ul th:each=&quot;item:${page.content}&quot;&gt;      &lt;li th:text=&quot;item.id&quot;&gt;id&lt;/li&gt;      &lt;li th:text=&quot;item.title&quot;&gt;title&lt;/li&gt;    &lt;/ul&gt;</code></pre><blockquote><p>可以通过’th:each=”item:${page.content}”‘标签来处理page对象。</p></blockquote><h5 id="遍历列表"><a href="#遍历列表" class="headerlink" title="遍历列表"></a>遍历列表</h5><blockquote><p>使用’th:each=”item:${list}”‘<br>如果list只有一个元素，则用</p></blockquote><pre><code>    &lt;div th:each=&quot;item:${list}&quot;&gt;      &lt;li th:text=&quot;${item}&quot;&gt;&lt;/li&gt;    &lt;/div&gt;</code></pre><blockquote><p>如果list有多个元素，用</p></blockquote><pre><code>    &lt;div th:each=&quot;item:${list}&quot;&gt;      &lt;li th:text=&quot;${item.id}&quot;&gt;&lt;/li&gt;      &lt;li th:text=&quot;${item.name}&quot;&gt;&lt;/li&gt;    &lt;/div&gt;</code></pre><h5 id="遍历数组"><a href="#遍历数组" class="headerlink" title="遍历数组"></a>遍历数组</h5><pre><code>    &lt;div th:each=&quot;item:${arrays}&quot;&gt;      &lt;li th:text=&quot;item&quot;&gt;&lt;/li&gt;    &lt;/div&gt;</code></pre><blockquote><p>使用’th:each=”item:${arrays}”‘遍历数组</p></blockquote><h5 id="遍历集合"><a href="#遍历集合" class="headerlink" title="遍历集合"></a>遍历集合</h5><pre><code>    //遍历key    &lt;div th:each=&quot;item:${map}&quot;&gt;      &lt;li th:text=&quot;item.key&quot;&gt;&lt;/li&gt;    &lt;/div&gt;    //遍历value    &lt;div th:each=&quot;item:${map}&quot;&gt;      &lt;li th:text=&quot;item.value&quot;&gt;&lt;/li&gt;    &lt;/div&gt;    //遍历key-value    &lt;div th:each=&quot;item:${map}&quot;&gt;      &lt;li th:text=&quot;item&quot;&gt;&lt;/li&gt;    &lt;/div&gt;</code></pre><blockquote><p>通过’th:text=”${item.key}”‘显示集合的key，通过’th:text=”${item.value}”‘显示集合的value</p></blockquote><hr><h4 id="创建公共代码块"><a href="#创建公共代码块" class="headerlink" title="创建公共代码块"></a>创建公共代码块</h4><blockquote><p>当一个项目的头部(header)和尾部(footer)需要重复显示时，可以创建一个公共块，然后在需要重复使用的地方调用</p></blockquote><hr><h5 id="创建重复代码块"><a href="#创建重复代码块" class="headerlink" title="创建重复代码块"></a>创建重复代码块</h5><blockquote><p>可以使用th:fragment=”header”标签来标记重复代码块</p></blockquote><pre><code>&lt;div th:fragment=&quot;footer&quot;&gt;  重复的头部(header)&lt;/div&gt;</code></pre><h5 id="调用重复代码块"><a href="#调用重复代码块" class="headerlink" title="调用重复代码块"></a>调用重复代码块</h5><blockquote><p>使用th:include或th:replace标签调用。标签根据fragment值来调整</p></blockquote><pre><code>&lt;div th:replace=&quot;~{common :: header}&quot;&gt;&lt;/div&gt;&lt;div th:include=&quot;~{common :: footer}&quot;&gt;&lt;/div&gt;</code></pre><blockquote><p>th:include表示将当前标签替换为模板中的标签，th:replace表示只在当前标签内加载模板中的内容</p></blockquote><hr><h4 id="分页处理"><a href="#分页处理" class="headerlink" title="分页处理"></a>分页处理</h4><ol><li>控制器传入Page对象<pre><code> Pageable pageable = PageRequest.of(start, limit, sort); Page&lt;User&gt; page = userMapper.findAll(pageable); ModelAndView modelAndView = new ModelAndView(); modelAndView.addObject(&quot;pages&quot;,page); return modelAndView;</code></pre></li><li>接收Page对象并处理<pre><code> &lt;a th:href=&quot;@{/article(start=0)}&quot;&gt;首页&lt;/a&gt; &lt;a th:if=&quot;${not page.isLast()}&quot; th:href=&quot;@{/article(start=${page.number+1})}&quot;&gt;下一页&lt;/a&gt; &lt;a th:if=&quot;${not page.isFirst()}&quot; th:href=&quot;@{/article(start=${page.number-1})}&quot;&gt;上一页&lt;/a&gt; &lt;a th:href=&quot;@{/article(start=${page.totalPages-1})}&quot;&gt;尾页&lt;/a&gt;</code></pre><blockquote><p>th:if=”${not page.isFirst()}”表示判断当前页数是否为第一页。在Thymeleaf中可以直接调用对象的方法</p></blockquote></li></ol><hr><h2 id="实体类注入属性"><a href="#实体类注入属性" class="headerlink" title="实体类注入属性"></a>实体类注入属性</h2><blockquote><p>在需要注入的类上面加上注解：@Component和@ConfigurationProperties(prefix = “name”)</p></blockquote><pre><code>@Component  //等于创建了&lt;bean id=&quot;user&#39; class=&quot;cn.jbit.entity.User&quot;/&gt;。可以通过@Resources实现自动注入@ConfigurationProperties(prefix = &quot;user&quot;)public class User{  private String name;  private int age;}</code></pre><blockquote><p>在配置文件中根据prefix的名称注入属性</p></blockquote><pre><code>user.name=张三user.age=18</code></pre><blockquote><p>需要注意：如果注入中文，显示会报错。需要修改字符编码：设置-Editor-File Encodings</p></blockquote><p><img src="/2020/07/02/springboot-er/setUTF-8.png" alt="setUTF-8"></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nginx</title>
      <link href="/2020/07/01/nginx/"/>
      <url>/2020/07/01/nginx/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是Nginx"><a href="#什么是Nginx" class="headerlink" title="什么是Nginx"></a>什么是Nginx</h1><blockquote><p>Nginx是一款自由的、开源的、高性能的HTTP服务器和反向代理服务器；同时也是一个IMAP、POP3、SMTP代理服务器；Nginx可以作为一个HTTP服务器进行网站的发布处理，另外Nginx可以作为反向代理进行负载均衡的实现。</p></blockquote><hr><h2 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h2><blockquote><p>一个请求访问服务器时被称为正向代理，当访问的服务器又访问其他的服务器时，这时候对于请求而言就叫做反向代理</p></blockquote><ul><li>正向代理：代理的是客户端</li><li>反向代理：代理的是服务器</li></ul><h2 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h2><blockquote><p>将请求/数据均分到多个操作单元上执行。核心就是均衡的分摊压力。</p></blockquote><h4>Nginx</h4><p>轻量级，高性能的web服务器/反向代理服务器。通过反向代理实现负载均衡。</p><ol><li>使用tar -zxvf解压后开放80端口</li><li>使用在nginx目录下访问sbin/nginx启动nginx</li><li>启动成功后可以通过ps -ef|grep nginx查看是否启动成功</li><li>访问启动的ip即可进入Nginx</li></ol><h2 id="Nginx常用指令"><a href="#Nginx常用指令" class="headerlink" title="Nginx常用指令"></a>Nginx常用指令</h2><blockquote><p>注意：以下命令都是在Nginx根目录下执行。如果不在根路径则需要指定Nginx的完整路径</p></blockquote><pre><code>启动：sbin/nginx停止：sbin/nginx -s stop重启：sbin/nginx -s reload检查配置文件(nginx.conf)是否合法：sbin/nginx -t</code></pre><h2 id="Nginx结构"><a href="#Nginx结构" class="headerlink" title="Nginx结构"></a>Nginx结构</h2><blockquote><p>conf/nginx.conf：Nginx服务器的基础配置</p></blockquote><h3 id="文件结构"><a href="#文件结构" class="headerlink" title="文件结构"></a>文件结构</h3><ul><li>全局块<ul><li>用于指定全局的参数，如log的存放位置</li></ul></li><li>events块<ul><li>设置最大连接数</li></ul></li><li>http块<ul><li>主体部分，嵌套多个server。配置反向代理提供负载均衡支持</li></ul></li><li>server块<ul><li>配置虚拟主机的相关参数，有多少个主机就需要配置多少个server块</li></ul></li><li>location块<ul><li>请求url过滤，正则匹配</li></ul></li></ul><h4 id="server说明"><a href="#server说明" class="headerlink" title="server说明"></a>server说明</h4><pre><code># 表示一个主机server{    listen 80;  #80端口    server_name localhost; #访问地址    # /表示访问localhost即可访问    location /{    root html;    index index.html index.htm    }     # 表示500,502，503,504错误时跳转到50x.html    error_page 500,502,503,504 /50x.html    location = 50x.html{    root html;    }}</code></pre><h3 id="构建反向代理"><a href="#构建反向代理" class="headerlink" title="构建反向代理"></a>构建反向代理</h3><blockquote><p>Nginx只处理静态内容(前端)，动态内容(后端)给tomcat处理</p></blockquote><pre><code># 负载均衡的配置upstrean itripbiz_server{    server 127.0.0.1:8080;}server{    listen 80;    server_name test;    root /data/itrip/itripfront; # root表示CentOS的根目录，指向部署在Nginx的前端静态工程路径    location / {    # 将request请求中的host和客户端的真实IP代理到tomcat，如果不配置则后端获取到的为代理后的内容    proxy_set_header Host $host;        proxy_set_header X-Real-IP $remote_addr;    proxy_pass https://itripbiz_server # 反向代理地址。    }}</code></pre><blockquote><p>注意：反向代理地址的名字要和upstrean的名字一致</p></blockquote><pre><code># 表示保留缓存location ~ .*\.(gif|jpg|png|html|mp3){    表示缓存的保留时间    expires 6h;}location ~ .*\.(css|js){    expires 2h;}</code></pre><pre><code># 配置日志文件。由于在http块中配置，所有不是全局配置access_log /data/logs/nginx/app_access.log;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 软件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用功能</title>
      <link href="/2020/06/30/chang-yong-gong-neng/"/>
      <url>/2020/06/30/chang-yong-gong-neng/</url>
      
        <content type="html"><![CDATA[<h2 id="Swagger"><a href="#Swagger" class="headerlink" title="Swagger"></a>Swagger</h2><h3 id="什么是Swagger"><a href="#什么是Swagger" class="headerlink" title="什么是Swagger"></a>什么是Swagger</h3><blockquote><p>Swagger前后端分离使用的一个功能</p></blockquote><h3 id="使用swagger"><a href="#使用swagger" class="headerlink" title="使用swagger"></a>使用swagger</h3><blockquote><p>在pom.xml导入对应的jar包</p></blockquote><pre><code>&lt;dependency&gt;    &lt;groupId&gt;io.springfox&lt;/groupId&gt;    &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt;    &lt;version&gt;2.6.1&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;io.springfox&lt;/groupId&gt;    &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt;    &lt;version&gt;2.6.1&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;com.google.guava&lt;/groupId&gt;    &lt;artifactId&gt;guava&lt;/artifactId&gt;    &lt;version&gt;19.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;    &lt;artifactId&gt;fastjson&lt;/artifactId&gt;    &lt;version&gt;1.2.47&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;    &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;    &lt;version&gt;2.9.0&lt;/version&gt;&lt;/dependency&gt;</code></pre><blockquote><p>创建一个swagger类，继承WebMvcConfigurationSupport。同时在类上面加上注解：@ComponentScan(basePackages=(“cn.jbit.controller”))</p></blockquote><pre><code>@EnableSwagger2@Configuration</code></pre><blockquote><p>ComponentScan：括号内写入控制层的地址</p></blockquote><p>在springmvc.xml(SpringMVC)配置文件内加入&lt;mvc:default-servlet-handler&gt;。并且在扫描控制层的代码内加入swagger所在的包路径，让swagger和控制层能一起扫描</p><pre><code>&lt;context:component-scan base-package=&quot;cn.jbit.controller,cn.jbit.swagger&quot;/&gt;</code></pre><ul><li>在类上面加上@Api(value=”userController”,description=”说明”)注解，用作网页访问时的类说明</li><li>在方法上面加上@ApiOperation(value=”说明”,notes=”说明”)注解，用作房爷访问时方法的说明</li><li>在网页输入localhost:8080/项目名称/swagger-ui.html即可访问控制层和里面的方法。</li></ul><blockquote><blockquote><p>注意：如果在创建控制层方法时没有指定连接方式，则会在网页显示所有的连接方式，如get,psot等。所以建议在使用@RequestMapper()注解时加上属性：method = RequestMethod.GET用于指定连接的方式</p></blockquote></blockquote><hr><h2 id="JavaMail"><a href="#JavaMail" class="headerlink" title="JavaMail"></a>JavaMail</h2><blockquote><p>创建一个userService类，里面写发送邮件和验证邮件的方法。ServiceImpl内加上@Service注解，和对象</p></blockquote><pre><code>@Resourceprivate ItripUserDao itripUserDao;    //添加对象信息@Resourceprivate MailService mailService;    //发送邮件@Resourceprivate RedisAPI redisAPI;        //将信息添加到Redis中</code></pre><h3 id="发送邮件"><a href="#发送邮件" class="headerlink" title="发送邮件"></a>发送邮件</h3><pre><code>void itriptxcreateUser(User user);</code></pre><blockquote><p>增加用户信息、生成激活码、发送邮件、激活码存入redis</p></blockquote><ol><li>添加用户信息<ul><li>使用dao层的添加方法将注册的信息添加到数据库，配置dao层的对象。注意自动注入</li></ul></li><li>生成激活码<ul><li>使用MD5加密生成随机激活码，调用MD5的静态方法生成随机码</li></ul></li><li>发送邮件<ul><li>创建MailServer和impl实现发送方法：sendActivationMail，注意配置Mailserver对象，并自动注入</li></ul></li><li>激活码存入redis<ul><li>创建redisAPI，调用set方法存入数据，注意配置redisAPI对象，并自动注入</li></ul></li></ol><hr><h3 id="配置配置文件信息"><a href="#配置配置文件信息" class="headerlink" title="配置配置文件信息"></a>配置配置文件信息</h3><h3>sendActivationMail方法：(传入收件地址和激活码)</h3><pre><code>@Resourceprivate SimpleMailMessage simpleMailMessage;@Resourceprivate MailSender mailSender;@Overridepublic void sendActivationMail(String mailTo, String activationCode) {    simpleMailMessage.setTo(mailTo);    simpleMailMessage.setText(&quot;您的激活码为：&quot;+activationCode+&quot;；请在30分钟内激活。&quot;);    mailSender.send(simpleMailMessage);}</code></pre><hr><h3>MailServerImpl的配置文件。装配在applicationContext中。</h3><pre><code>&lt;bean id=&quot;simpleMailMessage&quot; class=&quot;org.springframework.mail.SimpleMailMessage&quot;&gt;    &lt;property name=&quot;subject&quot; value=&quot;[i旅行]请激活您的账户&quot;&gt;&lt;/property&gt;    &lt;property name=&quot;from&quot; value=&quot;x18570421676@163.com&quot;&gt;&lt;/property&gt;&lt;/bean&gt;&lt;bean id=&quot;mailSender&quot; class=&quot;org.springframework.mail.javamail.JavaMailSenderImpl&quot;&gt;    &lt;property name=&quot;host&quot; value=&quot;smtp.163.com&quot;&gt;&lt;/property&gt;    &lt;property name=&quot;port&quot; value=&quot;465&quot;&gt;&lt;/property&gt;    &lt;property name=&quot;username&quot; value=&quot;x18570421676@163.com&quot;&gt;&lt;/property&gt;    &lt;property name=&quot;password&quot; value=&quot;LCMTFLISFFDMKUGK&quot;&gt;&lt;/property&gt;    &lt;property name=&quot;defaultEncoding&quot; value=&quot;UTF-8&quot;&gt;&lt;/property&gt;    &lt;property name=&quot;javaMailProperties&quot;&gt;        &lt;props&gt;            &lt;!-- 用户验证 --&gt;            &lt;prop key=&quot;mail.smtp.auth&quot;&gt;true&lt;/prop&gt;            &lt;prop key=&quot;mail.smtp.socketFactory.class&quot;&gt;javax.net.ssl.SSLSocketFactory&lt;/prop&gt;            &lt;prop key=&quot;mail.smtp.socketFactory.port&quot;&gt;465&lt;/prop&gt;        &lt;/props&gt;    &lt;/property&gt;&lt;/bean&gt;</code></pre><ul><li>subject<ul><li>发送的邮件标题</li></ul></li><li>from<ul><li>发送人邮件地址</li></ul></li><li>host<ul><li>发送邮件的服务器地址，去百度自己邮箱的服务器地址</li></ul></li><li>port<ul><li>协议端口口，同样去百度自己发邮件的协议端口</li></ul></li><li>username<ul><li>和发件人邮件地址同名</li></ul></li><li>password<ul><li>邮箱授权码</li></ul></li></ul><hr><h3>redisAPI类</h3><pre><code>private JedisPool jedisPool;public JedisPool getJedisPool() {    return jedisPool;}public void setJedisPool(JedisPool jedisPool) {    this.jedisPool = jedisPool;}/**    * set    * @param key    * @param value    */public String set(String key, String value){    Jedis jedis = jedisPool.getResource();    String result = jedis.set(key, value);    jedisPool.returnResource(jedis);    return result;}/**    * set    * @param key    * @param value    */public String set(String key, String value, int exprice){    Jedis jedis = jedisPool.getResource();    String result = jedis.setex(key, exprice, value);    jedisPool.returnResource(jedis);    return result;}/**    * get    * @param key    * @return    */public String get(String key){    Jedis jedis = jedisPool.getResource();    String value = jedis.get(key);    jedisPool.returnResource(jedis);    return value;}/**    * exists    * @param key    */public boolean exists(String key){    Jedis jedis = jedisPool.getResource();    boolean result = jedis.exists(key);    jedisPool.returnResource(jedis);    return  result;}/**    * ttl    * @param key    */public Long ttl(String key){    Jedis jedis = jedisPool.getResource();    Long result = jedis.ttl(key);    jedisPool.returnResource(jedis);    return  result;}/**    * del    * @param key    */public Long del(String key){    Jedis jedis = jedisPool.getResource();    long result = jedis.del(key);    jedisPool.returnResource(jedis);    return  result;}</code></pre><hr><h2 id="Token"><a href="#Token" class="headerlink" title="Token"></a>Token</h2><h3 id="创建Token"><a href="#创建Token" class="headerlink" title="创建Token"></a>创建Token</h3><blockquote><p>传入两个参数：request.getHeader(“user-agent”)和登录成功的对象</p></blockquote><pre><code>/** * Tock格式 * PC-USERCODE-USERID-CREATIONDATE-RONDEM[6位] * 客户端类型-用户的UserCode-用户的ID-当前时间-6位随机数 * @param userAgent * @param itripUser * @return */@Overridepublic String getTokens(String userAgent, ItripUser itripUser) {    StringBuffer token = new StringBuffer(&quot;&quot;);    //前缀    token.append(&quot;token:&quot;);    //获取客户端类型    UserAgent agent = UserAgent.parseUserAgentString(userAgent);    //判断是否为移动设备    if(agent.getOperatingSystem().isMobileDevice()){        //移动设备        token.append(&quot;MOBILE-&quot;);    }else{        //电脑端        token.append(&quot;PC-&quot;);    }    //用户的UserCode    token.append(MD5.getMd5(itripUser.getUsercode(), 32)+&quot;-&quot;);    //用户的ID    token.append(itripUser.getId().toString()+&quot;-&quot;);    //当前时间(年-月-日 时:分:秒)    token.append(new SimpleDateFormat(&quot;yyyy-MM-ddHH:mm:ss&quot;).format(new Date())+&quot;-&quot;);    //6位随机数    token.append(MD5.getMd5(userAgent, 6));    return token.toString();}</code></pre><h2 id="SpringBoot热部署"><a href="#SpringBoot热部署" class="headerlink" title="SpringBoot热部署"></a>SpringBoot热部署</h2><h3 id="SpringBoot的热部署方式"><a href="#SpringBoot的热部署方式" class="headerlink" title="SpringBoot的热部署方式"></a>SpringBoot的热部署方式</h3><blockquote><p>springboot有3中热部署方式</p></blockquote><ol><li><p>使用springloaded配置pom.xml文件，使用mvn spring-boot:run启动</p></li><li><p>使用springloaded本地加载启动，配置jvm参数</p></li><li><p>使用devtools工具包，操作简单，但是每次需要重新部署</p></li></ol><p>这里使用devtools完成热部署</p><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><blockquote><p>pom.xml配置</p></blockquote><pre><code>&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;    &lt;optional&gt;true&lt;/optional&gt;    &lt;scope&gt;true&lt;/scope&gt;&lt;/dependency&gt;</code></pre><blockquote><p>application.yml配置</p></blockquote><pre><code>spring:  thymeleaf:   cache: false</code></pre><h3 id="devtools的配置"><a href="#devtools的配置" class="headerlink" title="devtools的配置"></a>devtools的配置</h3><blockquote><p>在application.yml中配置devtools</p></blockquote><pre><code>spring:  devtools:    restart:      enabled: true  #设置开启热部署      additional-paths: src/main/java #重启目录      exclude: WEB-INF/**  freemarker:    cache: false</code></pre><h3 id="IDEA中配置"><a href="#IDEA中配置" class="headerlink" title="IDEA中配置"></a>IDEA中配置</h3><blockquote><p>当修改了类文件后，idea不会自动编译，得修改idea设置。</p></blockquote><ol><li>File-Settings-Compiler-Build Project automatically</li><li>ctrl + shift + alt + / ,选择Registry,勾上 Compiler autoMake allow when app running</li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swagger </tag>
            
            <tag> JavaMail </tag>
            
            <tag> Token </tag>
            
            <tag> devtools </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Solr和Reds的基本使用</title>
      <link href="/2020/06/23/solr-he-reds-de-ji-ben-shi-yong/"/>
      <url>/2020/06/23/solr-he-reds-de-ji-ben-shi-yong/</url>
      
        <content type="html"><![CDATA[<h1 id="solr是什么"><a href="#solr是什么" class="headerlink" title="solr是什么"></a>solr是什么</h1><blockquote><p>Solr是一个独立的企业级搜索应用服务器，它对外提供类似于Web-service的API接口。用户可以通过http请求，向搜索引擎服务器提交一定格式的XML文件，生成索引</p></blockquote><hr><h2 id="redis的使用"><a href="#redis的使用" class="headerlink" title="redis的使用"></a>redis的使用</h2><h3 id="redis的连接方式"><a href="#redis的连接方式" class="headerlink" title="redis的连接方式"></a>redis的连接方式</h3><hr><h4 id="xml文件配置"><a href="#xml文件配置" class="headerlink" title="xml文件配置"></a>xml文件配置</h4><blockquote><p>xml文件内容</p></blockquote><pre><code>&lt;bean id=&quot;jedisPoolConfig&quot; class=&quot;redis.clients.jedis.JedisPoolConfig&quot;&gt;    &lt;property name=&quot;maxActive&quot; value=&quot;300&quot;&gt;&lt;/property&gt;    &lt;property name=&quot;maxIdle&quot; value=&quot;100&quot;&gt;&lt;/property&gt;    &lt;property name=&quot;maxWait&quot; value=&quot;10000&quot;&gt;&lt;/property&gt;    &lt;property name=&quot;testOnBorrow&quot; value=&quot;true&quot;&gt;&lt;/property&gt;&lt;/bean&gt;&lt;bean id=&quot;jedisPool&quot; class=&quot;redis.clients.jedis.JedisPool&quot; destroy-method=&quot;destroy&quot;&gt;    &lt;constructor-arg ref=&quot;jedisPoolConfig&quot;&gt;&lt;/constructor-arg&gt;    &lt;constructor-arg value=&quot;192.168.179.128&quot;&gt;&lt;/constructor-arg&gt; //连接地址    &lt;constructor-arg value=&quot;6379&quot;&gt;&lt;/constructor-arg&gt;    &lt;constructor-arg value=&quot;100000&quot;&gt;&lt;/constructor-arg&gt;    &lt;constructor-arg value=&quot;administrator&quot;&gt;&lt;/constructor-arg&gt;    &lt;constructor-arg value=&quot;0&quot;&gt;&lt;/constructor-arg&gt;&lt;/bean&gt;&lt;bean id=&quot;redisAPI&quot; class=&quot;cn.jbit.tool.RedisAPI&quot;&gt; // redis工具类的位置    &lt;property name=&quot;jedisPool&quot; ref=&quot;jedisPool&quot;&gt;&lt;/property&gt;&lt;/bean&gt;</code></pre><blockquote><p>redis工具类</p></blockquote><pre><code>private JedisPool jedisPool;Jedis jedis = jedisPool.getResource();</code></pre><hr><h4 id="无参构造器配置"><a href="#无参构造器配置" class="headerlink" title="无参构造器配置"></a>无参构造器配置</h4><pre><code>Jedis jedis = new Jedis(‘127.0.0.1’, 6379, 0)</code></pre><blockquote><p>注意：如果redis配置了密码则无法通过无参构造器进行配置</p></blockquote><h3 id="配置redis的工具类"><a href="#配置redis的工具类" class="headerlink" title="配置redis的工具类"></a>配置redis的工具类</h3><pre><code>/*** 设置不过期的key* @param key* @param value*/public String set(String key, String value){    Jedis jedis = jedisPool.getResource();    String result = jedis.set(key, value);    jedisPool.returnResource(jedis);    return result;}/**    * 设置带过期时间的    * @param key    * @param value    */public String set(String key, String value, int exprice){    Jedis jedis = jedisPool.getResource();    String result = jedis.setex(key, exprice, value);    jedisPool.returnResource(jedis);    return result;}/**    * 根据key获取值    * @param key    * @return    */public String get(String key){    Jedis jedis = jedisPool.getResource();    String value = jedis.get(key);    jedisPool.returnResource(jedis);    return value;}/**    * 判断是否存在    * @param key    */public boolean exists(String key){    Jedis jedis = jedisPool.getResource();    boolean result = jedis.exists(key);    jedisPool.returnResource(jedis);    return  result;}/**    * 获取key的有效时间    * @param key    */public Long ttl(String key){    Jedis jedis = jedisPool.getResource();    Long result = jedis.ttl(key);    jedisPool.returnResource(jedis);    return  result;}/**    * 根据key删除值    * @param key    */public Long del(String key){    Jedis jedis = jedisPool.getResource();    long result = jedis.del(key);    jedisPool.returnResource(jedis);    return  result;}</code></pre><hr><h2 id="solr的使用"><a href="#solr的使用" class="headerlink" title="solr的使用"></a>solr的使用</h2><h3 id="solr的配置"><a href="#solr的配置" class="headerlink" title="solr的配置"></a>solr的配置</h3><blockquote><p>将mysql-connector-java-5.1.10.jar放在tomcat的lib目录下<br>将solr-dataimporthandler-4.9.1.jar和solr-dataimporthandler-extras-4.9.1.jar放在solr的web目录下的lib目录内</p></blockquote><hr><h4 id="配置solrconfig-xml"><a href="#配置solrconfig-xml" class="headerlink" title="配置solrconfig.xml"></a>配置solrconfig.xml</h4><blockquote><p>在solrconfig.xml里的&lt;requestHandler&gt; name=”/query”标签上方进行配置</p></blockquote><pre><code>&lt;requestHandler name=&quot;/dataimport&quot; class=&quot;org.apache.solr.handler.dataimport.DataImportHandler&quot;&gt;    &lt;lst name=&quot;defaults&quot;&gt;        &lt;str name=&quot;config&quot;&gt;data-config.xml&lt;/str&gt;    &lt;/lst&gt;&lt;/requestHandler&gt;</code></pre><hr><h4 id="配置data-config-xml"><a href="#配置data-config-xml" class="headerlink" title="配置data-config.xml"></a>配置data-config.xml</h4><blockquote><p>在solrconfig.xml同目录内创建data-config.xml文件</p></blockquote><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;gb2312&quot; ?&gt;&lt;dataConfig&gt;    &lt;dataSource type=&quot;JdbcDataSource&quot; driver=&quot;com.mysql.jdbc.Driver&quot;                url=&quot;jdbc:mysql://localhost/itripdb&quot; user=&quot;root&quot; password=&quot;root&quot;/&gt;    &lt;document name=&quot;HotelDocument&quot;&gt;        &lt;entity name=&quot;test&quot; query=&quot;select id, hotelName, countryId, provinceId, cityId, address, hotelType, hotelLevel, isGroupPurchase, redundantCityName, redundantProvinceName, redundantCountryName, redundantHotelStore, creationDate, createdBy, modifyDate, modifiedBy, details, facilities, hotelPolicy from itrip_hotel&quot; pk=&quot;id&quot;                deltaImportQuery=&quot;select id, hotelName, countryId, provinceId, cityId, address, hotelType, hotelLevel, isGroupPurchase, redundantCityName, redundantProvinceName, redundantCountryName, redundantHotelStore, creationDate, createdBy, modifyDate, modifiedBy, details, facilities, hotelPolicy from itrip_hotel where id=&#39;${dih.delta.id}&#39;&quot;                deltaQuery=&quot;select id as id from itrip_hotel where modifyDate &gt; &#39;${dih.last_index_time}&#39;&quot;&gt;            &lt;field column=&quot;id&quot; name=&quot;id&quot; /&gt;            &lt;field column=&quot;hotelName&quot; name=&quot;hotelName&quot; /&gt;            &lt;field column=&quot;countryId&quot; name=&quot;countryId&quot; /&gt;            &lt;field column=&quot;provinceId&quot; name=&quot;provinceId&quot; /&gt;            &lt;field column=&quot;cityId&quot; name=&quot;cityId&quot; /&gt;            &lt;field column=&quot;address&quot; name=&quot;address&quot; /&gt;            &lt;field column=&quot;hotelType&quot; name=&quot;hotelType&quot; /&gt;            &lt;field column=&quot;hotelLevel&quot; name=&quot;hotelLevel&quot; /&gt;            &lt;field column=&quot;isGroupPurchase&quot; name=&quot;isGroupPurchase&quot; /&gt;            &lt;field column=&quot;redundantCityName&quot; name=&quot;redundantCityName&quot; /&gt;            &lt;field column=&quot;redundantProvinceName&quot; name=&quot;redundantProvinceName&quot; /&gt;            &lt;field column=&quot;redundantCountryName&quot; name=&quot;redundantCountryName&quot; /&gt;            &lt;field column=&quot;redundantHotelStore&quot; name=&quot;redundantHotelStore&quot; /&gt;            &lt;field column=&quot;creationDate&quot; name=&quot;creationDate&quot; /&gt;            &lt;field column=&quot;createdBy&quot; name=&quot;createdBy&quot; /&gt;            &lt;field column=&quot;modifyDate&quot; name=&quot;modifyDate&quot; /&gt;            &lt;field column=&quot;modifiedBy&quot; name=&quot;modifiedBy&quot; /&gt;            &lt;field column=&quot;details&quot; name=&quot;details&quot; /&gt;            &lt;field column=&quot;facilities&quot; name=&quot;facilities&quot; /&gt;            &lt;field column=&quot;hotelPolicy&quot; name=&quot;hotelPolicy&quot; /&gt;        &lt;/entity&gt;    &lt;/document&gt;&lt;/dataConfig&gt;</code></pre><blockquote><p>最后在schema.xml文件内配置与列名对应的&lt;field&gt;标签</p></blockquote><pre><code>&lt;field name=&quot;id&quot; type=&quot;int&quot; indexed=&quot;true&quot; stored=&quot;true&quot;/&gt;</code></pre><blockquote><p>可以选择加入复合列</p></blockquote><pre><code>&lt;field name=&quot;keys&quot; type=&quot;text_ik&quot; indexed=&quot;true&quot; stored=&quot;true&quot; multiValued=&quot;true&quot;/&gt;//需要组合的列&lt;copyField source=&quot;hotelName&quot; dest=&quot;keys&quot;&gt;&lt;/copyField&gt; &lt;copyField source=&quot;address&quot; dest=&quot;keys&quot;&gt;&lt;/copyField&gt;</code></pre><hr><h3 id="solr分词器的配置"><a href="#solr分词器的配置" class="headerlink" title="solr分词器的配置"></a>solr分词器的配置</h3><hr><blockquote><p>将IKAnalyzer2012FF_u1.jar放在solr的web目录下的lib目录内<br>将IKAnalyzer.cfg.xm和stopword.dic放在solr的web目录的classes目录内</p></blockquote><blockquote><p>在schema.xml的schema标签内加入分词器的元素，然后将需要分词的列的type改为text_ik</p></blockquote><pre><code>&lt;fieldType name=&quot;text_ik&quot; class=&quot;solr.TextField&quot;&gt;    &lt;analyzer type=&quot;index&quot;  isMaxWordLength=&quot;false&quot; class=&quot;org.wltea.analyzer.lucene.IKAnalyzer&quot;/&gt;    &lt;analyzer type=&quot;query&quot;  isMaxWordLength=&quot;true&quot; class=&quot;org.wltea.analyzer.lucene.IKAnalyzer&quot;/&gt;&lt;/fieldType&gt;</code></pre><h3 id="solr在java中的使用"><a href="#solr在java中的使用" class="headerlink" title="solr在java中的使用"></a>solr在java中的使用</h3><hr><blockquote><p>创建一个工具类，工具类后面使用T泛型</p></blockquote><pre><code>public class BaseDao&lt;T&gt;{    private HttpSolrClient httpSolrClient;}</code></pre><blockquote><p>通过有参构造器传入solr的地址来实现选择不同的solr_home</p></blockquote><pre><code>public BaseDao(String url){    //创建HttpSolrClient    httpSolrClient = new HttpSolrClient(url);    //配置解析器    httpSolrClient.setParser(new XMLResponseParser());    //设置响应时间，时间超过设置时间抛出异常    httpSolrClient.setConnectionTimeout(1000);}</code></pre><blockquote><p>传入查询条件(solrQuery)和返回的类型来执行solr并获取返回的list</p></blockquote><pre><code>public List&lt;T&gt; SolrHote(SolrQuery solrQuery, Class type){    List&lt;T&gt; list = null;    try {        QueryResponse response = httpSolrClient.query(solrQuery);        list = response.getBeans(type);    } catch (SolrServerException e) {        e.printStackTrace();    } catch (IOException e) {        e.printStackTrace();    } finally {        return list;    }}</code></pre><blockquote><p>使用的示例</p></blockquote><pre><code>// 通过有参构造方法传入solr地址private BaseDao&lt;User&gt; baseDao = new BaseDao()&lt;&quot;http://localhost:8080/solr/User&quot;&gt;;// 获取solr查询的数据public void test(){    // 查询条件。如果通过有参构造器创建，则表示使用Q查询。通过键值对的方式传入查询条件    SolrQuery solrQuery = new SolrQuery(&quot;*:*&quot;);    // FQ查询。通过键值对的方式传入查询条件    solrQuery.setParam(&quot;keys:test&quot;);    // 分页查询    solrQuery.setStart(0);  // 当前页数    solrQuery.setRows(10);  // 每页显示多少行    // 查询的排序方式    solrQuery.setSort(&quot;id&quot;,SolrQuery.ORDER.asc);    // 通过id执行升序查询    solrQuery.setSort(&quot;id&quot;,SolrQuery.ORDER.desc);   // 通过id执行降序查询    // 执行查询方法    List&lt;User&gt; list = baseDao.SolrHote(solrQuery, User.class);}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
            <tag> solr </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot基础</title>
      <link href="/2020/06/13/springboot-ji-chu/"/>
      <url>/2020/06/13/springboot-ji-chu/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是SpringBoot"><a href="#什么是SpringBoot" class="headerlink" title="什么是SpringBoot"></a>什么是SpringBoot</h1><blockquote><p>Spring Boot是由Pivotal团队提供的全新框架，其设计目的是用来简化新Spring应用的初始搭建以及开发过程。该框架使用了特定的方式来进行配置，从而使开发人员不再需要定义样板化的配置。通过这种方式，Spring Boot致力于在蓬勃发展的快速应用开发领域(rapid application development)成为领导者</p></blockquote><hr><h2 id="SpringBoot的优势"><a href="#SpringBoot的优势" class="headerlink" title="SpringBoot的优势"></a>SpringBoot的优势</h2><h3 id="简化配置"><a href="#简化配置" class="headerlink" title="简化配置"></a>简化配置</h3><blockquote><p>SpringBoot是对Spring的进一步封装，基于注解开发。并舍弃笨重的xml，使用yml和properties进行简要的配置即可。</p></blockquote><h3 id="产品级独立运行"><a href="#产品级独立运行" class="headerlink" title="产品级独立运行"></a>产品级独立运行</h3><blockquote><p>每一个工程都可打包成一个jar包。其中配置了tomcat和其他servlet容器，可独立运行。这是和微服务最契合的一点。</p></blockquote><h3 id="强大的场景启动器"><a href="#强大的场景启动器" class="headerlink" title="强大的场景启动器"></a>强大的场景启动器</h3><blockquote><p>每一个特殊的场景需求都封装成了一个starter，只需导入这个既有了这个场景所需的一切。其中包括自动化配置和依赖信息等。</p></blockquote><hr><h2 id="SpringBoot工作部分"><a href="#SpringBoot工作部分" class="headerlink" title="SpringBoot工作部分"></a>SpringBoot工作部分</h2><ol><li>starter依赖：引入特定功能的自动装配类和所需的依赖</li><li>@EnableXxxx注解：启动某种功能</li><li>yml或properties配置：进行配置</li><li>主启动类：每个程序必须有一个主启动类</li></ol><hr><h2 id="使用SpringBoot"><a href="#使用SpringBoot" class="headerlink" title="使用SpringBoot"></a>使用SpringBoot</h2><blockquote><p>本次使用为maven项目。同时也可使用自带的模板创建，也可以手动创建maven项目然后自己配置</p></blockquote><h3 id="使用模板"><a href="#使用模板" class="headerlink" title="使用模板"></a>使用模板</h3><p>创建spring starter project项目，在Available搜索框搜索Spring web并将其勾选即可创建SpringBoot项目模板</p><blockquote><p>注意：需要在properties标签内加入子标签&lt;maven-jar-plugin.version&gt;3.0.0&lt;/maven-jar-plugin.version&gt;</p></blockquote><h3 id="手动创建SpringBoot项目"><a href="#手动创建SpringBoot项目" class="headerlink" title="手动创建SpringBoot项目"></a>手动创建SpringBoot项目</h3><blockquote><p>配置pom.xml</p></blockquote><pre><code>&lt;!-- 继承SpringBoot官方指定的父工程 --&gt;&lt;parent&gt;    &lt;groupId&gt;org.springframework-boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;    &lt;version&gt;2.1.6&lt;/version&gt;&lt;/parent&gt;&lt;dependencies&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;&lt;!-- Maven构建过程相关配置 --&gt;&lt;build&gt;    &lt;!-- 构建过程中用到的插件 --&gt;    &lt;plugins&gt;        &lt;!-- 将SpringBoot打包成一个可执行的jar包 --&gt;        &lt;plugin&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;        &lt;/plugin&gt;    &lt;/plugins&gt;&lt;/build&gt;</code></pre><blockquote><p>创建主启动类</p></blockquote><pre><code>@SpringBootApplicationpublic class helloWorld{    public static void main(String[] args){    SpringApplication.run(helloWorld.class,args);    }}</code></pre><hr><h2 id="运行SpringBoot"><a href="#运行SpringBoot" class="headerlink" title="运行SpringBoot"></a>运行SpringBoot</h2><h3 id="在Eclipse上运行SpringBoot"><a href="#在Eclipse上运行SpringBoot" class="headerlink" title="在Eclipse上运行SpringBoot"></a>在Eclipse上运行SpringBoot</h3><p>创建Controller后点击工具类里面的boot dashboard。然后在下面出现的boot dashboard窗口点击load下拉框，点击需要启动的项目右键start运行即可。</p><blockquote><p>注意：这种启动方式不需要在<a href="http://localhost:8080/后面加项目名称，直接输入控制器的访问名称即可正常访问" target="_blank" rel="noopener">http://localhost:8080/后面加项目名称，直接输入控制器的访问名称即可正常访问</a></p></blockquote><h3 id="运行StringBootjar包"><a href="#运行StringBootjar包" class="headerlink" title="运行StringBootjar包"></a>运行StringBootjar包</h3><p>生成项目jar包：右键项目，运行Maven-install即可生成jar包<br><br>在cmd里面进入到jar包所在的文件位置，输入java -jar xxx.jar运行命令<br></p><blockquote><p>注意：生成jar包时可能会出现Perhaps you are running on a JRE rather than a JDK和Unable to find a @SpringBootConfiguration错误<br><br>Perhaps you are running on a JRE rather than a JDK：</p></blockquote><p>进入Window-Preferences-Execution Environments选择jdkSE版本，从右侧添加对应的jdk<br><br>Unable to find a @SpringBootConfiguration：进入scr/test/java里的测试类，将类上面的注解换成：SpringBootTest(classes = BootTestApplication.class)。里面映射的类是启动类</p><hr><h2 id="SpringBoot扫描方式"><a href="#SpringBoot扫描方式" class="headerlink" title="SpringBoot扫描方式"></a>SpringBoot扫描方式</h2><hr><h3 id="默认扫描"><a href="#默认扫描" class="headerlink" title="默认扫描"></a>默认扫描</h3><blockquote><p>会自动扫描主启动类所在的包和所在的子包</p></blockquote><hr><h3 id="自定义扫描"><a href="#自定义扫描" class="headerlink" title="自定义扫描"></a>自定义扫描</h3><blockquote><p>在主启动类上面加上注解：@ComponentScan。使用这个注解即可自己制定扫描的路径，如：@ComponentScan(“cn.jbit.controller”)</p></blockquote><blockquote><p>注意：自己指定扫描路径后默认扫描会失效</p></blockquote><hr><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><blockquote><p>如果想自定义某些功能，则需要去main/resources目录下的application.properties或application.yml里配置对应的功能</p></blockquote><hr><h3 id="properties的常用配置"><a href="#properties的常用配置" class="headerlink" title="properties的常用配置"></a>properties的常用配置</h3><pre><code>server.port=?：//设置启动的端口号server.servlet.context-path=/?：//连接地址，必须用/开头</code></pre><hr><h3 id="yml语法"><a href="#yml语法" class="headerlink" title="yml语法"></a>yml语法</h3><blockquote><p>例如有两个语法：server.port=1000和server.servlet.context-path=/test，则可以写成：</p></blockquote><pre><code>server:  port: 1000 servlet:   context-path: /test</code></pre><blockquote><p>注意：同数量的空格表示为同级目录，在写完:后需要加上空格 </p></blockquote><h4 id="使用yml的配置"><a href="#使用yml的配置" class="headerlink" title="使用yml的配置"></a>使用yml的配置</h4><p>yml配置</p><pre><code>age: 18name: 张三</code></pre><p>类中的使用</p><pre><code>import org.springframework.beans.factory.annotation.Value;public class user{    @Value(&quot;${age})    private String name;    @Value(&quot;${name})    private int age;}</code></pre><hr><h4 id="值的类型"><a href="#值的类型" class="headerlink" title="值的类型"></a>值的类型</h4><p>字面量：<br><br>普通的字符串，数值，布尔类型。</p><blockquote><p>注意：如果是0开头的一串数字因为会被SpringBoot按照8进制数据解析，所以则需要用’将内容包括起来</p></blockquote><hr><h4 id="对象，Map"><a href="#对象，Map" class="headerlink" title="对象，Map"></a>对象，Map</h4><blockquote><p>常规写法：</p></blockquote><pre><code>user:  id: 10 age: 18 name: 张三</code></pre><p>行内写法：user: {id: 10,age: 18,name: 张三}</p><blockquote><p>注意：行内写法的:后面需要加上空格</p></blockquote><hr><h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><blockquote><p>常规写法：</p></blockquote><pre><code>user:  age:  - 18 - 20 - 18</code></pre><hr><h4 id="行内写法"><a href="#行内写法" class="headerlink" title="行内写法"></a>行内写法</h4><pre><code>user:  age: [18,20,18]</code></pre><blockquote><p>注意：-后面需要接空格</p></blockquote><hr><h2 id="配置文件中的值注入bean"><a href="#配置文件中的值注入bean" class="headerlink" title="配置文件中的值注入bean"></a>配置文件中的值注入bean</h2><blockquote><p>如果不使用注解改变日期格式，默认为xxxx/xx/xx的格式，可以在Date格式上面加上注解：@DateTimeFormat(pattern = “yyyy-MM-dd HH:mm:ss”)来改变注入的形式，加上注解后格式就变成了XXXX-XX-XX XX:XX:XX的格式</p></blockquote><h3 id="使用yml完成注入"><a href="#使用yml完成注入" class="headerlink" title="使用yml完成注入"></a>使用yml完成注入</h3><blockquote><p>在需要注入的类上面加上注解：@component。该注解将需要注入的类加入ioc容器。然后使用@ConfigurationProperties(prefix=””)。这个注解可以将yml里的属性注入到类中</p></blockquote><p>日期默认格式是使用/分隔<br></p><p>在测试类(?)上面加上@RunWith(SpringRunner.class)<br></p><hr><blockquote><p>如果只是简单的数值，例如只有一个String类型的值，可以通过@Value注解注入到属性内，如：</p></blockquote><pre><code>test:  stringTest: &quot;测试字符串&quot;;</code></pre><blockquote><p>则可在需要注入的地方加上注解：@Vaule(“${test.stringTest}”)来实现注入</p></blockquote><hr><h2 id="使用log4j打印日志"><a href="#使用log4j打印日志" class="headerlink" title="使用log4j打印日志"></a>使用log4j打印日志</h2><blockquote><p>有些日志是使用debug打印的，然而SpringBoot只会显示用info打印的数据。有的时候，比如说整合了Mybatis后想查看执行的sql就会看不见。因为打印的执行语句是使用debug打印的。这个时候就需要将debug的日志显示出来。但是因为debug的所有日志太多，会导致有些关键日志被自动清除。所有需要指定某个特定的类打印debug</p></blockquote><h3 id="显示所有debug"><a href="#显示所有debug" class="headerlink" title="显示所有debug"></a>显示所有debug</h3><pre><code>logging:  level:   root: debug</code></pre><h3 id="显示某个特定类的debug"><a href="#显示某个特定类的debug" class="headerlink" title="显示某个特定类的debug"></a>显示某个特定类的debug</h3><pre><code>logging:  level:   cn.jbit: debug</code></pre><blockquote><p>注意：这里的cn.jbit就是指定的类的全限定名称</p></blockquote><hr><h2 id="Spring注解"><a href="#Spring注解" class="headerlink" title="Spring注解"></a>Spring注解</h2><ul><li>@Configuration<ul><li>在类名上面使用。将一个类变成配置类，加载这个类中的配置可以取代之前的xml</li></ul></li><li>@Bean<ul><li>在返回一个对象的方法上使用。将一个类的对象加入IOC容器</li></ul></li><li>@Import<ul><li>在类名上使用，可以更简洁的将对象加入IOC容器，如：@Import(User.class)即可将User加入IOC容器。注意：默认使用无参构造器</li></ul></li><li>@ComponentScan<ul><li>相当于xml的context:component-scan。例：<pre><code>      @ComponentScan(          value=&quot;cn.jbit.component&quot;,//扫描的包          userDefaultFilers=fals,          includeFilers={              @Filter(type=FilterType.ANNOTATION,calsses=Controller.class)//只扫描带Controller注解的内容          },          excludeFilters={              @Filter(type=FilterType.ANNOTATION,classes=Service.class)//不扫描Service注解的内容          }      )</code></pre></li></ul></li></ul><h3 id="SpringBoot注解"><a href="#SpringBoot注解" class="headerlink" title="SpringBoot注解"></a>SpringBoot注解</h3><ul><li>@SpringBootConfiguration<ul><li>功能和Spring的注解功能一致</li></ul></li><li>@EnableAutoConfiguration<ul><li>启用自动化配置</li></ul></li><li>@AutoConfigurationPackage<ul><li>指定自动化配置的包</li></ul></li><li>@SpringBootApplication<ul><li>表示是一个SpringBoot应用。包含@SpringBootConfiguration，@EnableAutoConfiguration，@ComponentScan</li></ul></li></ul><hr><h2 id="整合Mybatis"><a href="#整合Mybatis" class="headerlink" title="整合Mybatis"></a>整合Mybatis</h2><h3 id="加载mybatis依赖"><a href="#加载mybatis依赖" class="headerlink" title="加载mybatis依赖"></a>加载mybatis依赖</h3><pre><code>&lt;dependency&gt;    &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;    &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;    &lt;version&gt;2.1.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;    &lt;artifactId&gt;druid&lt;/artifactId&gt;    &lt;version&gt;1.0.5&lt;/version&gt;&lt;/dependency&gt;</code></pre><h3 id="配置yml文件"><a href="#配置yml文件" class="headerlink" title="配置yml文件"></a>配置yml文件</h3><pre><code>spring:   datasource:    name: mydb   type: com.alibaba.druid.pool.DruidDataSource   url: jdbc:mysql://localhost:3306/smbms?serverTimezone=UTC   username: root   password: root   driver-class-name: com.mysql.cj.jdbc.Drivermybatis:  mapper-locations: classpath*:/mybatis/mapper/*dao.xml    //因为是maven项目，所以dao.xml文件存放在src/main/resources/mybatis/mapper目录下。所以这里的classpath指定的就是dao.xml文件存放的路径。后面的*dao.xml表示所有以dao.xml结尾的文件logging:   level: cn.jbit.dao: debug</code></pre><h3 id="主启动类"><a href="#主启动类" class="headerlink" title="主启动类"></a>主启动类</h3><p>在主启动类上加上注解：@MapperScan(“cn.jbit.dao”)。括号内写接口dao所在的路径，这里为cn.jbit.dao</p><h3 id="测试类"><a href="#测试类" class="headerlink" title="测试类"></a>测试类</h3><p>在测试类上面加上@SpringBootTest(classes = BootTestApplication.class)注解。classes里面写主启动类</p><h2 id="SpringBoot的自动配置"><a href="#SpringBoot的自动配置" class="headerlink" title="SpringBoot的自动配置"></a>SpringBoot的自动配置</h2><blockquote><p>使用@EnableAutoConfiguration注解来实现WEB(Tomcat,JSON.WebMVC等)的自动配置</p></blockquote><blockquote><p>如果不需要某些自动配置，则可以通过注解@EnableAutoConfiguration的’exclude’或’excludeName’属性来指定。或者在配置文件(yml或properties)中指定Spring.autoconfigure.exclude的值来禁用</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 入门 </tag>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis</title>
      <link href="/2020/06/13/redis/"/>
      <url>/2020/06/13/redis/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是redis"><a href="#什么是redis" class="headerlink" title="什么是redis"></a>什么是redis</h1><blockquote><p>redis是一个key-value的临时存储系统，和Memcached类似，它支持存储的value类型相对更多，包括string(字符串)、list(链表)、set(集合)、zset(sorted set –有序集合)和hash（哈希类型）</p></blockquote><h2 id="文件介绍"><a href="#文件介绍" class="headerlink" title="文件介绍"></a>文件介绍</h2><ul><li>redis-server.exe<ul><li>服务器启动命令</li></ul></li><li>redis-cli.exe<ul><li>命令行客户端</li></ul></li><li>redis.windows.conf<ul><li>Redis核心配置文件</li></ul></li><li>redis-benchmark.exe<ul><li>性能测试工具</li></ul></li><li>redis-check-aof.exe<ul><li>AOF文件修复工具</li></ul></li><li>redis-check-dump.exe<ul><li>RDB文件检查工具</li></ul></li></ul><h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><p>双击redis-server.exe启动redis服务端</p><blockquote><p>在启动界面port表示端口号，等同于(127.0.0.1)或者(localhost)。pid表示每次启动redis都等于启动了一个对象，pid即为实例的id。所以pid每次启动都会改变</p></blockquote><blockquote><p>注意：如果想启动多个redis则端口号不能相同。需要去配置文件改变启动的端口号才能启动多个</p></blockquote><p>双击redis-cli.exe启动redis客户端</p><h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><blockquote><p>清屏：clear</p></blockquote><blockquote><p>退出：exit,quit,按ESC</p></blockquote><hr><h3 id="获取帮助"><a href="#获取帮助" class="headerlink" title="获取帮助"></a>获取帮助</h3><pre><code>help set        //查看指令orhelp @string    //查看群组</code></pre><blockquote><p>注意：群组是一组命令的集合，如set和get都属于string群组；同时可以输入helo 后按tab来查看可用的指令(可用于自动补全命令)</p></blockquote><hr><h3 id="信息添加"><a href="#信息添加" class="headerlink" title="信息添加"></a>信息添加</h3><pre><code>set key value</code></pre><blockquote><p>注意：如果添加的key同名，后添加的数据会覆盖之前的数据</p></blockquote><hr><h3 id="信息查询"><a href="#信息查询" class="headerlink" title="信息查询"></a>信息查询</h3><pre><code>get key</code></pre><blockquote><p>注意：如果查询的key不存在，会返回nil</p></blockquote><hr><h2 id="常见数据类型"><a href="#常见数据类型" class="headerlink" title="常见数据类型"></a>常见数据类型</h2><blockquote><p>常见类型：string，hash，list，set，sorted_set</p></blockquote><hr><h3 id="string类型的基本操作"><a href="#string类型的基本操作" class="headerlink" title="string类型的基本操作"></a>string类型的基本操作</h3><blockquote><p>添加/修改数据：set key value<br>获取数据：get key<br>删除数据：del key</p></blockquote><blockquote><p>注意：执行操作时1表示执行成功，0表示执行失败</p></blockquote><ul><li>修改/添加多个数据<ul><li>mset key1 value1 key2 value2</li></ul></li></ul><blockquote><p>注意：添加多条数据一般使用这个指令。但是如果一次发送的数据太多，则需要减少一次发送的数据量。</p></blockquote><ul><li>获取多个数据<ul><li>mget key1 key2</li></ul></li><li>获取字符串个数<ul><li>strlen key</li></ul></li><li>追加信息到原始信息后面(如果原始信息存在就追加，否则新建)<ul><li>append key value</li></ul></li></ul><hr><h4 id="扩展操作1"><a href="#扩展操作1" class="headerlink" title="扩展操作1"></a>扩展操作1</h4><blockquote><p>由于主键id的数字过大，会影响查询性能。所以需要吧一张表分割成多个表。但是这样做各个表之间的主键如果任由自增长的话会出现重新的情况。</p></blockquote><p>解决方案：使用Redis解决</p><blockquote><p>自增：incr key(每次使用自增1)<br>指定自增：incrby key increment(自己指定每次自增的数量)<br>指定自增(可为小数)：incrbyfloat key increment(自己指定每次自增的数量，可为浮点类型)</p></blockquote><blockquote><p>自减：decr key(每次使用自减1)<br>指定自减：decr key increment(自己指定每次自减的数量)</p></blockquote><blockquote><p>由于redis是单线程，所以一时间只能有一个表的主键执行自增。这样就解决了多表id的分布式自增可能会重复问题</p></blockquote><hr><h4 id="扩展操作2"><a href="#扩展操作2" class="headerlink" title="扩展操作2"></a>扩展操作2</h4><blockquote><p>投票时一定时间内只能投一票，或者某个新闻只有在一段时间内为热点，又或者验证码过期时间</p></blockquote><p>解决方案1：设置数据有指定的生命周期</p><blockquote><p>创建一个变量，并指定存在时间(秒)。指定时间超过后该变量就会自动销毁</p></blockquote><pre><code>setex key seconds value</code></pre><p>创建一个变量，并指定存在时间(毫秒)。指定时间超过后该变量就会自动销毁</p><pre><code>psetex key milliseconds value</code></pre><blockquote><p>注意：如果给一个变量指定生命周期后再用set创建了一个同名的变量，则后创建的会覆盖掉之前指定了定生命周期的变量。</p></blockquote><blockquote><p>解决方案2：使用redis控制数据的生命周期。通过数据是否失效控制业务行为。适用于具有时效性的限定控制操作。</p></blockquote><hr><h4 id="拓展操作3"><a href="#拓展操作3" class="headerlink" title="拓展操作3"></a>拓展操作3</h4><blockquote><blockquote><p>获取数据库数据时的key名称，存储结构<br>获取数据库数据时的名称<br>在将数据库的数据放在redis中时，key命名的规范一般为：表名:主键列:主键值:列名。中间用:分隔<br>存储结构</p></blockquote></blockquote><p>可使用json存储数据</p><pre><code>set user:id:1 {id:1,name:admin,age:18}。</code></pre><blockquote><p>注意：使用json存数据如果想修改其中一个数据，只能全部修改</p></blockquote><h3>注意事项</h3><ol><li>由于不同操作，返回的数字会不同。有的时候返回的0和1表示成功和失败。有的时候表示运行结果。</li><li>存储的数据有最大值(512MB)</li><li>报错的数据有最大范围(java中long的最大值)：9223372036854775807</li></ol><hr><h3 id="hash类型的基本操作"><a href="#hash类型的基本操作" class="headerlink" title="hash类型的基本操作"></a>hash类型的基本操作</h3><blockquote><p>增加/修改数据：hset key field value(一次只能增加一个field，key同名不会覆盖，只会增加多个field。)<br>获取数据：hget key field或者hgetall key<br>删除数据：hdel key field1 [field2]</p></blockquote><p>增加/修改多个数据</p><pre><code>hmset key field1 value1 field2 value2</code></pre><p>获取多个数据</p><pre><code>hmget key field1 field2</code></pre><p>获取哈希表中字段的数量</p><pre><code>hlen key</code></pre><p>获取哈希表中是否存在指定字段</p><pre><code>hexists key field</code></pre><hr><h4 id="扩展操作"><a href="#扩展操作" class="headerlink" title="扩展操作"></a>扩展操作</h4><blockquote><blockquote><p>获取哈希中的所有字段名或者值<br>获取所有字段名：hkeys key<br>获取所有值：hvals key</p></blockquote></blockquote><p>设置指定字段的值增加指定范围的值</p><pre><code>hincrby key field incrementhincrbyfloat key field increment</code></pre><blockquote><p>注意：如果想实现自减则需要传入负数</p></blockquote><h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><p>购物车的设计和实现</p><blockquote><p>一个数据多次加载，如何使用缓存实现一次加载N次显示</p></blockquote><pre><code>hsetnx key field value</code></pre><blockquote><p>如果需要加载的field已经存在，再次执行该命令就会执行失败</p></blockquote><blockquote><p>已知商品会出现高并发的情况，限量购买数量。如：商品秒杀，上限1000。由于redis是单线程，所以由redis进行减少不会出现超卖的情况。</p></blockquote><h3>注意事项</h3><ol><li>value只能存储string类型的数据，不存在嵌套现象(套娃)。如果为取到列，对应值为nil</li><li>可存储2的32次方-1</li><li>哈希创造初衷不是为了存大量数据而设计的。所以不能将哈希作为对象列表使用</li><li>如果内部field过多，整体遍历效率就会降低(hgetall)。有可能成为数据访问的瓶颈。所以建议需要什么获取什么。不要遍历出没用的数据</li></ol><hr><h3 id="list类型的基本操作"><a href="#list类型的基本操作" class="headerlink" title="list类型的基本操作"></a>list类型的基本操作</h3><blockquote><p>需求：存储多个数据，并对数据进入存储空间的顺序做区分</p></blockquote><blockquote><p>添加/修改数据：lpush key value1 value2或者rpush key value1 value2<br>获取数据：lrange key start stop或者lindex key index或者llen key<br>获取并移除数据；lpop key或者rpop key(左或右依次拿出并删除数据)</p></blockquote><blockquote><p>注意：使用lpush(左侧插入)插入数据的话，使用lrange读取数据就最后插入的最先显示。使用rpush(右侧插入)插入数据的话，使用lrange读取数据就是最先插入的最先显示。</p></blockquote><ul><li>由于插入list的数据进入顺序是固定的，且查询时头尾都可查询。所以查询时最好满是右进(rpush )左查(lrange )</li><li>最后插入的数据下标为0，倒数第二个插入的数据下标为1，依次类推</li><li>当不知道list长度时，可使用0 -1查询所有</li></ul><h4 id="扩展操作1-1"><a href="#扩展操作1-1" class="headerlink" title="扩展操作1"></a>扩展操作1</h4><pre><code>blpop key1 [key2] timeoutbrpop key1 [key2] timeout</code></pre><p>等待指定时间(秒)，然后在等待时间内从左或右依次拿出数据。如果时间到了还没拿到数据则返回nil。如果在等待的时间内拿到了数据，则返回拿到的数据</p><blockquote><p>注意：可设置多个key，表示从多个key列表获取数据</p></blockquote><h4 id="扩展操作2-1"><a href="#扩展操作2-1" class="headerlink" title="扩展操作2"></a>扩展操作2</h4><p>从list中间删除某个value</p><pre><code>lrem key count value：lrem 需要删除的list(list1) 删除的个数(1) 删除的value(a)：lrem list1 1 a</code></pre><blockquote><p>注意：如果value存在多个，并且删除的个数为多个。删除时会从左往右删</p></blockquote><h4 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h4><p>当数据库的日志为分布式时，连贯的日期格式会分布在多个数据库中，如果需要查看会很不方便。所以需要用redis集中一下数据<br>在不同的数据库添加数据到redis即可</p><h3>注意事项</h3><ol><li>保存的数据为string类型。最多2的32次方-1个</li><li>list具有索引概念。但操作时以队列的形式入队出队操作。或以栈的形式进行入栈出栈操作</li><li>由于list是有序的，所以可以进行分页等操作。通常第一页来着list，第二页或更多页来自数据库</li></ol><hr><h3 id="set类型的基本操作"><a href="#set类型的基本操作" class="headerlink" title="set类型的基本操作"></a>set类型的基本操作</h3><blockquote><p>需求：存储大量数据，在查询方面提供更高的效率。虽然list存储方便，但是读取效率过低。所以不推荐使用list</p></blockquote><blockquote><p>添加数据：sadd key member1 [member2]<br>获取全部数据：smembers key<br>删除数据：srem key member1 [member2]<br>获取集合数据的总量：scard key<br>判断集合中是否包含指定数据：sismember key member</p></blockquote><blockquote><p>随机获取集合中指定数量的数据：srandmember key [count]<br>随机获取集合中某个数据，并将该数据移除集合：spop key [count]</p></blockquote><hr><h4 id="扩展操作-1"><a href="#扩展操作-1" class="headerlink" title="扩展操作"></a>扩展操作</h4><p>多个集合的交，并，差集(交集：两个数据都有的部分；并集：两个数据的所有部分，重复的只显示一次；差集：a集合里减去b集合后剩下的部分)</p><pre><code>sinter key1 [key2]sunion key1 [key2]sdiff key1 [key2]</code></pre><p>将多个集合的交，并，差集存储到指定集合中</p><pre><code>sinterstore destination key [key2]sunionstore destination key [key2]sdiffstore destination key [key2]</code></pre><p>将指定数据从原始集合中移动到目标集合中</p><pre><code>smove source destination member</code></pre><blockquote><p>smove a1 a2 name：将a1中的name移动到a2中去</p></blockquote><h3>注意事项</h3><ol><li>set类型不允许数据重复，如果添加的数据在set中已存在，将只保留一份</li></ol><hr><h2 id="sorted-set类型的基本操作"><a href="#sorted-set类型的基本操作" class="headerlink" title="sorted_set类型的基本操作"></a>sorted_set类型的基本操作</h2><blockquote><p>需求：根据自身特性进行排序的方法</p></blockquote><blockquote><p>添加/修改数据：zadd key score1 member1 [score2 member2]</p></blockquote><blockquote><p>获取全部数据：zrangekey stat stop [withscores](从小到大排序)或者zrevrange key start stop [withsscores](从大到小排序)：按照数字顺序显示</p></blockquote><p>获取全部数据时加上withscores会显示名称和值</p><blockquote><p>删除数据：zrem key member [member…]</p></blockquote><p>按条件获取数据</p><pre><code>zrangebyscore key min max [withscores] [limit]zrevrangebyscore key max min [withscores]</code></pre><p>条件删除数据</p><pre><code>zremrangebyrank key stat stop：从第几个下标删到第几个下标。从小到大删除zremrangebyscore key min max</code></pre><p>获取集合总数</p><pre><code>zcard keyzcount key min max</code></pre><p>集合交，并集操作</p><pre><code>zinterstore destination numkeys key [key]zunionstore destination numkeys key [key]</code></pre><hr><h2 id="通用操作"><a href="#通用操作" class="headerlink" title="通用操作"></a>通用操作</h2><blockquote><p>删除指定key：del key<br>获取的key是否存在：exists key<br>获取key类型：type key</p></blockquote><blockquote><p>指定key的有效时间</p></blockquote><pre><code>expire key secods：秒pexprie key milliseconds：millexpireat key timestamp：秒，时间戳pexpireat key milliseconds-timestamp</code></pre><blockquote><p>获取key的有效时间</p></blockquote><pre><code>ttl keypttl key</code></pre><blockquote><p>切换key从时效性到永久：persist key</p></blockquote><blockquote><p>查询key</p></blockquote><pre><code>keys pattern ：可为*(任意字符)，?(匹配任意一个符号)，[](匹配一个指定符号)</code></pre><p>例如：keys a*(查询所有以a开头的)；keys a?(查询a开头，后面任意一个字符)；keys a[bc]d(查询a开头，d结尾。中间是b或者c的)</p><blockquote><p>数据库通用指令<br>为了解决key重复的问题，redis为每个服务提供了16个数据库，从0到15。每个数据库之间的数据相互独立(默认在0数据库)</p></blockquote><blockquote><p>切换数据库：slect index</p></blockquote><blockquote><p>其他操作</p></blockquote><pre><code>quit(退出)ping(测试服务器是否连通)echo message(通过echo输出一段内容)</code></pre><blockquote><p>数据移动<br>move key db(将key移动到对应的库中)<br><br>例：move name 1(将名为name的key移动到数据库1中)</p></blockquote><blockquote><p>数据清除</p></blockquote><pre><code>dbsize -(查看当前库有多少key)flushdb -(删掉当前库的数据)flushall -(删掉所有库的数据)</code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux</title>
      <link href="/2020/06/13/linux/"/>
      <url>/2020/06/13/linux/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux的好处"><a href="#Linux的好处" class="headerlink" title="Linux的好处"></a>Linux的好处</h1><blockquote><p>作为一款操作软件。免费，开源，高效，稳定和处理高并发非常强悍。很多企业级项目都会部署到Linux上，比如说javaEE，python等。</p></blockquote><hr><h2 id="VM和Linux-CentOS"><a href="#VM和Linux-CentOS" class="headerlink" title="VM和Linux(CentOS)"></a>VM和Linux(CentOS)</h2><blockquote><p>首先安装VM(虚拟机)，再安装CentOS(Linux)</p></blockquote><blockquote><p>安装完VM后创建虚拟机空间。然后安装CentOS</p></blockquote><hr><h2 id="虚拟机的网络连接三种形式"><a href="#虚拟机的网络连接三种形式" class="headerlink" title="虚拟机的网络连接三种形式"></a>虚拟机的网络连接三种形式</h2><h3 id="桥连接"><a href="#桥连接" class="headerlink" title="桥连接"></a>桥连接</h3><blockquote><p>等于在内网创建了一台电脑，其他人可访问你创建在VM上的CentOS。但是如果创建了多台桥连接的虚拟机，那么IP地址会不够用。会出现IP地址冲突</p></blockquote><blockquote><p>缺点：Linux可以和其他系统通信，但是会造成IP冲突</p></blockquote><h3 id="NAT-推荐"><a href="#NAT-推荐" class="headerlink" title="NAT(推荐)"></a>NAT(推荐)</h3><blockquote><p>会新建一个IP地址，如之前的IP地址是192.168.0.10，那么就会新创建一个192.168.100.20，同时，Linux系统的IP地址也会是新创建的地址：192.168.100.30。之前的IP地址依旧可以和其他电脑进行访问，但是新创建的IP地址只能和VM上的Linux进行联系</p></blockquote><blockquote><p>缺点：Linux能通过主机和其他系统通信，但是其他系统不能主动联系上Linux系统</p></blockquote><h3 id="仅主机模式"><a href="#仅主机模式" class="headerlink" title="仅主机模式"></a>仅主机模式</h3><hr><h2 id="windows和Linux的文件共享"><a href="#windows和Linux的文件共享" class="headerlink" title="windows和Linux的文件共享"></a>windows和Linux的文件共享</h2><blockquote><p>在Linux上安装vmtools，这样就可以实现在实体机和虚拟机直接的内容复制</p></blockquote><h3 id="创建共享文件夹"><a href="#创建共享文件夹" class="headerlink" title="创建共享文件夹"></a>创建共享文件夹</h3><ol><li>创建共享文件夹后Windows和Linux即可共同访问</li><li>新建文件夹后右键将文件夹属性设为共享。</li><li>虚拟机设置点击选项-共享文件夹-添加后选择之前共享的文件夹</li><li>在Linux文件夹下的mnt-hgfs文件夹就是共享文件夹</li></ol><hr><h2 id="Linux目录结构"><a href="#Linux目录结构" class="headerlink" title="Linux目录结构"></a>Linux目录结构</h2><blockquote><p>/bin</p></blockquote><p>存放经常使用的命令</p><hr><blockquote><p>/sbin</p></blockquote><p>系统管理员使用的系统管理程序</p><hr><blockquote><p>/home</p></blockquote><p>普通用户目录，一个用户一个目录。一般以用户的账号名称命名</p><hr><blockquote><p>/root</p></blockquote><p>超级权限者的用户主目录。</p><hr><blockquote><p>/lib</p></blockquote><p>系统开机所需要的最基本的动态链接共享库</p><hr><blockquote><p>/lost+found</p></blockquote><p>一般是空的，当计算机非法关闭后就会存放一些文件</p><hr><blockquote><p>/etc</p></blockquote><p>所有系统管理所需的配置文件和子目录</p><hr><blockquote><p>/usr</p></blockquote><p>用户的应用程序和文件都在这个目录下</p><hr><blockquote><p>/boot</p></blockquote><p>Linux启动到核心文件，包括链接文件和镜像文件</p><hr><blockquote><p>/proc</p></blockquote><p>虚拟的目录，是系统文件的映射。访问这个目录获取系统信息</p><hr><blockquote><p>/srv</p></blockquote><p>存放服务器启动所需提取的数据</p><hr><blockquote><p>/sys</p></blockquote><p>安装了2.6内核中新出现的一个文件系统</p><hr><blockquote><p>/tmp</p></blockquote><p>存放临时文件</p><hr><blockquote><p>/dev</p></blockquote><p>所有硬件用文件的形式展现</p><hr><blockquote><p>/media</p></blockquote><p>自动识别一些设备，如U盘，识别后会自动把识别的设备挂载到这个目录下</p><hr><blockquote><p>/mnt</p></blockquote><p>让用户临时挂载别的文件系统的，可以吧外部的存储挂载在/mnt上，然后进入该目录就可以查看了</p><hr><blockquote><p>/opt</p></blockquote><p>安装软件存放的目录。</p><hr><blockquote><p>/usr/local</p></blockquote><p>给另一个主机额外安装软件所安装的目录。一般是通过编译源码的方式安装程序</p><hr><blockquote><p>/var</p></blockquote><p>习惯将经常修改的文件放在这个目录下，如日志</p><hr><blockquote><p>/selinux</p></blockquote><p>安全子系统。</p><hr><h2 id="Linux常用指令-基础"><a href="#Linux常用指令-基础" class="headerlink" title="Linux常用指令(基础)"></a>Linux常用指令(基础)</h2><ul><li>reboot<ul><li>重启CentOS</li></ul></li><li>halt<ul><li>关机</li></ul></li><li>sync<ul><li>吧内存的数据同步到磁盘（不管是关机还是重启，首先要运行sync命令）</li></ul></li><li>shudown -h now<ul><li>立刻关机</li></ul></li><li>shodown -h 1<ul><li>1分钟后关机</li></ul></li><li>shodown -r now<ul><li>重启计算机 </li></ul></li><li>rm 文件名<ul><li>删除文件</li></ul></li><li>su -root<ul><li>切换管理员</li></ul></li><li>logout<ul><li>注销用户 </li></ul></li><li>cd<ul><li>切换目录(cd ~表示回到家目录；cd ..表示返回上级目录 )</li></ul></li><li>ll<ul><li>查看当前目录的所有文件</li></ul></li><li>pwd<ul><li>查看当前目录</li></ul></li><li>cat -n 文件名<ul><li>查看文件(只能查看文件，不能修改)。一般在后面加上| more：cat -n /home/user | more。进行分页后按空格翻页</li></ul></li></ul><hr><h2 id="远程登录Linux"><a href="#远程登录Linux" class="headerlink" title="远程登录Linux"></a>远程登录Linux</h2><h3 id="为什么要远程登录"><a href="#为什么要远程登录" class="headerlink" title="为什么要远程登录"></a>为什么要远程登录</h3><blockquote><p>在实际运用中，Linux很大概率是安装在机房上的。通过机房操纵Linux不现实，所有需要使用远程登录Linux</p></blockquote><h3 id="如何实现远程登录"><a href="#如何实现远程登录" class="headerlink" title="如何实现远程登录"></a>如何实现远程登录</h3><blockquote><p>一般需要安装两款软件：一款是远程登录软件(xshell)， 一款是上传，下载文件(XFtp5)。</p></blockquote><p>使用远程登录之前，需要在Linux上开启sshd服务</p><blockquote><p><font color="red">注意：如果是NAT的连接方式，需要在控制面板进入网络和 Internet——网络和共享中心。点击左侧的更改适配器设置。右键VMware Network Adapter VMnet8，选择属性。在网络目录下选中TPC/IPv4，属性。将默认网关设置成Linux的IP地址，上面的IP地址改为Linux的IP前三位相同的IP，后面的一位随意，除开0,255端口</font></p></blockquote><h3 id="上传下载文件"><a href="#上传下载文件" class="headerlink" title="上传下载文件"></a>上传下载文件</h3><blockquote><p>安装Xftp后即可上传下载文件</p></blockquote><hr><h2 id="Vi和Vim编辑器"><a href="#Vi和Vim编辑器" class="headerlink" title="Vi和Vim编辑器"></a>Vi和Vim编辑器</h2><blockquote><p>所有Linux系统都会内置Vi文本编辑器。而Vim是Vi的增强版，可以主动已字体的颜色辨别语法的正确性</p></blockquote><blockquote><p>Vim的三种模式：正常模式，插入模式，命令行模式。</p></blockquote><h3 id="正常模式"><a href="#正常模式" class="headerlink" title="正常模式"></a>正常模式</h3><blockquote><p>默认模式，在这个模式中，你可使用上下左右按键操作光标</p></blockquote><h3 id="插入模式"><a href="#插入模式" class="headerlink" title="插入模式"></a>插入模式</h3><blockquote><p>按i,l,o,O,a,A,r,R即可进入编辑模式，一般是按i进入</p></blockquote><h3 id="命令行模式"><a href="#命令行模式" class="headerlink" title="命令行模式"></a>命令行模式</h3><blockquote><p>可提供你相关指令，完成读取，存盘，替换，离开vim，显示行号等动作都是在此模式达成</p></blockquote><blockquote><p>新建文件：vim 文件名进入命令行模式后输入i进入插入模式即可编辑文件。文件编辑完后输入ESC即可退出编辑模式。然后输入:wq即可报错并退出。</p></blockquote><blockquote><p>注意：如果vim 文件名的文件已存在，则会打开文件。否则会创建新文件</p></blockquote><hr><h2 id="vim常用命令"><a href="#vim常用命令" class="headerlink" title="vim常用命令"></a>vim常用命令</h2><ul><li>vim 文件名<ul><li>如果文件名已存在则进入文件，否则创建新文件</li></ul></li><li>:wq<ul><li>保存并退出</li></ul></li><li>:q！<ul><li>文件不报错，直接退出</li></ul></li><li>:q<ul><li>一般用于查看文件后退出</li></ul></li><li>yy<ul><li>拷贝当前行，yy前加5表示当前向下5行。yy复制后p粘贴</li></ul></li><li>dd<ul><li>删除当前行，dd前加5表示删除当前向下5行。</li></ul></li><li>/关键字<ul><li>在文件中查找某个单词，输入n表示下一个</li></ul></li><li>set nu/set nonu<ul><li>设置文件的行号，取消文件的行号。</li></ul></li><li>[G]<ul><li>文件最末行</li></ul></li><li>[gg]<ul><li>文件首行</li></ul></li><li>u<ul><li>撤销动作</li></ul></li></ul><hr><h2 id="操作用户"><a href="#操作用户" class="headerlink" title="操作用户"></a>操作用户</h2><h3 id="创建用户"><a href="#创建用户" class="headerlink" title="创建用户"></a>创建用户</h3><pre><code>useradd 用户名oradduser 用户名</code></pre><blockquote><p><font color="red">注意：如果创建用户的时候没有指定组，则会在创建用户时创建一个和用户同名的组，然后将用户添加到组内<br>如果使用useradd/adduser -d /home/目录 用户名创建用户，则会将用户可操纵的路径改为设置的路径</font></p></blockquote><hr><h3 id="用户设置-修改密码"><a href="#用户设置-修改密码" class="headerlink" title="用户设置/修改密码"></a>用户设置/修改密码</h3><pre><code>passwd 用户名</code></pre><hr><blockquote><p>用户登录后默认在home/用户名目录下。用户只能在自己的目录下操作</p></blockquote><hr><h3 id="删除用户"><a href="#删除用户" class="headerlink" title="删除用户"></a>删除用户</h3><pre><code>userdel 用户名</code></pre><blockquote><p><font color="red">注意：userdel删除用户会保留home目录下对应的用户文件夹。如果使用userdel -r 用户名删除用户则会将用户对应的文件夹一同删掉</font></p></blockquote><hr><h3 id="查询用户信息"><a href="#查询用户信息" class="headerlink" title="查询用户信息"></a>查询用户信息</h3><pre><code>id 用户名</code></pre><hr><h3 id="切换用户"><a href="#切换用户" class="headerlink" title="切换用户"></a>切换用户</h3><pre><code>su - 用户名</code></pre><hr><h3 id="组的操作"><a href="#组的操作" class="headerlink" title="组的操作"></a>组的操作</h3><blockquote><p>创建组：groupadd 组名<br>删除组：groupdel 组名<br>创建用户时指定组：useradd -g 用户组 用户<br>修改用户组： usermod -g 用户组 用户名。</p></blockquote><hr><h3 id="用户文件说明"><a href="#用户文件说明" class="headerlink" title="用户文件说明"></a>用户文件说明</h3><blockquote><p>/etc/passwd</p></blockquote><p>用户的配置文件，记录用户的信息</p><blockquote><p>每行含义：用户名：口令：用户标识号：组标识号：注释性描述：主目录：登录 sell</p></blockquote><hr><blockquote><p>/etc/group</p></blockquote><p>组的配置文件，记录Linux包含的组信息</p><blockquote><p>每行的含义：组名：口令：组标识符：组内用户列表</p></blockquote><hr><blockquote><p>使用init [0123456]更改运行级别。同时可以进入/etc/inittab修改最下面的id:5:initdefault更改启动时的运行级别。默认是级别5(图形界面)</p></blockquote><ul><li>0：关机</li><li>3：单用户模式</li><li>5：图形界面</li><li>6：重启</li></ul><hr><h2 id="常用指令"><a href="#常用指令" class="headerlink" title="常用指令"></a>常用指令</h2><h3 id="创建文件夹"><a href="#创建文件夹" class="headerlink" title="创建文件夹"></a>创建文件夹</h3><pre><code>mkdir 名称</code></pre><blockquote><p>如果一次创建多级目录则需要加上-p：<br>例：mkdir -p /home/admini/user;admin和user都是新增的文件夹</p></blockquote><hr><h3 id="删除文件夹"><a href="#删除文件夹" class="headerlink" title="删除文件夹"></a>删除文件夹</h3><pre><code>rmdir 名称</code></pre><blockquote><p>只能删除空文件夹，如果有文件则需要使用rm -rf 目录；才能删除。任何目录都是从/开始</p></blockquote><hr><h3 id="创建文件"><a href="#创建文件" class="headerlink" title="创建文件"></a>创建文件</h3><pre><code>touch 文件</code></pre><blockquote><p>创建新文件(touch 文件名；创建多个文件用空格分隔</p></blockquote><hr><h3 id="复制文件"><a href="#复制文件" class="headerlink" title="复制文件"></a>复制文件</h3><pre><code>cp 文件名/文件夹 粘贴的地址</code></pre><ul><li>粘贴路径可为相对路径或绝对路径</li><li>如果复制的为整个文件夹，则需要在cp后面加上-r。如：cp -r 文件 路径</li><li>如果有多个相同的文件则会依次提示是否覆盖。可在cp前面加上\表示全覆盖。如：\cp</li></ul><hr><h3 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h3><pre><code>rm 文件名</code></pre><blockquote><p>如果需要删除文件夹，则需在rm后加上-r：rm -r 文件夹。如果不想提示，可以加上-f，表示强制删除不提示：rm -f 文件</p></blockquote><blockquote><p><font color="red">注意：-r和-f可以同时使用：rm -rf 文件</font></p></blockquote><hr><h3 id="mv指令"><a href="#mv指令" class="headerlink" title="mv指令"></a>mv指令</h3><blockquote><p>mv：剪切文件或重命名</p></blockquote><pre><code>mv name names（重命名）mv /home/user /home/（剪切）</code></pre><hr><h3 id="more指令"><a href="#more指令" class="headerlink" title="more指令"></a>more指令</h3><blockquote><p>more指令是一个基于VI编辑器的文本过滤器。已全屏的方式分页显示数据</p></blockquote><table><thead><tr><th align="center">操作</th><th align="center">功能说明</th></tr></thead><tbody><tr><td align="center">空格</td><td align="center">下一页</td></tr><tr><td align="center">回车</td><td align="center">下一行</td></tr><tr><td align="center">q</td><td align="center">立刻立刻more，不在浏览文件</td></tr><tr><td align="center">Ctrl+f</td><td align="center">向下滚动一屏</td></tr><tr><td align="center">Ctrl+b</td><td align="center">返回上一屏</td></tr><tr><td align="center">=</td><td align="center">输出当前行号</td></tr><tr><td align="center">:f</td><td align="center">输出文件名和当前行号</td></tr></tbody></table><hr><h3 id="less指令"><a href="#less指令" class="headerlink" title="less指令"></a>less指令</h3><blockquote><p>用来分屏查看文件，功能和more类似，但是比more更强大。less在显示文件时不是一次全部加载，而是一次加载需要显示的文件。对显示大型文件有更高的效率</p></blockquote><table><thead><tr><th align="center">操作</th><th align="center">功能说明</th></tr></thead><tbody><tr><td align="center">空格</td><td align="center">向下翻一页</td></tr><tr><td align="center">pagedown</td><td align="center">向下翻动一页</td></tr><tr><td align="center">pageup</td><td align="center">向上翻动一页</td></tr><tr><td align="center">/字符</td><td align="center">向下搜索[字符]的功能：n向下查找，N向上查找</td></tr><tr><td align="center">?字符</td><td align="center">向上搜索[字符]的功能：n向上查找；N向下查找</td></tr><tr><td align="center">q</td><td align="center">离开less这个程序</td></tr></tbody></table><hr><h2 id="Linux安装javaEE环境"><a href="#Linux安装javaEE环境" class="headerlink" title="Linux安装javaEE环境"></a>Linux安装javaEE环境</h2><blockquote><p>注意：下列软件需要使用Linux专用版本。下载的文件放在Linux系统的opt目录下，输入tar -zxvf 文件名即可解压.gz的文件</p></blockquote><hr><h3 id="jdk1-8"><a href="#jdk1-8" class="headerlink" title="jdk1.8"></a>jdk1.8</h3><blockquote><p>配置环境变量：vim /etc/profile</p></blockquote><blockquote><p>进入profile文件后在文件末尾加上：</p></blockquote><pre><code>JAVA_HOME=/opt/jdk1.8(jdk解压地址) PATH=/opt/jdk1.8(jdk解压地址)/bin:$PATHexport  JAVA_HOME PATH</code></pre><blockquote><p>注意：配置完后需要注销才能生效。或者使用source /etc/profile重新加载profile文件</p></blockquote><hr><h3 id="tomcat-7-0"><a href="#tomcat-7-0" class="headerlink" title="tomcat 7.0"></a>tomcat 7.0</h3><blockquote><p>解压完成后进入tomcat的bin目录。输入./startup.sh 启动tomat。此时只有ContOS才能访问8080端口，如果需要Windows访问8080需要开放防火墙</p></blockquote><p>开放8080端口，根据你自己的需要进行修改 </p><pre><code>/sbin/iptables -I INPUT -p tcp --dport 8080 -j ACCEPT</code></pre><p>保存</p><pre><code>/etc/rc.d/init.d/iptables save</code></pre><p>重启服务</p><pre><code>/etc/init.d/iptables restart</code></pre><p>查看端口是否开放</p><pre><code>/sbin/iptables -L -n</code></pre><hr><h3 id="mysql"><a href="#mysql" class="headerlink" title="mysql"></a>mysql</h3><blockquote><p>进入解压后的源码包：cd mysql-5.6.14</p></blockquote><blockquote><p>设置编译参数</p></blockquote><pre><code>cmake -DCMAKE_INSTALL_PREFIX=/usr/local/mysql -DMYSQL_DATADIR=/usr/local/mysql/data -DSYSCONFDIR=/etc -DWITH_MYISAM_STORAGE_ENGINE=1 -DWITH_INNOBASE_STORAGE_ENGINE=1 -DWITH_MEMORY_STORAGE_ENGINE=1 -DWITH_READLINE=1 -DMYSQL_UNIX_ADDR=/var/lib/mysql/mysql.sock -DMYSQL_TCP_PORT=3306 -DENABLED_LOCAL_INFILE=1 -DWITH_PARTITION_STORAGE_ENGINE=1 -DEXTRA_CHARSETS=all -DDEFAULT_CHARSET=utf8 -DDEFAULT_COLLATION=utf8_general_ci</code></pre><blockquote><p>执行编译并安装：make &amp;&amp; make install</p></blockquote><p>因为安装后mysql所在组的权限是root，所以需要更改权限</p><pre><code>chown -R mysql(设置所有组):mysql(设置所在组) /usr/local/mysql</code></pre><p>如果没有mysql组则创建一个组，然后设置权限</p><blockquote><p>添加mysql组：groupadd mysql</p></blockquote><blockquote><p>创建用户：useradd -g mysql mysql</p></blockquote><p>初始化配置(所有操作都在usr/local/mysql路径下)</p><pre><code>scripts/mysql_install_db --basedir=/usr/local/mysql --datadir=/usr/local/mysql/data --user=mysql</code></pre><blockquote><p>注意：当CentOS为6.x版本时，在/etc目录下会存在一个my.cnf文件需要将此文件更名为其他名字，如:/etc/my.cng.bak,否则该文件会干扰源码安装的MySQL的正确配置，造成无法启动</p></blockquote><pre><code>mv /etc/my.cnf /etc/my.cnf.bak</code></pre><blockquote><p>添加服务，拷贝服务脚本到init.d目录，并设置开机启动(要在/usr/local/mysql下执行)</p></blockquote><pre><code>cp support-files/mysql.server /etc/init.d/mysql</code></pre><blockquote><p>设置mysql自动启动，不管在哪个级别上：chkconfig mysql on</p></blockquote><blockquote><p>启动mysql服务：service mysql start </p></blockquote><p>进入环境设置文件，在PATH=后面加上mysql/bin的路径。确保能在任何文件夹运行mysql</p><blockquote><p>进入环境设置文件：vim /etc/profile</p></blockquote><blockquote><p>设置PATH：PATH=JDK/bin:/usr/local/mysql/bin:$PATH</p></blockquote><blockquote><p>使用mysql -u root -p进入mysql后记得修改root账户的密码：SET PASSWORD = PASSWORD(‘root’);设置当前登录账号密码为root</p></blockquote><h2 id="开放端口"><a href="#开放端口" class="headerlink" title="开放端口"></a>开放端口</h2><h3 id="查看打开的端口"><a href="#查看打开的端口" class="headerlink" title="查看打开的端口"></a>查看打开的端口</h3><pre><code>/etc/init.d/iptables status</code></pre><hr><h3 id="开启端口"><a href="#开启端口" class="headerlink" title="开启端口"></a>开启端口</h3><pre><code>iptables -A INPUT -p tcp --dport 8080 -j ACCEPT </code></pre><blockquote><p>注意：8080可替换成任何想要开启的端口</p></blockquote><hr><h3 id="保存并重启防火墙"><a href="#保存并重启防火墙" class="headerlink" title="保存并重启防火墙"></a>保存并重启防火墙</h3><pre><code>/etc/rc.d/init.d/iptables save/etc/init.d/iptables restart</code></pre>]]></content>
      
      
      <categories>
          
          <category> 软件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> JavaEE </tag>
            
            <tag> Tomcat </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git</title>
      <link href="/2020/06/13/git/"/>
      <url>/2020/06/13/git/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是Git"><a href="#什么是Git" class="headerlink" title="什么是Git"></a>什么是Git</h1><blockquote><p>Git全称是分布式版本控制系统，通常配合GitHub在编程中会用到，并且由于git支持分布式部署，可以有效、高速的处理从很小到非常大的项目版本管理。</p></blockquote><h2 id="Git工作区域"><a href="#Git工作区域" class="headerlink" title="Git工作区域"></a>Git工作区域</h2><blockquote><p>工作区：添加，编辑，修改文件等操作</p></blockquote><blockquote><p>暂存区：暂存已修改的文件，最后统一提交到Git上</p></blockquote><blockquote><p>Git仓库：最终确定文件报错到仓库，成为一个新的版本，并对他人可见</p></blockquote><h2 id="Git命令"><a href="#Git命令" class="headerlink" title="Git命令"></a>Git命令</h2><pre><code>git status</code></pre><blockquote><p>查看文件状态</p></blockquote><pre><code>git add 文件名</code></pre><blockquote><p>将文件从工作区提交到暂存区</p></blockquote><pre><code>git commit -m &quot;描述&quot;</code></pre><blockquote><p>将文件从暂存区提交到Git仓库</p></blockquote><blockquote><p>建议每次操作前使用 git status查看当前文件状态</p></blockquote><blockquote><p>注意：上传文件时文件需要和.git是同级目录</p></blockquote><h2 id="Git初始化"><a href="#Git初始化" class="headerlink" title="Git初始化"></a>Git初始化</h2><blockquote><p>设置用户名(提交到Git仓库后显示的名称)</p></blockquote><pre><code>git config --global user.name &#39;test&#39;</code></pre><blockquote><p>设置用户邮箱</p></blockquote><pre><code>git config --global user.email &#39;test@163.com&#39;</code></pre><blockquote><p>查看设置</p></blockquote><pre><code>git config --list</code></pre><h2 id="初始化Git仓库"><a href="#初始化Git仓库" class="headerlink" title="初始化Git仓库"></a>初始化Git仓库</h2><blockquote><p>在想要克隆Git仓库的文件夹打开Git Bash或者使用cd进入特定文件夹。<br>使用git clone 仓库地址;将指定仓库克隆到本地<br>依次使用：</p></blockquote><pre><code>git add .    将该文件夹下的所有文件添加进去git commit -m &#39;描述&#39;git push -u origin master</code></pre><blockquote><p>注意：中途可以插入git status查看文件状态。git commit -m的提示信息注意使用单引号。<br>上传的时候根据.git文件夹内的地址不同，上传的仓库也不同</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 软件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SSM整合</title>
      <link href="/2020/04/30/ssm-zheng-he/"/>
      <url>/2020/04/30/ssm-zheng-he/</url>
      
        <content type="html"><![CDATA[<h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><blockquote><p>本文章内容为SSM所需的配置文件</p></blockquote><blockquote><p>，说明了所需的jar包(可根据需求自行增加)。</p></blockquote><h1 id="SSM整合"><a href="#SSM整合" class="headerlink" title="SSM整合"></a><strong>SSM整合</strong></h1><h2 id="所需jar包："><a href="#所需jar包：" class="headerlink" title="所需jar包："></a>所需jar包：</h2><h1 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a><strong>配置文件</strong></h1><p>beans配置</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;     xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;     xsi:schemaLocation=&quot;        http://www.springframework.org/schema/beans         http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;&lt;/beans&gt;</code></pre><h2 id="resoueces目录下的applicationContext-mybatis-xml"><a href="#resoueces目录下的applicationContext-mybatis-xml" class="headerlink" title="/resoueces目录下的applicationContext-mybatis.xml"></a>/resoueces目录下的applicationContext-mybatis.xml</h2><pre><code>&lt;!-- 获取数据源 --&gt;&lt;bean id=&quot;dataSource&quot; class=&quot;org.apache.commons.dbcp2.BasicDataSource&quot; destroy-method=&quot;close&quot; scope=&quot;singleton&quot;&gt;    &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;/&gt;    &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/smbms?serverTimezone=UTC&quot;/&gt;    &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;    &lt;property name=&quot;password&quot; value=&quot;root&quot;/&gt;&lt;/bean&gt;</code></pre><hr><h1 id="配置aop"><a href="#配置aop" class="headerlink" title="配置aop"></a><strong>配置aop</strong></h1><pre><code>&lt;!-- 配置aop --&gt;&lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;    &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;&lt;/bean&gt;&lt;aop:aspectj-autoproxy/&gt;&lt;aop:config proxy-target-class=&quot;true&quot;&gt;    &lt;aop:pointcut expression=&quot;execution(* *cn.jbit.service..*(..))&quot; id=&quot;transService&quot;/&gt;    &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut-ref=&quot;transService&quot;/&gt;&lt;/aop:config&gt;&lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;transactionManager&quot;&gt;    &lt;tx:attributes&gt;        &lt;tx:method name=&quot;*&quot; propagation=&quot;REQUIRED&quot;/&gt;    &lt;/tx:attributes&gt;&lt;/tx:advice&gt;</code></pre><h2 id="配置mybatis的SqlSessionFactoryBean"><a href="#配置mybatis的SqlSessionFactoryBean" class="headerlink" title="配置mybatis的SqlSessionFactoryBean"></a><em>配置mybatis的SqlSessionFactoryBean</em></h2><pre><code>&lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;    &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;    &lt;property name=&quot;configLocation&quot; value=&quot;classpath:mybatis-config.xml&quot;/&gt;&lt;/bean&gt;</code></pre><blockquote><p>注意：如果不想配置mybatis.config.xml文件可以将configLocation更换成mapperLocations，如：</p></blockquote><pre><code>&lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;    &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;    &lt;property name=&quot;mapperLocations&quot; value=&quot;classpath:cn/jbit/dao/*.xml&quot;/&gt;    &lt;property name=&quot;typeAliasesPackage&quot; value=&quot;cn.jbit.entity&quot;/&gt;&lt;/bean&gt;</code></pre><ul><li>mapperLocations<ul><li>设置dao.xml文件的路径，这样就会自动扫描映射文件</li></ul></li><li>typeAliasesPackage<ul><li>设置实体类路径，在映射文件里写实体类时就不用写全路径了</li></ul></li></ul><h2 id="配置MapperScannerConfigurer，自动注册dao接口对应的xml并配置成bean"><a href="#配置MapperScannerConfigurer，自动注册dao接口对应的xml并配置成bean" class="headerlink" title="配置MapperScannerConfigurer，自动注册dao接口对应的xml并配置成bean"></a><em>配置MapperScannerConfigurer，自动注册dao接口对应的xml并配置成bean</em></h2><pre><code>&lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt;    &lt;property name=&quot;basePackage&quot; value=&quot;cn.jbit.dao&quot;&gt;&lt;/property&gt;&lt;/bean&gt;</code></pre><p>配置context标签自动扫描cn.jbit.service包下的控制器</p><pre><code>&lt;context:component-scan base-package=&quot;cn.jbit.service&quot;/&gt;</code></pre><h2 id="配置mybatis-config-xml"><a href="#配置mybatis-config-xml" class="headerlink" title="配置mybatis-config.xml"></a><em>配置mybatis-config.xml</em></h2><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration  PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;  &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt;  &lt;settings&gt;    &lt;!--开启Mybatis支持延迟加载--&gt;    &lt;setting name=&quot;lazyLoadingEnabled&quot; value=&quot;true&quot;/&gt;    &lt;!--开启Mybatis支持延迟加载--&gt;    &lt;setting name=&quot;aggressiveLazyLoading&quot; value=&quot;false&quot;/&gt;    &lt;!-- 配置log为log4j --&gt;    &lt;setting name=&quot;logImpl&quot; value=&quot;STDOUT_LOGGING&quot;/&gt;  &lt;/settings&gt;  &lt;typeAliases&gt;      &lt;package name=&quot;cn.jbit.entity&quot;&gt;&lt;/package&gt;  &lt;/typeAliases&gt;  &lt;mappers&gt;    &lt;package name=&quot;cn.jbit.dao&quot;/&gt;  &lt;/mappers&gt;&lt;/configuration&gt;</code></pre><h2 id="配置springmvc-servlet-xml"><a href="#配置springmvc-servlet-xml" class="headerlink" title="配置springmvc-servlet.xml"></a><em>配置springmvc-servlet.xml</em></h2><p>配置context标签自动扫描cn.jbit.controller包下的控制器</p><pre><code>&lt;context:component-scan base-package=&quot;cn.jbit.controller&quot;/&gt;</code></pre><h2 id="配置mvc-annotation-driven标签和消息转换器"><a href="#配置mvc-annotation-driven标签和消息转换器" class="headerlink" title="配置mvc:annotation-driven标签和消息转换器"></a><em>配置mvc:annotation-driven标签和消息转换器</em></h2><pre><code>&lt;mvc:annotation-driven conversion-service=&quot;myConversionService&quot;&gt;    &lt;mvc:message-converters register-defaults=&quot;true&quot;&gt;        &lt;bean class=&quot;org.springframework.http.converter.StringHttpMessageConverter&quot;&gt;            &lt;property name=&quot;supportedMediaTypes&quot; value=&quot;text/plain;charset=UTF-8&quot;/&gt;        &lt;/bean&gt;    &lt;/mvc:message-converters&gt;&lt;/mvc:annotation-driven&gt;&lt;!-- 加载自定义转换器 --&gt;&lt;bean id=&quot;myConversionService&quot; class=&quot;org.springframework.context.support.ConversionServiceFactoryBean&quot;&gt;    &lt;property name=&quot;converters&quot;&gt;        &lt;list&gt;            &lt;bean class=&quot;cn.jbit.tool.StringToDateConverter&quot;&gt;                &lt;constructor-arg type=&quot;java.lang.String&quot; value=&quot;yyyy-MM-dd&quot;/&gt;            &lt;/bean&gt;        &lt;/list&gt;    &lt;/property&gt;&lt;/bean&gt;</code></pre><h2 id="配置mvc-resources标签加载静态资源"><a href="#配置mvc-resources标签加载静态资源" class="headerlink" title="配置mvc:resources标签加载静态资源"></a><em>配置mvc:resources标签加载静态资源</em></h2><pre><code>&lt;mvc:resources location=&quot;/statics/&quot; mapping=&quot;/statics/**&quot;/&gt;</code></pre><h2 id="配置支持文件上传"><a href="#配置支持文件上传" class="headerlink" title="配置支持文件上传"></a><em>配置支持文件上传</em></h2><pre><code>&lt;bean id=&quot;multipartResolver&quot; class=&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;&gt;    &lt;property name=&quot;maxUploadSize&quot; value=&quot;5000000&quot;&gt;&lt;/property&gt;    &lt;property name=&quot;defaultEncoding&quot; value=&quot;UTF-8&quot;&gt;&lt;/property&gt;&lt;/bean&gt;</code></pre><h2 id="配置多视图解析器"><a href="#配置多视图解析器" class="headerlink" title="配置多视图解析器"></a><em>配置多视图解析器</em></h2><pre><code>&lt;bean id=&quot;viewResolver&quot; class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;    &lt;property name=&quot;prefix&quot; value=&quot;/jsp/&quot;/&gt;    &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt;&lt;/bean&gt;</code></pre><h2 id="配置拦截器"><a href="#配置拦截器" class="headerlink" title="配置拦截器"></a><em>配置拦截器</em></h2><pre><code>&lt;mvc:interceptors&gt;    &lt;mvc:interceptor&gt;        &lt;!-- *开头的路径都拦截 --&gt;        &lt;mvc:mapping path=&quot;/smbm/**&quot;/&gt;        &lt;!-- 拦截器路径 --&gt;        &lt;bean class=&quot;cn.SpringMVC.interceptor.FirstInterceptor&quot;&gt;&lt;/bean&gt;    &lt;/mvc:interceptor&gt;&lt;/mvc:interceptors&gt;</code></pre><h2 id="配置web-xml"><a href="#配置web-xml" class="headerlink" title="配置web.xml"></a><em>配置web.xml</em></h2><p>配置springmvc.xmlc扫描</p><pre><code>&lt;servlet&gt;       &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt;    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;    &lt;init-param&gt;        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;        &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt;    &lt;/init-param&gt;    &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt;    &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt;       &lt;url-pattern&gt;/&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;</code></pre><p>传参乱码解决</p><pre><code>&lt;filter&gt;    &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt;    &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;    &lt;init-param&gt;        &lt;param-name&gt;encoding&lt;/param-name&gt;        &lt;param-value&gt;utf-8&lt;/param-value&gt;    &lt;/init-param&gt;    &lt;init-param&gt;        &lt;param-name&gt;forceEncoding&lt;/param-name&gt;        &lt;param-value&gt;true&lt;/param-value&gt;    &lt;/init-param&gt;&lt;/filter&gt;&lt;filter-mapping&gt;    &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt;    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt;</code></pre><p>Spring监听器</p><pre><code>&lt;context-param&gt;    &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;    &lt;param-value&gt;classpath:applicationContext-*.xml&lt;/param-value&gt;&lt;/context-param&gt;&lt;listener&gt;    &lt;listener-class&gt;        org.springframework.web.context.ContextLoaderListener    &lt;/listener-class&gt;&lt;/listener&gt;</code></pre><hr><h1 id="ajax返回参数的方式更换"><a href="#ajax返回参数的方式更换" class="headerlink" title="ajax返回参数的方式更换"></a><strong>ajax返回参数的方式更换</strong></h1><blockquote><p>在ajax返回参数时，可以试着返回一个自定义的类。类里面有执行状态(int)，状态说明(String)，需要传递的对象(Object)这三个属性。在jsp页面就可以根据执行状态来觉得执行什么内容，</p></blockquote><blockquote><p>比如说传递了自定义的类，根据类的有参构造器，传入了执行状态：200，状态说明：执行成功，传递的对象：User。这时候在jsp页面就可以判断，如果data.执行状态=200，就执行登录操作</p></blockquote><p>首先创建一个枚举类</p><pre><code>enum ResultCode</code></pre><p>然后在枚举类里创建几个数据的状态，例如执行成功(SUCCESS(200,”成功”))，执行失败(FAIL(303,”失败”))，对象为空(EMPTY(250,”空值”))。这个数据状态是可以根据需求添加的</p><pre><code>SUCCESS(200,&quot;成功&quot;),FAIL(303,&quot;失败&quot;),EMPTY(250,&quot;空值&quot;),ERROR(101,&quot;错误&quot;);</code></pre><p>在枚举类里创建两个属性：执行状态和状态说明。并提供set和get方法</p><pre><code>private int code ;private String desc;</code></pre><p>最后提供有参和无参的构造器</p><hr><p>创建一个自定义状态类：ResponseMsg<br><br>并让该类实现Serializable。<br><br>在该类里面有三个私有属性：</p><pre><code>Integer statusString msgObject data</code></pre><p>并提供对应的set和get方法<br><br>根据需求提供对应的有参和无参构造器</p><hr><p>根据枚举类里的数据状态写对应的静态方法</p><pre><code>public static  ResponseMsg BySuccess(String msg,Object data) {    return new ResponseMsg(ResultCode.SUCCESS.getCode(),msg,data);}</code></pre><p>这个方法就是执行成功需要返回的自定义类方法。在返回时，传入说明和一个对象。同时，在调用这个方法时会自动获取对应的枚举：ResultCode.SUCCESS.getCode()</p><pre><code>public static ResponseMsg ByFail(String msg) {    return new ResponseMsg(ResultCode.FAIL.getCode(),msg);}</code></pre><p>这个方法就是执行失败返回的自定义方法，在返回时，只需要提供说明即可。这样返回的就是对应的枚举和一个说明</p><blockquote><p>注意：写不同的方法时，需要改变对应的枚举，比如执行成功就是传入的ResultCode.SUCCESS.getCode()，执行失败就是传入的ResultCode.FAIL.getCode()。</p></blockquote><p>在写不同的方法时需要不同的有参构造器，比如说执行成功就需要全参构造器</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mybatis </tag>
            
            <tag> 框架 </tag>
            
            <tag> Spring </tag>
            
            <tag> SpringMVC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringMVC(二)</title>
      <link href="/2020/04/24/springmvc-er/"/>
      <url>/2020/04/24/springmvc-er/</url>
      
        <content type="html"><![CDATA[<h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><blockquote><p>本篇作为SpringMVC（一）的补充</p></blockquote><h2 id="返回参数"><a href="#返回参数" class="headerlink" title="返回参数"></a><strong>返回参数</strong></h2><blockquote><p>使用ModelAndView返回的方法可在jsp页面直接使用EL表达式(${name})获取参数</p></blockquote><pre><code>public ModelAndView index(String name){    ModelAndView mView = new ModelAndView ();    mView .addObject(&quot;name&quot;,&quot;value&quot;);    mView.setViewName(&quot;index&quot;);    return mview;}</code></pre><ul><li>addObject<ul><li>添加键值对，也可以只传入value，这样name默认就是传入的value，如果value是一个变量名，那么name就是变量名</li></ul></li><li>setViewName：跳转地址<ul><li>根据xml配置的地址进行跳转<blockquote><p>使用Model作为传递的参数也可在jsp页面直接使用EL表达式(${name})获取参数</p></blockquote></li></ul></li></ul><pre><code>public String index(String name, Model model){    model.addAttribute(&quot;name&quot;,&quot;value&quot;);    return &quot;index&quot;;}</code></pre><ul><li>addAttribute<ul><li>添加键值对，也可以只传入value，这样name默认就是传入的value，如果value是一个变量名，那么name就是变量名</li></ul></li></ul><hr><h2 id="传参的设置"><a href="#传参的设置" class="headerlink" title="传参的设置"></a><strong>传参的设置</strong></h2><pre><code>@RequestParam(value=&quot;&quot;,required=true,defaultValue=?) String name</code></pre><ul><li><p>value</p><ul><li>传入的参数名称</li></ul></li><li><p>required</p><ul><li>该参数是否为必传，当为true时，该参数必须有，否则会报错。如果为false，表示该参数可不传</li></ul></li><li><p>defaultValue</p><ul><li>当没有传入属性时的默认值</li></ul><hr></li></ul><h2 id="单文件上传"><a href="#单文件上传" class="headerlink" title="单文件上传"></a><strong>单文件上传</strong></h2><p>在spring-mvc.xml配置bean</p><pre><code>&lt;bean id=&quot;multipartResolver&quot; class=&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;&gt;    &lt;property name=&quot;maxUploadSize&quot; value=&quot;5000000&quot;&gt;&lt;/property&gt;    &lt;property name=&quot;defaultEncoding&quot; value=&quot;UTF-8&quot;&gt;&lt;/property&gt;&lt;/bean&gt;</code></pre><p>jsp页面</p><pre><code>form表单的编码类型必须是multipart/form-data类型，提交类型必须是post&lt;form enctype=&quot;multipart/form-data&quot; method=&quot;post&quot; action=&quot;test/index&quot;&gt;    &lt;input type=&quot;file&quot; name=&quot;image&quot; value=&quot;&quot;/&gt;&lt;/form&gt;</code></pre><p>Controller页面</p><pre><code>public String addUser(User user,HttpServletRequest request ,HttpSession session ,@RequestParam(value=&quot;image&quot;,required=false) MultipartFile attach){    //判断是否有上传文件    if(!attach.isEmpty()){        //获取文件路径        String path = request.getSession().getServletContext().getRealPath(&quot;statics&quot;+File.separator+&quot;uploadfiles&quot;);        //获取原文件名        String name = attach.getOriginalFilename();        //获取原文件后缀        String prefix = FilenameUtlis.getExtension(name);        //判断文件大小        if(attach.getSize() &gt; 5000){            //文件大于500KB        }else if(prefix.equalsIgnoreCase(&quot;jpg&quot;)){//判断文件后缀            //创建新的文件名称            String fileName = System.currentTimeMillis()+RandomUtils.nextInt(1000000)+&quot;test.jpg&quot;;//新的名称为当前时间+随机数+&quot;test.jpg&quot;            //定义上传到服务器的路径。该路径是相对路径            String fileUrl = &quot;uploadfiles&quot;+File.separator+fileName;            //将地址和名称存储到一个file对象，该对象用来接收上传的文件流。该地址是绝对路径            File file = new File(path,fileName);            //如果地址不存在则创建一个地址            if(!file.exists()){                file.mkdirs();            }            //将文件上传至服务器            try{                attach.transferTo(file)            }cath{                //文件上传失败            }            //将文件位置添加到add的User对象中            user.setImage(fileUrl);        }else{            //文件格式不对        }    }}</code></pre><p>注意：生成随机数需要加载commons-lang的jar包</p><hr><h2 id="上传多个文件"><a href="#上传多个文件" class="headerlink" title="上传多个文件"></a><strong>上传多个文件</strong></h2><p>在jsp页面的多个file组件的name必须一致<br><br>Controller页面：</p><pre><code>public String addUser(User user,HttpServletRequest request ,HttpSession session ,@RequestParam(value=&quot;image&quot;,required=false) MultipartFile[] attachs){    for(int i=0;i&lt;attachs.length;i++){        MultipartFile attach = attachs[i];        //和上传单个文件相似        //给两个不同的user文件名称赋值        String FileName = path+File.separator+fileName;        if(i==0){            user.setTest1(FileName )        }else if(i==1){            user.setTest2(FileName )        }    }}</code></pre><p>注意：如果是上传多个文件，MultipartFile名称前必须加上@RequestParam注解，否则会报错</p><hr><h2 id="传递的乱码"><a href="#传递的乱码" class="headerlink" title="传递的乱码"></a><strong>传递的乱码</strong></h2><p>在解决传递的乱码时，text/plain可以换成application/json来解决json传递中文出现的乱码</p><pre><code>&lt;mvc:annotation-driven&gt;    &lt;mvc:message-converters register-defaults=&quot;true&quot;&gt;        &lt;bean class=&quot;org.springframework.http.converter.StringHttpMessageConverter&quot;&gt;            &lt;property name=&quot;supportedMediaTypes&quot; value=&quot;text/plain;charset=UTF-8&quot;/&gt;        &lt;/bean&gt;    &lt;/mvc:message-converters&gt;&lt;/mvc:annotation-driven&gt;</code></pre><hr><h2 id="日期格式的乱码"><a href="#日期格式的乱码" class="headerlink" title="日期格式的乱码"></a><strong>日期格式的乱码</strong></h2><p>在spring-mvc.xml里配置消息转换器<br><br>在上面的代码mvc:message-converters里面加入子标签</p><pre><code>&lt;bean class=&quot;com.alibaba.fastjson.support.spring.FastJsonHttpMessageConverter&quot;&gt;    &lt;property name=&quot;supportedMediaTypes&quot;&gt;        &lt;list&gt;            &lt;value&gt;text/html;charset=utf-8&lt;/value&gt;            &lt;value&gt;application/json&lt;/value&gt;        &lt;/list&gt;    &lt;/property&gt;    &lt;property name=&quot;features&quot; value=&quot;WriteDateUserFormat&quot;/&gt;&lt;/bean&gt;</code></pre><p>注意：若只配置&lt;property name=”features” value=”WriteDateUserFormat”/&gt;，则会输入yyyy-MM-dd HH:mm:ss格式的日期</p><hr><p>同时也可以只指定某个日期属性的格式<br><br>在属性上加上注解：@JSONField(format=”yyyy-MM-dd”)<br><br>因为这种方式具有强入侵性，紧耦合。并且修改麻烦，所有尽量使用配置bean的方式解决日期格式的问题。<br></p><p>注意：使用@ResponseBody后返回类型直接是需要返回的对象就行，这样对象返回就是json格式的字符串</p><hr><h2 id="多视图解析器"><a href="#多视图解析器" class="headerlink" title="多视图解析器"></a><strong>多视图解析器</strong></h2><p>可以通过同路径，设置MIME格式控制服务器返回的数据类型。从而获得不同的返回内容<br><br>在spring-mvc.xml里配置bean</p><pre><code>&lt;bean class=&quot;org.springframework.web.servlet.view.ContentNegotiatingViewResolver&quot;&gt;    &lt;property name=&quot;favorParameter&quot; value=&quot;true&quot;/&gt;    &lt;property name=&quot;defaultContentType&quot; value=&quot;text/html&quot;/&gt;    &lt;property name=&quot;mediaTypes&quot;&gt;        &lt;map&gt;            &lt;entry key=&quot;html&quot; value=&quot;text/json;charset=utf-8&quot;/&gt;            &lt;entry key=&quot;json&quot; value=&quot;application/json;charset=utf-8&quot;/&gt;            &lt;entry key=&quot;xml&quot; value=&quot;application/xml;charset=utf-8&quot;/&gt;        &lt;/map&gt;    &lt;/property&gt;    &lt;property name=&quot;viewResolvers&quot;&gt;        &lt;list&gt;            &lt;bean id=&quot;viewResolver&quot; class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;                &lt;property name=&quot;prefix&quot; value=&quot;/jsp/&quot;/&gt;                &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt;            &lt;/bean&gt;        &lt;/list&gt;    &lt;/property&gt;&lt;/bean&gt;</code></pre><ul><li>favorParameter<ul><li>默认为true，表示支持参数匹配，可以根据请求参数的值确定MIME类型，默认的请求参数为format</li></ul></li><li>mediaTypes<ul><li>contentType以什么格式展示，若url的后缀为.json，则会以application/json的格式进行数据展示。</li></ul></li></ul><p>连接url改变：</p><pre><code>smbms/tool/showUser.json</code></pre><hr><h2 id="编写自定义转换器"><a href="#编写自定义转换器" class="headerlink" title="编写自定义转换器"></a><strong>编写自定义转换器</strong></h2><blockquote><p>用于解决日期格式的转换问题</p></blockquote><p>创建工具类StringToDateConverter，然后继承org.springframework.core.convert.converter包下的Converter</p><pre><code>public class StringToDateConverter implements Converter&lt;String, Date&gt;{    private String datePattern;    public StringToDateConverter(String datePattern) {        this.datePattern = datePattern;    }    public Date convert(String s) {        Date date = null;        try {            date = new SimpleDateFormat(datePattern).parse(s);        } catch (ParseException e) {            e.printStackTrace();        }        return date;    }}</code></pre><p>在springmvc.xml加载转换器</p><pre><code>&lt;mvc:annotation-driven conversion-service=&quot;myConversionService&quot;&gt;    &lt;mvc:message-converters register-defaults=&quot;true&quot;&gt;        &lt;bean class=&quot;org.springframework.http.converter.StringHttpMessageConverter&quot;&gt;            &lt;property name=&quot;supportedMediaTypes&quot; value=&quot;text/plain;charset=UTF-8&quot;/&gt;        &lt;/bean&gt;    &lt;/mvc:message-converters&gt;&lt;/mvc:annotation-driven&gt;&lt;!-- 加载自定义转换器 --&gt;&lt;bean id=&quot;myConversionService&quot; class=&quot;org.springframework.context.support.ConversionServiceFactoryBean&quot;&gt;    &lt;property name=&quot;converters&quot;&gt;        &lt;list&gt;            &lt;bean class=&quot;cn.jbit.tool.StringToDateConverter&quot;&gt;                &lt;constructor-arg type=&quot;java.lang.String&quot; value=&quot;yyyy-MM-dd&quot;/&gt;            &lt;/bean&gt;        &lt;/list&gt;    &lt;/property&gt;&lt;/bean&gt;</code></pre><h2 id="REST风格"><a href="#REST风格" class="headerlink" title="REST风格"></a><strong>REST风格</strong></h2><p>使用该风格可以简化访问路径</p><pre><code>@RequestMapping(&quot;/test/{id}&quot;)public String test1(@PathVariable String id){}</code></pre><p>访问时输入/test/name即可访问对应的方法</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ajax </tag>
            
            <tag> 入门 </tag>
            
            <tag> 框架 </tag>
            
            <tag> SpringMVC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring配置补充</title>
      <link href="/2020/04/24/spring-pei-zhi-bu-chong/"/>
      <url>/2020/04/24/spring-pei-zhi-bu-chong/</url>
      
        <content type="html"><![CDATA[<h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><blockquote><p>JDBC是由数据库中间服务商提供的，用于连接数据库的Java API。一组类和接口（对接数据库），JNDI是为应用服务器（Tomcat）管理资源所设置的目录样式的唯一标识。（数据库、网页、文档等）</p></blockquote><h2 id="配置DataSource"><a href="#配置DataSource" class="headerlink" title="配置DataSource"></a><strong>配置DataSource</strong></h2><p>将配置文件写在properties文件中，通过读取的方式配置DataSource</p><pre><code>&lt;bean class=&quot;org.springframework.beans.factory.config.PropertyPlaceholderConfigurer&quot;&gt;    &lt;property name=&quot;location&quot;&gt;    &lt;value&gt;classpath:database.properties&lt;/value&gt;    &lt;/property&gt;&lt;/bean&gt;</code></pre><ul><li>value<ul><li>配置文件路径</li></ul></li></ul><p>使用后在applicationContext.xml配置文件里可以使用${key}来获取配置的值，例如：</p><pre><code>&lt;bean id=&quot;dataSource&quot; class=&quot;org.apache.commons.dbcp2.BasicDataSource&quot; destroy-method=&quot;close&quot;&gt;    &lt;property name=&quot;driverClassName&quot; value=&quot;${Driver}&quot;/&gt;    &lt;property name=&quot;url&quot; value=&quot;${url}&quot;&gt;&lt;/property&gt;    &lt;property name=&quot;username&quot; value=&quot;${username}&quot;/&gt;    &lt;property name=&quot;password&quot; value=&quot;${password}&quot;/&gt;&lt;/bean&gt;</code></pre><hr><h2 id="使用JNDI连接数据库"><a href="#使用JNDI连接数据库" class="headerlink" title="使用JNDI连接数据库"></a><strong>使用JNDI连接数据库</strong></h2><blockquote><p>NDI和DBCP的区别：dbcp是针对当前项目的，只能当前项目使用。而jndi是存储在服务器中的。服务器中可以有多个项目，多个项目可以共用数据源</p></blockquote><p>首先在tomcat安装目录配置jndi数据源<br><br>打开context.xml文件，在context标签内配置：</p><pre><code>&lt;Resource name=&quot;jndi/smbms&quot; auth=&quot;Container&quot;        type=&quot;javax.sql.DataSource&quot;        maxActice=&quot;100&quot; maxIdle=&quot;30&quot;        maxWait=&quot;3000&quot; username=&quot;root&quot; password=&quot;root&quot;        driverClassName=&quot;com.mysql.jdbc.Driver&quot;    url=&quot;jdbc:mysql://localhost:3306/forum?userUnicode=true&amp;amp;characterEncoding=utf-8&quot;/&gt;</code></pre><p>然后在xml文件内配置bean</p><pre><code>&lt;bean id=&quot;dataSource&quot; class=&quot;org.springframework.jndi.JndiObjectFactoryBean&quot;&gt;    &lt;property name=&quot;jndiName&quot;&gt;    &lt;value&gt;java:comp/env/jdbc/smbms&lt;/value&gt;    &lt;/property&gt;&lt;/bean&gt;</code></pre><ul><li>value<ul><li>comp/env是固定路径，jdbc/smbms是配置的数据源名称</li></ul></li></ul><hr><h2 id="Spring自动装配"><a href="#Spring自动装配" class="headerlink" title="Spring自动装配"></a><strong>Spring自动装配</strong></h2><blockquote><p>在xml文件配置bean时如果需要注入属性则需要手动设置property的name和value属性，可以改为&lt;bean id=”a” class=”test” autowire=”byName”/&gt;来自动注入对应的属性</p></blockquote><p>autowire属性：</p><ul><li>no<ul><li>默认值，不进行自动装配</li></ul></li><li>byName<ul><li>根据属性名称自动装配。自动查找对应的id，找到就注入，否则什么都不做</li></ul></li><li>byType<ul><li>根据属性的类型自动匹配，如果找到一个则注入，找到多个则报错，没找到就什么都不做</li></ul></li><li>constructor<ul><li>和byType类型，不过他针对构造方法，如果找到一个bean的构造方法的参数类型相匹配则注入，否则什么都不做</li></ul></li></ul><blockquote><p>注意：可以写在beans标签内开启自动装配</p></blockquote><hr><h2 id="拆分Spring配置文件"><a href="#拆分Spring配置文件" class="headerlink" title="拆分Spring配置文件"></a><strong>拆分Spring配置文件</strong></h2><blockquote><p>根据模块不同分为四部分：公共部分，dao，service，web</p></blockquote><p>例如：<br><br>applicationContext.xml负责公共部分，例如事务控制，dataSource，注入映射器等<br><br>applicationContext-dao.xml只负责配置dao层的bean<br><br>applicationContext-service.xml只负责配置service层的bean和注入（可以开启自动装配。一般是根据名称自动装配）<br></p><hr><h2 id="合并多个配置文件"><a href="#合并多个配置文件" class="headerlink" title="合并多个配置文件"></a><strong>合并多个配置文件</strong></h2><ol><li>在ClassPathXMLApplicationContext()里传入多个配置文件，如：ClassPathXMLApplicationContext(“applicationContext.xml”,”applicationContext-dao.xml”)。多个配置文件用’,’分隔</li><li>在公共部分加入&lt;import resource=””/&gt;来加载多个配置文件，如：&lt;import resource=”applicationContext-dao.xml”/&gt;</li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis和Spring整合</title>
      <link href="/2020/04/24/mybatis-he-spring-zheng-he/"/>
      <url>/2020/04/24/mybatis-he-spring-zheng-he/</url>
      
        <content type="html"><![CDATA[<h2 id="SqlMapConfig-xml配置"><a href="#SqlMapConfig-xml配置" class="headerlink" title="SqlMapConfig.xml配置"></a><strong>SqlMapConfig.xml配置</strong></h2><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration  PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;  &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt;   &lt;settings&gt;    &lt;!--开启Mybatis支持延迟加载--&gt;    &lt;setting name=&quot;lazyLoadingEnabled&quot; value=&quot;true&quot;/&gt;    &lt;!--开启Mybatis支持延迟加载--&gt;    &lt;setting name=&quot;aggressiveLazyLoading&quot; value=&quot;false&quot;/&gt;    &lt;!-- 配置log为log4j --&gt;    &lt;setting name=&quot;logImpl&quot; value=&quot;STDOUT_LOGGING&quot;/&gt;  &lt;/settings&gt;  &lt;typeAliases&gt;&lt;!-- 扫描实体类 --&gt;      &lt;package name=&quot;cn.jbit.entity&quot;&gt;&lt;/package&gt;  &lt;/typeAliases&gt;  &lt;mappers&gt;&lt;!-- 自动扫描xml文件 --&gt;    &lt;package name=&quot;cn.jbit.dao&quot;/&gt;  &lt;/mappers&gt;&lt;/configuration&gt;</code></pre><hr><h2 id="applicationContext-mybatis-xml配置"><a href="#applicationContext-mybatis-xml配置" class="headerlink" title="applicationContext-mybatis.xml配置"></a><strong>applicationContext-mybatis.xml配置</strong></h2><p>连接数据库相关的信息</p><pre><code>&lt;bean id=&quot;dataSource&quot; class=&quot;org.apache.commons.dbcp.BasicDataSource&quot; destroy-method=&quot;close&quot;&gt;  &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;  &lt;property name=&quot;url&quot;&gt;    &lt;value&gt;&lt;![CDATA[jdbc:mysql://localhost:3306/system?useUnicode=true&amp;characterEncoding=utf-8]]&gt;&lt;/value&gt;  &lt;/property&gt;  &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;  &lt;property name=&quot;password&quot; value=&quot;root&quot;/&gt;&lt;/bean&gt;</code></pre><h2 id="配置SqlSessionFactoryBean"><a href="#配置SqlSessionFactoryBean" class="headerlink" title="配置SqlSessionFactoryBean"></a><strong>配置SqlSessionFactoryBean</strong></h2><pre><code>&lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;  &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;  &lt;property name=&quot;configLocation&quot; value=&quot;classpath:mybatis-config.xml&quot;/&gt;  &lt;property name=&quot;mapperLocations&quot;&gt;  &lt;list&gt;    &lt;value&gt;classpath:cn/subms/dao/**/*.xml&lt;/value&gt;  &lt;/list&gt;  &lt;/property&gt;&lt;/bean&gt;</code></pre><hr><h2 id="配置实现类-impl"><a href="#配置实现类-impl" class="headerlink" title="配置实现类(impl)"></a><strong>配置实现类(impl)</strong></h2><p>设置bean的id</p><pre><code>@Component(&quot;userDaoImpl &quot;)public class UserDaoImpl implements UserDao{  //自动配置sqlSessionFactory。或者可以指定sqlSessionTemplate创建的bean  @Autowired  private SqlSessionTemplate sqlSession;  public list&lt;User&gt; getUserList(User user){    return sqlSession.selectList(&quot;cn.jbit.dao.UserDao.getUserList&quot;,user);  }}</code></pre><hr><p>写在applicationContext-mybatis.xml配置中</p><pre><code>&lt;bean id=&quot;sqlSessionTemplate&quot; class=&quot;org.mybatis.spring.SqlSessionTemplate&quot;&gt;  &lt;constructor-arg name=&quot;sqlSessionFactory&quot; ref=&quot;sqlSessionFactory&quot;/&gt;&lt;/bean&gt;</code></pre><hr><p>配置服务层(Service)</p><pre><code>@Component(&quot;userServiceImpl&quot;)public class UserServiceImpl{//自动配置@Autowiredprivate IUserDao userDao;  public void addUser(){    userDao.addUser();  }}</code></pre><hr><h2 id="注入映射器的实现"><a href="#注入映射器的实现" class="headerlink" title="注入映射器的实现"></a><strong>注入映射器的实现</strong></h2><h3 id="为什么要注入映射器的实现"><a href="#为什么要注入映射器的实现" class="headerlink" title="为什么要注入映射器的实现"></a><em>为什么要注入映射器的实现</em></h3><blockquote><p>原本每次使用方法都需要创建一次映射器(sqlSession.getMapper(UserDao.class).getgetUserList(user))，注入映射器后只需要创建一次即可。使用注入映射后无需创建daoimpl，直接用注解在service的dao对象上自动注入即可</p></blockquote><h2 id="声明式事务"><a href="#声明式事务" class="headerlink" title="声明式事务"></a><strong>声明式事务</strong></h2><p>注意：默认只有RuntimeException异常能触发事务回滚;<br><br>抛出异常：throw new RuntimeException(“抛出异常”);<br></p><blockquote><p>首先声明tx和aop的命名空间</p></blockquote><pre><code>xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;xsi:schemalocation=&quot;http://www.springframework.org/schema/tx    http://www.springframework.org/schema/tx/spring-tx-3.1.xsd&quot;</code></pre><p>定义事务管理器</p><pre><code>&lt;bean id=&quot;txManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!-- 定义事务增强 --&gt;&lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;txManager&quot;&gt;  &lt;tx:attributes&gt;    &lt;tx:method name=&quot;add*&quot; timeout=&quot;-1&quot;/&gt;  &lt;/tx:attributes&gt;&lt;/tx:advice&gt;</code></pre><ul><li><p>tx:method</p><ul><li>timeout：默认值为-1，事务超时时间。当为-1时表示事务不会超时。里面的数字表示超时的时间，用秒做单位</li></ul></li><li><p>propagation</p><ol><li>默认值为REQUIRED，表示所有匹配的方法都在一个事务中，如果不在事务中则新建一个事务。一般增删改使用默认值</li><li>supports。表示如果在事务中则按照事务的方式进行处理，如果不在事务中就按正常的方式进行处理。一般用于查询</li></ol><hr></li></ul><p>配置切面决定那些包下面的哪些方法参与事务增强</p><pre><code>&lt;aop:config&gt;  &lt;aop:pointcut expression=&quot;execution(* cn.jbit.service..*.*(..))&quot; id=&quot;myPoint&quot;/&gt;  &lt;!-- 织入事务增强 --&gt;  &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut-ref=&quot;myPoint&quot;/&gt;&lt;/aop:config&gt;</code></pre><ul><li>expression<ul><li>决定那些包下面的哪些方法参与事务增强</li></ul></li><li>advice-ref<ul><li>表示织入哪个增强id</li></ul></li><li>pointcut-ref<ul><li>决定哪些方法加入增强<br>当配置完事务管理器后，如果指定多条增删改语句，要么都执行，要么都不执行。这就是事务控制</li></ul></li></ul><hr><h2 id="使用注解完成事务管理"><a href="#使用注解完成事务管理" class="headerlink" title="使用注解完成事务管理"></a><strong>使用注解完成事务管理</strong></h2><pre><code>&lt;bean id=&quot;txManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;  &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt;&lt;/bean&gt;&lt;tx:annotation-driven transaction-manager=&quot;txManager&quot;/&gt;</code></pre><p>在需要事务增强的类名上加上注解：@Transactional表示该类下的所有方法都织入事务增强<br>在类中的方法上加上：@Transactional(propagation=Propagation.SUPPORTS)表示只有该方法织入事务增强</p><blockquote><p>注意：注解和配置切面不可以同时使用，否则会报错</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mybatis </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring(二)</title>
      <link href="/2020/04/18/spring-er/"/>
      <url>/2020/04/18/spring-er/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是AOP"><a href="#什么是AOP" class="headerlink" title="什么是AOP"></a><strong>什么是AOP</strong></h2><blockquote><p>AOP是面向切面(Aspect Orinted Programming)编程。是软件编程思想发展到一定程度的产物。是面向对象编程的补充。一般适用于具有横切逻辑的场合，如访问控制，事务管理，性能监控</p></blockquote><h2 id="AOP的特点"><a href="#AOP的特点" class="headerlink" title="AOP的特点"></a><strong>AOP的特点</strong></h2><blockquote><p>能够在不改变原代码的基础上织入新的功能</p></blockquote><h2 id="AOP的使用"><a href="#AOP的使用" class="headerlink" title="AOP的使用"></a><strong>AOP的使用</strong></h2><h3 id="xml配置"><a href="#xml配置" class="headerlink" title="xml配置"></a><em>xml配置</em></h3><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;    xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans         https://www.springframework.org/schema/beans/spring-beans.xsd         http://www.springframweork.org/schema/aop         http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;  &lt;aop:aspectj-autoproxy proxy-target-class=&quot;true&quot;/&gt;&lt;/beans&gt;</code></pre><blockquote><p>和AOP相关的配置都放在&lt;aop:cnofig&gt;标签中</p></blockquote><pre><code>&lt;aop:cnofig&gt;  &lt;aop:pointcut id=&quot;&quot; expression=&quot;execution(public void setUser(cn.jbit.entity.User))&quot;/&gt;&lt;/aop:cnofig&gt;</code></pre><blockquote><p>配置切入点的标签&lt;aop:pointcut&gt;的expression属性可以配置切入点表达式，用来织入与表达式匹配的方法</p></blockquote><pre><code>expression=&quot;expression(public void setUser(User user))&quot;</code></pre><p>expression：切入点标识符，括号中是一个切入点表达式。常用的模糊查询表达式如下：<br>public * setUser(User user)：匹配所有类型的返回值<br><br>public void *(User user)：匹配所有的方法名<br><br>public void setUser(..)：匹配所有的参数个数和类型<br><br> * com.service.*.*(..)：匹配com.service包下的所有类和方法<br><br> * com.service..*.*(..)：匹配com.service包和子包下的所有类和方法<br></p><hr><blockquote><p>将先执行的方法a和后执行的方法b织入</p></blockquote><pre><code>&lt;bean id=&quot;testa&quot; class=&quot;方法a和方法b所在的类路径&quot;/&gt;&lt;aop:config&gt;  &lt;aop:pointcut id=&quot;pointcutTest/切入点id&quot; expression=&quot;execution(public void setUser(cn.jbit.entity.User))&quot;/&gt;  &lt;aop:aspect ref=&quot;testa&quot;&gt;    &lt;!--将方法a作为前置增强并引用需要增强的方法切入点id--&gt;    &lt;aop:before method=&quot;a&quot; pointcut-ref=&quot;pointcutTest&quot;/&gt;    &lt;!--将方法b作为后置增强并引用需要增强的方法切入点id--&gt;    &lt;aop:after-returning method=&quot;b&quot; pointcut-ref=&quot;pointcutTest&quot; returning=&quot;result&quot;/&gt;  &lt;/aop:aspect&gt;&lt;/aop:config&gt;</code></pre><hr><h2 id="AOP常用的增强方式"><a href="#AOP常用的增强方式" class="headerlink" title="AOP常用的增强方式"></a><strong>AOP常用的增强方式</strong></h2><h3 id="异常抛出增强"><a href="#异常抛出增强" class="headerlink" title="异常抛出增强"></a><em>异常抛出增强</em></h3><blockquote><p>特点是在目标抛出异常时，织入增强处理。可为其他异常模块提供统一，可插拔的异常处理方案<br>包含增强方法的JavaBean</p></blockquote><pre><code>pubic class test1{  public void afterThrowing(JoinPoint jp,RuntimeException e){    system.out.print(jp.getSignature().getName()+&quot;方法异常：&quot;+e);  }}</code></pre><p>xml配置如下</p><pre><code>&lt;!--声明增强方法所在的bean--&gt;&lt;bean id=&quot;theLogger&quot; class=&quot;test1路径&quot;/&gt;&lt;!--配置切面--&gt;&lt;aop:config&gt;  &lt;!--定义切入点(需要增强的方法所在)--&gt;  &lt;aop:pointcut id=&quot;&quot; expression=&quot;execution(* server.UserServer.*(..))&quot;/&gt;  &lt;!--引用增强方法--&gt;  &lt;aop:aspect ref=&quot;增强方法的bean&quot;&gt;    &lt;aop:after-throwing method=&quot;增强方法名&quot; pointcut-ref=&quot;切入点id&quot; throwing=&quot;e&quot;/&gt;  &lt;/aop:aspect&gt;&lt;/aop:config&gt;</code></pre><blockquote><p>注意：op:after-throwing标签即为异常增强</p></blockquote><hr><h3 id="最终增强"><a href="#最终增强" class="headerlink" title="最终增强"></a><em>最终增强</em></h3><blockquote><p>最终增强的特点是无论方法是抛出异常还是正常退出，该增强都会执行。类似finally语句块，一般用于释放资源</p></blockquote><p>语法和异常抛出增强基本一致，只需要更改&lt;aop:aspect&gt;标签内的子标签即可</p><pre><code>&lt;aop:after method=&quot;增强方法名&quot; pointcut-ref=&quot;切入点id&quot;/&gt;</code></pre><hr><h3 id="环绕增强"><a href="#环绕增强" class="headerlink" title="环绕增强"></a><em>环绕增强</em></h3><blockquote><p>环绕增强在目标的前后都可以执行织入增强处理。在环绕增强中，可以获取和修改传递的参数，返回值。可以对他进行异常处理，甚至可以决定方法是否被执行</p></blockquote><pre><code>public class test1{  public void testa(ProceedingJoinPoint jp) throws Throwable{    system.out.print(&quot;方法执行前&quot;);    try{      Object result = jp.proceed();//执行方法并获得返回值      return result;    }catch(Throwable e){      system.out.print(&quot;方法异常：&quot;+e);      throw e;    }finally{      system.out.print(&quot;方法执行结束&quot;);    }  }}</code></pre><p>xml配置</p><pre><code>&lt;aop:around method=&quot;增强方法名&quot; pointcut-ref=&quot;切入点id&quot;/&gt;</code></pre><hr><h2 id="使用注解进行操作"><a href="#使用注解进行操作" class="headerlink" title="使用注解进行操作"></a><strong>使用注解进行操作</strong></h2><h2 id="实现控制反转"><a href="#实现控制反转" class="headerlink" title="实现控制反转"></a><em>实现控制反转</em></h2><p>开启注解扫描：</p><pre><code>&lt;context:component-scan base-package=&quot;cn.jbit&quot;/&gt;</code></pre><p>自动扫描带有@Service等注解的文件配置成bean</p><blockquote><p>在需要定义bean的类名上面加上注解即可创建对应的bean。效果等同于：&lt;bean id=”名称” class=”路径”/&gt;<br>注解：</p></blockquote><ul><li>@Repository(“名称”)：用于标注dao类(XXXDao.java)</li><li>@Service(“名称”)：用于标注业务类(XXXServerImpl.java)</li><li>@Controller(“名称”)：用于标注控制器类</li><li>@Component(“名称”)：用于标注控制器类(XXXDaoImpl.java)</li></ul><hr><h3 id="完成属性的装配"><a href="#完成属性的装配" class="headerlink" title="完成属性的装配"></a><em>完成属性的装配</em></h3><p>使用：在需要配置的属性名上面加入注解即可<br></p><pre><code>@Autowired</code></pre><p>该注解自动为属性注入所依赖内容。此时可以省略属性的set方法<br></p><p>如果有一个以上的类型自动匹配时，则可以使用注解指定需要的bean名称<br><br>例：</p><pre><code>@Autowired@Qualifier(&quot;bean名称&quot;)private UserDao userDao;</code></pre><p>也可以直接指定某个bean</p><pre><code>@Rrsource(&quot;&quot;)</code></pre><hr><h3 id="使用注解配置的xml"><a href="#使用注解配置的xml" class="headerlink" title="使用注解配置的xml"></a><em>使用注解配置的xml</em></h3><p>使用注解即可为指定特定的名称的bean注入属性</p><pre><code>@Resource(name=&quot;name&quot;)</code></pre><p>如果没有指定name，只是@Resource。则会自动匹配与属性名相同的bean注入</p><hr><h4 id="配置切面"><a href="#配置切面" class="headerlink" title="配置切面"></a><strong>配置切面</strong></h4><p>配置xml文件</p><pre><code>&lt;bean class=&quot;切面所在的路径&quot;/&gt;&lt;aop:aspectj-autoproxy/&gt;</code></pre><ol><li>使用@Aspect注解在类上添加切面</li><li>使用@Before(“execution(* cn.jbit.dao..*(..))”)将方法定义为切面增强方法</li><li>@Before为前值增强，@AfterReturning(pointcut = “execution(* cn.jbit.dao..*(..))”, returning = “returnValue”)为后置增强。returning为方法接收的返回值名称。如String a则为returning = “a”<blockquote><p>如果多个方法需要匹配同一个表达式，则可以简化。</p></blockquote></li></ol><p>如前置增强和后置增强都需要匹配dao包和其子包(execution(* cn.jbit.dao..*(..))，则可以</p><pre><code>@Pointcut(&quot;execution(* cn.jbit.dao..*(..)&quot;)public void test(){}@Before(&quot; test()&quot;)public void before(){  //前值增强}@AfterReturning(pointcut = &quot;test()&quot;, returning = &quot;a&quot;)public void aterReturning(Object a){  //后置增强}</code></pre><hr><h4 id="配置增强类型"><a href="#配置增强类型" class="headerlink" title="配置增强类型"></a><strong>配置增强类型</strong></h4><p>异常增强：</p><pre><code>@AfterThrowing(pointcut = &quot;test()&quot; , throwing = &quot;e&quot;)public void afterThrowing(RuntimeException e){  //异常增强}</code></pre><p>最终增强：</p><pre><code>@After(&quot;test()&quot;)</code></pre><p>环绕增强：</p><pre><code>@Around(&quot;test()&quot;)public void around(ProceedingJoinPoint jp){  //调用方法：jp,getSignature().getName();  //传入参数：Arrays.toString(jp.getArgs);  Object obj = jp.proceed();//执行方法并返回返回值}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> AOP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Oracle(三)</title>
      <link href="/2020/04/17/oracle-san/"/>
      <url>/2020/04/17/oracle-san/</url>
      
        <content type="html"><![CDATA[<h2 id="使用PL-SQL的好处"><a href="#使用PL-SQL的好处" class="headerlink" title="使用PL/SQL的好处"></a>使用PL/SQL的好处</h2><ol><li>具有编程语言的特点。能把一组sql语句放到一个模块中。使其更具有模块化程序的特点。</li><li>可采用过程性语言控制程序的结构。可以增加逻辑判断，如判断，循环等</li><li>可对程序中的错误进行自行处理。使程序遇见错误时不会立即中断</li><li>具有更好的可以执行，可移植到另一个oracle数据库中</li><li>减少了网络的交互，有助于提高程序性能</li></ol><hr><h2 id="PL-SQL结构"><a href="#PL-SQL结构" class="headerlink" title="PL/SQL结构"></a>PL/SQL结构</h2><pre><code>[declare]--声明部分：在此声明PL/SQL用到的变量，类型及游标。以及局部的存储过程和函数begin--执行部分：过程以及sql语句，程序的主要部分[exception]--异常处理部分：错误处理end;--注意：执行部分不能省略</code></pre><hr><h2 id="运算符关系表达式"><a href="#运算符关系表达式" class="headerlink" title="运算符关系表达式"></a><strong>运算符关系表达式</strong></h2><center>一般运算符</center><table><thead><tr><th align="center">运算符</th><th align="center">意义</th></tr></thead><tbody><tr><td align="center">=</td><td align="center">等于</td></tr><tr><td align="center">&lt;&gt;,!=,~-,^=</td><td align="center">不等于</td></tr><tr><td align="center">&lt;</td><td align="center">小于</td></tr><tr><td align="center">&gt;</td><td align="center">大于</td></tr><tr><td align="center">&lt;=</td><td align="center">小于等于</td></tr><tr><td align="center">&gt;=</td><td align="center">大于等于</td></tr><tr><td align="center">+</td><td align="center">加</td></tr><tr><td align="center">-</td><td align="center">减</td></tr><tr><td align="center">*</td><td align="center">乘</td></tr><tr><td align="center">/</td><td align="center">除</td></tr><tr><td align="center">:=</td><td align="center">赋值</td></tr><tr><td align="center">=&gt;</td><td align="center">关系号</td></tr><tr><td align="center">..</td><td align="center">范围运算符</td></tr><tr><td align="center">||</td><td align="center">字符连接符</td></tr></tbody></table><center>逻辑运算符</center><table><thead><tr><th align="center">运算符</th><th align="center">意义</th></tr></thead><tbody><tr><td align="center">is null</td><td align="center">是空值</td></tr><tr><td align="center">between and</td><td align="center">介于两者之间</td></tr><tr><td align="center">in</td><td align="center">在一列键值中</td></tr><tr><td align="center">and</td><td align="center">与</td></tr><tr><td align="center">or</td><td align="center">或者</td></tr><tr><td align="center">not</td><td align="center">取反值</td></tr></tbody></table><hr><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a><strong>数据类型</strong></h2><h3 id="变量的声明"><a href="#变量的声明" class="headerlink" title="变量的声明"></a><em>变量的声明</em></h3><pre><code>variable_name data_type[(size)][:=init_value];</code></pre><ul><li>variable_name：变量名</li><li>data_type：变量的sql或PL/SQL数据类型</li><li>size：变量的范围</li><li>init_value：初始变量值</li></ul><hr><h3 id="常量的声明"><a href="#常量的声明" class="headerlink" title="常量的声明"></a><em>常量的声明</em></h3><pre><code>variable_name constant data_type[:=init_value];</code></pre><hr><h3 id="常量和变量的声明和赋值"><a href="#常量和变量的声明和赋值" class="headerlink" title="常量和变量的声明和赋值"></a><em>常量和变量的声明和赋值</em></h3><pre><code>declare     --声明变量和赋值常量    v_ename varcahr2(20);    c_rate_incr constant number(8) := 10;    --常量begin    --执行部分    v_ename := ‘test’;end;</code></pre><hr><h3 id="PL-SQL数据类型"><a href="#PL-SQL数据类型" class="headerlink" title="PL/SQL数据类型"></a><em>PL/SQL数据类型</em></h3><blockquote><p>按数据类型可分为：标量数据类型，LOB数据类型，属性类型</p></blockquote><blockquote><p>标量数据类型：和oracle数据类型类似，只是数据长度有所变化。同时新增了boolean数据类型，boolean的值可为：true,false,null</p></blockquote><blockquote><p>LOB数据类型：用于存储大的数据对象。主要支持：bfile,blob,clob,nclob</p></blockquote><blockquote><p>属性类型：用于引用变量或数据库列的数据类型，以及表示表中一行的数据类型。如%type,%rowtype</p></blockquote><ul><li><p>%type：定义一个变量时如果数据类型和已创建的变量(尤其是表的某一列)数据类型一致时可使用。<br><br>优点：</p><ol><li>可以不必知道引用的数据类型</li><li>引用的数据类型改变时可以同时改变，容易保持一致。不用修改程序</li></ol></li><li><p>%rowtype：返回一个数据类型。如果数据类型和数据库表的数据结构一致，可使用。<br><br>优点：</p><ol><li>可以不必知道所引用的数据库中列的个数和数据类型</li><li>所引用的列的个数和数据类型可改变。容易保持一致<blockquote><p>使用语法 </p></blockquote></li></ol></li></ul><pre><code>--v_name的数据类型是tableUser表的id列数据类型v_name tableUser.id%type := 10;--将表的一行数据类型赋值给v_rec。可以v_rec tableUser%rowtype;</code></pre><hr><h2 id="控制语句"><a href="#控制语句" class="headerlink" title="控制语句"></a><strong>控制语句</strong></h2><blockquote><p>控制语句又可分为：条件控制，循环控制，顺序控制</p></blockquote><h3 id="条件控制"><a href="#条件控制" class="headerlink" title="条件控制"></a><em>条件控制</em></h3><blockquote><p> 包括if语句和case语句</p></blockquote><h4 id="if语法"><a href="#if语法" class="headerlink" title="if语法"></a>if语法</h4><pre><code>if&lt;布尔表达式&gt; then     PL/SQL和SQL语句end if;</code></pre><pre><code>if&lt;布尔表达式&gt; then     PL/SQL和SQL语句else     其他语句end if;</code></pre><pre><code>if&lt;布尔表达式&gt; then     PL/SQL和SQL语句elsif &lt;布尔表达式&gt; then    其他语句else     其他语句end if;</code></pre><h4 id="case语法"><a href="#case语法" class="headerlink" title="case语法"></a>case语法</h4><pre><code>case 条件表达式    when 条件表达式结果1 then        语句1    when 条件表达式结果2 then         语句2    [else 语句段]end case;</code></pre><pre><code>case     when 条件表达式1 then        语句1    when 条件表达式2 then         语句2    [else 语句段]end case;</code></pre><hr><h3 id="循环控制"><a href="#循环控制" class="headerlink" title="循环控制"></a><em>循环控制</em></h3><blockquote><p>用于重复执行一系列语句，包括loop，while，for</p></blockquote><h4 id="loop语法"><a href="#loop语法" class="headerlink" title="loop语法"></a>loop语法</h4><pre><code>loop    要执行的语句    exit when&lt;条件语句&gt; --条件满足退出循环end loop;</code></pre><h4 id="while语法"><a href="#while语法" class="headerlink" title="while语法"></a>while语法</h4><pre><code>while &lt;布尔表达式&gt; loop    要执行的语句end loop;</code></pre><h4 id="for语法"><a href="#for语法" class="headerlink" title="for语法"></a>for语法</h4><pre><code>for循环计数器 in [reverse] 下限...上限 loop    执行的语句end loop;</code></pre><hr><h3 id="顺序控制"><a href="#顺序控制" class="headerlink" title="顺序控制"></a><em>顺序控制</em></h3><p>null语句：是一个可执行语句。相当于一个占位符或不执行任何操作的空语句</p><blockquote><p>例：如果在if else语句里。如果值给else语句块添加sql语句，if语句块不写内容则会报语法错误。这时候就需要在if语句块里加入null</p></blockquote><pre><code>if v_id=1 then    null;--如果删除null会报语法错误else    dbms_output.put_line(‘’)end if;</code></pre><hr><h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a><strong>异常处理</strong></h2><blockquote><p>异常类型可大概分为：预定义异常，非预定义异常，用户自定义异常</p></blockquote><h3 id="预定义异常"><a href="#预定义异常" class="headerlink" title="预定义异常"></a><em>预定义异常</em></h3><pre><code>beginexception     when &lt;exception_name&gt; then        sequence_of_statements;    when others then    --其他异常        sequence_of_statements;    end;</code></pre><hr><h3 id="用户自定义异常"><a href="#用户自定义异常" class="headerlink" title="用户自定义异常"></a><em>用户自定义异常</em></h3><blockquote><p>在定义部分定义异常情况</p></blockquote><pre><code>declare    &lt;异常名称&gt; exception;</code></pre><blockquote><p>在执行部分抛出异常</p></blockquote><pre><code>begin    raise &lt;异常名称&gt;</code></pre><blockquote><p>在异常处理部分接收异常</p></blockquote><pre><code>exception    when &lt;异常名称&gt; then    dbms_output.put_line(‘错误类型：’||sqlcode||sqlerrm)</code></pre><hr><h3 id="自定义错误信息"><a href="#自定义错误信息" class="headerlink" title="自定义错误信息"></a><em>自定义错误信息</em></h3><pre><code>raise_application_error(error_name,error_message);</code></pre><blockquote><p>error_name：异常编号。编号必须为-20999~-20000之间的负整数<br>error_message：异常消息文本。长度可达2048字节<br>注意：该自定义错误信息直接写在执行部分即可</p></blockquote><hr><h2 id="游标"><a href="#游标" class="headerlink" title="游标"></a><strong>游标</strong></h2><h3 id="什么是游标"><a href="#什么是游标" class="headerlink" title="什么是游标"></a><strong>什么是游标</strong></h3><blockquote><p>游标是系统为用户开设的一个数据缓冲区，存放sql语句的执行结果。在执行一个有增删改查的PL/SQL块时，oracle会在内存中分配一个缓冲区，将执行结果放在这个缓冲区中。而游标是指向该缓冲区的一个指针</p></blockquote><h3 id="游标分类"><a href="#游标分类" class="headerlink" title="游标分类"></a><strong>游标分类</strong></h3><blockquote><p>在Oracle中，游标可分为：静态游标和动态游标。静态游标是在编译时知道明确的select语句的游标。静态游标又分为隐式游标和显式游标</p></blockquote><h3 id="显式游标"><a href="#显式游标" class="headerlink" title="显式游标"></a><em>显式游标</em></h3><pre><code>cursor cursor_name [(parameter[,parameter]...)][return return_type] is select statement;</code></pre><ul><li>cursor_name：游标名称</li><li>parameter：指定输入参数，不能输入参数长度，例如varchar2(200)</li><li>return_type：定义提取的行的类型</li><li>select statement：查询语句</li></ul><p>打开游标：</p><pre><code>open cursor_name[(parameter)]</code></pre><p>提取游标：</p><pre><code>fetch cursor_name into variables;</code></pre><ul><li>variables：变量名,该方法是将读取出来的内容存放在变量内</li></ul><hr><p>关闭游标：</p><pre><code>close cursor_name;</code></pre><p>示例：</p><pre><code>declare--根据列的类型创建变量    v_name scott.students.stu_name%type;    v_id scott.students.stu_id%type;--创建游标    cursor students_cursor is select stu_name,stu_id from scott.students;begin    --开启游标    open students_cursor;    --循环遍历游标的值    loop    --将单次遍历出来的值存储到变量内    fetch students_cursor into v_name,v_id;        exit when students_cursor%notfound;            DBMS_OUTPUT.put_line(&#39;第&#39;||students_cursor%rowcount||&#39;个用户&#39;||v_name||v_id);    end loop;    --关闭游标    close students_cursor;end;</code></pre><p>显示游标属性：</p><ul><li>%found：只有DML语句影响一行或多行的时候才返回true</li><li>%notfound：如果DML语句没有影响行则返回true</li><li>%rowcount：返回DML影响的行数</li><li>%isopen：返回游标是否已打开<br>使用显示游标更新</li></ul><pre><code>--在声明部分锁定需要修改的表cursor cursor_name is select_statement for update[of columns];</code></pre><ul><li>cursor_name：名称</li><li>select_statement：修改的表查询语句</li><li>of：列名，写上要修改的表的列名<blockquote><p>注意：如果是单表查询就不需要写of<br>在使用for update子句声明游标后使用下列语法更新行</p></blockquote></li></ul><pre><code>update table_name set column_name = column_value where current of cursor_name;</code></pre><ul><li>cursor_name：游标名<blockquote><p>注意：使用前先打开游标，然后通过loop循环修改值</p></blockquote></li></ul><hr><h3 id="循环游标"><a href="#循环游标" class="headerlink" title="循环游标"></a><em>循环游标</em></h3><blockquote><blockquote><p>可简化显示游标的处理代码。循环游标隐式打开游标，自动从活动集获取行，在处理完后自动关闭游标。循环游标自动创建%rowtype类型的变量用作记录索引。</p></blockquote></blockquote><pre><code>--语法for record_index in cursor_name loop     executable_statementsend loop;--示例for table_index in cursor_test loop    cursor_test.nameend loop;</code></pre><ul><li>record_index：是PL/SQL声明的记录变量此变量的属性声明为%rowtype类型。作用域在for循环内。</li><li>cursor_name：游标名</li></ul><blockquote><p>该游标有如下特性：</p></blockquote><ol><li>从游标提取了所有记录之后自动终止</li><li>提取和处理游标中的每一条记录</li><li>如果提取记录之后%notfound返回true则循环终止</li><li>如未有返回行则不进入循环<blockquote><p>no_data_found和%notfound的区别</p></blockquote></li><li>select … into 语句返回0条和多条记录时触发no_data_found</li><li>当update或delete语句的where未找到时触发%notfound</li><li>在提取循环中用%notfound或%found来确定循环的退出条件，而不用no_data_found</li></ol><hr><h2 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a><strong>存储过程</strong></h2><h3 id="子程序的组成"><a href="#子程序的组成" class="headerlink" title="子程序的组成"></a>子程序的组成</h3><p>子程序是已命名的PL/SQL块，存储在数据库中。可以在任何数据库客户端和应用程序中调用。</p><ul><li><p>声明部分</p><ul><li>包括类型，游标，常量，变量，异常和嵌套子程序的声明。退出子程序后将不存在。</li></ul></li><li><p>可执行部分</p><ul><li>包括赋值，控制执行过程和操纵oracle语句。</li></ul></li><li><p>异常处理部分</p><ul><li>包括异常处理程序。负责处理存储过程中的异常</li></ul><hr></li></ul><p>优点</p><ol><li>模块化(可将程序分解为可管理的，明确的逻辑模块)</li><li>可重用性(子程序在创建并执行后可在任意数量的应用程序中执行)</li><li>可维护性(可简化维护操作。)<br>安全性(用户可设置权限。这样不仅使数据更安全，而且可以保证)</li></ol><hr><h3 id="存储过程的用法"><a href="#存储过程的用法" class="headerlink" title="存储过程的用法"></a><em>存储过程的用法</em></h3><blockquote><p>创建存储过程</p></blockquote><pre><code>--语法create [or replace] procedure procedure_name    [(procedure_list)]{is|as}    [local_declarations]begin    executable_statement    [exception]    [exception_handlers]    end [procedure_name];--示例create or replace procedure add_student(    id student.id&amp;type,                        --输入参数，id    name student.name&amp;type default ‘张三’;    --输入参数，姓名。默认为张三    stu_date student.stu_date&amp;type;            --输入参数，时间)isbegin    insert into student values(id,name,stu_date);end;</code></pre><ul><li>procedure_name：存储过程的名称</li><li>procedure_list：参数列表，可选</li><li>local_declarations：局部声明，可选</li><li>executable_statement：可执行语句</li><li>exception_handlers：异常处理，可选</li><li>or replace：可选，如果不包含这个表示创建新的一个存储过程。如果已存在该存储过程则会报错。如果包含这个则表示如果系统中没有则创建新的存储过程。如果有则替换原来的存储过程<blockquote><p>调用存储过程</p></blockquote></li></ul><pre><code>exec[ute] procedure_name (procedure_list)</code></pre><ul><li>execute：执行命令，可简写成exec</li><li>procedure_name：存储空间名称</li><li>procedure_list：传递的参数<blockquote><p>注意：传递参数可按默认顺序传递，也可以用名称传递和混合传递。名称传递：exec add_student (id=&gt;10,name=&gt;’张三’,stu_date=&gt;’2019-01-01’)</p></blockquote></li></ul><h3 id="在PL-SQL调用存储过程"><a href="#在PL-SQL调用存储过程" class="headerlink" title="在PL/SQL调用存储过程"></a><em>在PL/SQL调用存储过程</em></h3><p>直接使用名称调用即可。注意参数的传递。传递方式和sql一样，分为默认传递，名称传递，混合传递。<br>    注意：使用混合传递时，第一个使用名称传递的列后面的所有列都需要使用名称传递</p><blockquote><p>存储过程的参数模式</p></blockquote><p>调用程序是通过参数向被调用的存储过程传递参数的传递的方式分为三种：in，out，in out即输入参数，输入参数，输入/输出参数<br>在创建参数的时候在参数名后面加上传递方式即可改变参数模式</p><blockquote><p>存储过程的访问权限</p></blockquote><p>由于创建存储过程后只有创建的用户或者管理员才能使用。所有如果其他人需要使用的话必须获得execute权限<br>授予权限</p><pre><code>grant execute on procedure_name to user/public</code></pre><ul><li>procedure_name：需要授权的存储过程名称</li><li>user/public：需要授权的用户。或者所有人都可以访问</li></ul><p>撤销权限</p><pre><code>revoke execute on procedure_name from user</code></pre><blockquote><p>删除存储过程</p></blockquote><pre><code>drop procedure procedure_name</code></pre><hr><h3 id="存储过程规则"><a href="#存储过程规则" class="headerlink" title="存储过程规则"></a><em>存储过程规则</em></h3><ol><li>存储过程中不可用直接使用DDL语句。可以通过动态sql实现，但不建议频繁的使用DDL语句</li><li>存储过程必须有相应的出错处理功能</li><li>存储过程中在引用表字段时需要使用%type和%rowtype</li><li>必须在存储过程中做异常捕获。并将异常信息通过os_Msg输出</li><li>-19999~-1的异常为Oracle定义的异常代码</li><li>存储过程必须包含两个输出参数，即on_Flag(number)和os_Msg(varchar2)分别用于标识过程的执行状态和提示信息(包括异常状态下的异常信息)其中on_Flag包含三种取值情况：0标识执行成功但无提示；大于0表示执行成功且有提示；小于0表示执行失败并有提示</li><li>when others必须放在异常处理代码的最后。最为默认处理器没有显示处理的异常</li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Oracle </tag>
            
            <tag> PL/SQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Oracle(二)</title>
      <link href="/2020/03/28/oracle-er/"/>
      <url>/2020/03/28/oracle-er/</url>
      
        <content type="html"><![CDATA[<h2 id="表空间"><a href="#表空间" class="headerlink" title="表空间"></a><strong>表空间</strong></h2><h3 id="表空间的作用"><a href="#表空间的作用" class="headerlink" title="表空间的作用"></a><em>表空间的作用</em></h3><ol><li>对不同用户分配不同的表空间，不同的对象模式分配不同的表空间。方便对用户数据的操纵，对象模式的管理</li><li>可以将不懂的数据文件存放在不同的磁盘中，有利于提高I/O的性能以及有利于备份和恢复数据等</li></ol><hr><h3 id="表空间的分类"><a href="#表空间的分类" class="headerlink" title="表空间的分类"></a><em>表空间的分类</em></h3><center>表空间的分类</center><table><thead><tr><th align="center">类别</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">永久性表空间</td><td align="center">一般保存表，视图，过程和索引等数据。system,sysaux,users(默认),exampe</td></tr><tr><td align="center">临时表空间</td><td align="center">保存系统中短期存在的数据，如排序数据等</td></tr><tr><td align="center">撤销表空间</td><td align="center">用来帮助回退未提交的事务数据，已提交了的数据是不可以恢复的。一般不需要搭建临时和撤销表空间。除非把他们移动到磁盘中提高性能。</td></tr></tbody></table><hr><h3 id="创建表空间"><a href="#创建表空间" class="headerlink" title="创建表空间"></a><em>创建表空间</em></h3><pre><code>--语法create tablespace tabledatafile ‘filename&#39; [ size integer[K|M]][autoextend[off|no]];--实例create tablespace testTabledatafile ‘d:\file\tabTest\a.DBF&#39; size 10M autoextend no;</code></pre><ul><li>table<ul><li>表空间名称</li></ul></li><li>datafile <ul><li>指定组成表空间的一个或多个数据文件。当有多个数据文件时用’，’分隔</li></ul></li><li>filename<ul><li>文件路径和名称</li></ul></li><li>size<ul><li>文件大小。用K指定千字节大小，M指定兆字节大小</li></ul></li><li>autoextend<ul><li>用来启动或禁止数据文件的自动扩展。使用off时会禁用自动扩展。当表空间剩余容量为0时会使数据不能存储到数据库中</li></ul></li></ul><hr><h3 id="删除表空间"><a href="#删除表空间" class="headerlink" title="删除表空间"></a><em>删除表空间</em></h3><pre><code>drop tablespace table_name including contents and datafile;  --删除前最好对数据库备份</code></pre><ul><li>table_name<ul><li>需要删除的表空间名称</li></ul></li></ul><hr><h2 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a><strong>用户管理</strong></h2><h3 id="创建新用户"><a href="#创建新用户" class="headerlink" title="创建新用户"></a><em>创建新用户</em></h3><blockquote><p>每个新用户创建时都会有一个默认表空间和一个临时表空间，如果没有指定，users为默认表空间，temp为临时表空间</p></blockquote><pre><code>--语法create user testUserIDENTIFIED BY passWord[default tablespace tabName][temporary tablespace tab]--实例create user SchemingCatIDENTIFIED BY abcddefault tablespace worktbstemporary tablespace temp</code></pre><ul><li>testUser<ul><li>用户名</li></ul></li><li>passWord<ul><li>用户登录密码</li></ul></li><li>tabName<ul><li>默认表空间</li></ul></li><li>tab<ul><li>临时表空间<blockquote><blockquote><p>注意：如果创建的用户无法登陆，则需要授权create session权限（登陆权限）。如果需要建表则根据需求给与connect（临时用户）或resource（正式用户）</p></blockquote></blockquote></li></ul></li></ul><hr><h3 id="修改用户名密码"><a href="#修改用户名密码" class="headerlink" title="修改用户名密码"></a><em>修改用户名密码</em></h3><pre><code>--语法alter user testUser identified by pwd</code></pre><ul><li>testUser<ul><li>修改的用户</li></ul></li><li>pwd<ul><li>修改的密码</li></ul></li></ul><hr><h3 id="删除用户"><a href="#删除用户" class="headerlink" title="删除用户"></a><em>删除用户</em></h3><pre><code>--语法drop user testUser</code></pre><ul><li>testUser<ul><li>删除的用户</li></ul></li></ul><hr><h2 id="数据库权限"><a href="#数据库权限" class="headerlink" title="数据库权限"></a><strong>数据库权限</strong></h2><blockquote><p>可分为系统权限和对象权限</p></blockquote><h3 id="系统权限"><a href="#系统权限" class="headerlink" title="系统权限"></a><em>系统权限</em></h3><blockquote><p>可以在系统中执行的特定操作。如创建表，创建表空间等都属于系统权限<br>常见权限如下：</p></blockquote><ul><li>create session<ul><li>连接到数据库</li></ul></li><li>create table<ul><li>创建表</li></ul></li><li>create view<ul><li>创建视图</li></ul></li><li>create sequence<ul><li>创建序列</li></ul></li></ul><hr><h3 id="对象权限"><a href="#对象权限" class="headerlink" title="对象权限"></a><em>对象权限</em></h3><blockquote><p>用户可访问和操纵的特定对象。可以通过赋予用户某个特殊的对象来获得某个对象的管理权限，对视图，序列，存储过程，如对某张表的增删改查等</p></blockquote><p>获取权限的两种路径：1. 管理员直接向用户授予权限；2. 管理员将权限授权给角色，然后将角色授予一个或多个用户</p><blockquote><p>为了高效实用，通常是将角色授予用户。其中常用的有：connect，resource，dba等。一般只授予connect和resource。因为dba有所有的系统权限，可以给其他用户，角色授予权限</p></blockquote><p>常用的系统预订角色</p><ul><li>connect<ul><li>需要连接上数据库的用户，特别是不需要创建表的用户</li></ul></li><li>resource<ul><li>更加可靠和正式的数据库用户都能授予该角色，可以创建表，触发器，过程等</li></ul></li><li>dba<ul><li>数据库管理员角色，拥有数据库最高权限，拥有dba角色的用户可以撤销其他用户甚至dba的权限</li></ul></li></ul><hr><pre><code>--授予语法grant 权限|角色 to 用户--授予某张表的权限grant insert[,update][,select][,delete] on 表 to 用户--取消授权revoke 权限|角色 from 用户</code></pre><blockquote><p>如果要授予或取消多个权限/角色则需要用’，’将其分隔</p></blockquote><hr><h2 id="序列"><a href="#序列" class="headerlink" title="序列"></a><strong>序列</strong></h2><h3 id="什么是序列"><a href="#什么是序列" class="headerlink" title="什么是序列"></a><em>什么是序列</em></h3><blockquote><p>序列用来生成唯一，连续的整数的数据库对象。序列可按升序或降序排列</p></blockquote><hr><h3 id="序列的创建"><a href="#序列的创建" class="headerlink" title="序列的创建"></a><em>序列的创建</em></h3><pre><code>--语法create sequence sequence_name[start with integer][increment by integer][maxvalue integer|nomaxvalue][minvalue integer|nominvalue][cycle|nocycle][cache integer|nocache]--实例create sequence namestart with 1increment by 1maxvalue 100cyclecache 20--这组序列的意思是生成一个叫name的序列，从1开始生成，每次序列增加1。序列最多生成到100。序列生成到100后再次从1开始循环生成。缓存20个序列号</code></pre><ul><li>start with<ul><li>指定生成的第一个序列号，对于升序代表的意思是数字开始的最小值，对于降序的意思是数字的最大值</li></ul></li><li>increment by<ul><li>定序号之间的间隔，默认为1。如果n为正数，则为升序，如果n为负数，则为降序</li></ul></li><li>maxvalue/nomaxvalue<ul><li>序列可生成的最大值/如果指定nomaxvalue，升序的默认最大值为10的27次方，降序的最大值为-1</li></ul></li><li>minvalue/nominvalue<ul><li>序列的最小值。minvalue必须小于等于start with。并且必须小于maxvalue/如果指定了nominvalue，升序的最小值为1，降序的最小值为-1026。这是默认值</li></ul></li><li>cycle/nocycle<ul><li>序列在达到最小值或最大值后将从头开始生成/序列达到最小值或最大之后将不再重头开始。这是默认值</li></ul></li><li>cache/nocache<ul><li>可预先分配一组序号。并保留在内存中，这样可以更快的访问序列号。当用完缓存中的所有序列号时，将重新生成一组序列号放在缓存中/不会预先生成序列号。如果创建时忽略了cache integer|nocache则会默认生成并缓存20个序列号</li></ul></li></ul><hr><h3 id="访问序列"><a href="#访问序列" class="headerlink" title="访问序列"></a><em>访问序列</em></h3><blockquote><p>通过nextval和currval伪列爱访问该序列的值。可以从伪列中选择值，但不能修改值。</p></blockquote><ul><li>nextval<ul><li>返回序列下一个值。当第一次使用时，将返回序列的初始值。在下次引用时，自动使用increment by来增加序列值，并返回新值</li></ul></li><li>currval<ul><li>返回序列当前值，即最后一次引用nextval时返回的值。</li></ul></li></ul><hr><h3 id="更改序列"><a href="#更改序列" class="headerlink" title="更改序列"></a><em>更改序列</em></h3><pre><code>--语法alter sequence [schema.]name[increment by integer][maxvalue integer|nomaxvalue][minvalue integer|nominvalue][cycle|nocycle][cache integer|nocache]</code></pre><ul><li>schema<ul><li>如果不是创建序列的用户修改序列则需要加上创建的用户</li></ul></li></ul><hr><h3 id="删除序列"><a href="#删除序列" class="headerlink" title="删除序列"></a><em>删除序列</em></h3><pre><code>--语法drop sequence [schema.]name</code></pre><hr><h3 id="使用序列"><a href="#使用序列" class="headerlink" title="使用序列"></a><em>使用序列</em></h3><blockquote><p>序列生成的数值只能保证在单个对象里实例是唯一的，所以不适合<strong>并行</strong>或<strong>远程环境</strong>里的主关键字。因为各个环境的序列肯能会生成相同的数字，从而导致<strong>冲突</strong>的发生。所以在不需要并行的环境中可以选择序列作为主关键字<br><br>可以使用sys_guid()函数生成32位唯一编码作为主键，适用于并行环境开发</p></blockquote><pre><code>--使用自增长的序列作为主键insert into user values(name.nextval,&#39;张三&#39;,18)</code></pre><blockquote><blockquote><p>注意：在迁移数据库的时候需要注意时。由于迁移后表中已存在数据，所以需要修改序列的初始值，否则会插入重复的数据</p></blockquote></blockquote><hr><h2 id="同义词"><a href="#同义词" class="headerlink" title="同义词"></a><strong>同义词</strong></h2><h3 id="同义词的用途"><a href="#同义词的用途" class="headerlink" title="同义词的用途"></a><em>同义词的用途</em></h3><ol><li>简化sql语句</li><li>隐藏对象名称和持有者</li><li>为分布式数据库的远程对象提供了位置透明性</li><li>提供对对象的公共访问<blockquote><p>注意：访问公共同义词必须经过授权：create select on 同义词名称 to public</p></blockquote></li></ol><hr><h3 id="同义词的分类"><a href="#同义词的分类" class="headerlink" title="同义词的分类"></a><em>同义词的分类</em></h3><blockquote><p>同义词分为私有同义词和公有同义词</p></blockquote><h4 id="私有同义词"><a href="#私有同义词" class="headerlink" title="私有同义词"></a>私有同义词</h4><blockquote><p>只能被当前模式的用户访问。且私有同义词不可以当前模式的对象名称相同。要在当前模式下创建私有同义词，用户必须拥有create synonym系统权限。要在其他用户模式下创建私有同义词，用户必须拥有create any synonym系统权限</p></blockquote><pre><code>--语法create [or replace] synonym [schema.]namefor [schema.]object_name--实例create synonym namefor objName</code></pre><ul><li>or replace<ul><li>表示在同义词存在的情况下替换该同义词</li></ul></li><li>name<ul><li>同义词名称</li></ul></li><li>object_name<ul><li>创建同义词的对象名称</li></ul></li></ul><blockquote><p>使用时直接使用同义词即可。例：select * from objName等于select * from name</p></blockquote><h4 id="公有同义词"><a href="#公有同义词" class="headerlink" title="公有同义词"></a>公有同义词</h4><blockquote><p>可被所有数据库用户访问。创建公有有同义词需要有create public synonym权限</p></blockquote><pre><code>--语法create [or replace] public synonym namefor [schema.]object_name</code></pre><p>公有同义词和私有同义词的区别：</p><ol><li>私有同义词只能在当前模式下访问，且名称不能和当前模式的用户同名。公有同义词可被所有用户访问</li><li>如对象和公有同义词重名时，默认调用对象。当私有同义词和公有同义词重名时默认调用私有同义词</li></ol><hr><h3 id="删除同义词"><a href="#删除同义词" class="headerlink" title="删除同义词"></a><em>删除同义词</em></h3><pre><code>--语法drop [public] synonym [schema.]name</code></pre><p>注意：删除公有同义词时需要加上public</p><hr><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a><strong>索引</strong></h2><h3 id="什么是索引"><a href="#什么是索引" class="headerlink" title="什么是索引"></a><em>什么是索引</em></h3><blockquote><p>索引是与表关联的可选结构。是一种快速访问数据的途径。可提高数据库性能</p></blockquote><hr><h3 id="索引的分类"><a href="#索引的分类" class="headerlink" title="索引的分类"></a><em>索引的分类</em></h3><table><thead><tr><th align="center">物理分类</th><th align="center">逻辑分类</th></tr></thead><tbody><tr><td align="center">分区或非分区索引</td><td align="center">单例或组合索引</td></tr><tr><td align="center">B树索引（标准索引/默认）</td><td align="center">唯一或非唯一索引</td></tr><tr><td align="center">正常或反向键索引</td><td align="center">基于函数索引</td></tr><tr><td align="center">图位索引</td><td align="center"></td></tr></tbody></table><hr><h4 id="B树索引"><a href="#B树索引" class="headerlink" title="B树索引"></a>B树索引</h4><blockquote><p>B树索引也称为标准索引</p></blockquote><pre><code>create [unique] index index_name on table_name(column_list) [tablespace tablespace_name]</code></pre><ul><li>unique<ul><li>指定唯一索引，默认情况下非唯一索引</li></ul></li><li>index_name<ul><li>索引名称</li></ul></li><li>table_name<ul><li>创建索引的表名</li></ul></li><li>column_list<ul><li>创建索引的列名的列表。可以创建多列，用’，’分隔</li></ul></li><li>tablespace_name<ul><li>为索引指定表空间</li></ul></li></ul><blockquote><p>唯一索引：索引的列中任意两行都没有重复值。索引的关键字只能指向表中的一行。创建主键约束和唯一约束时会创建与之对应的唯一索引</p></blockquote><blockquote><p>非唯一索引：单个关键字可以有多个与之关联的行</p></blockquote><hr><h4 id="反向键索引"><a href="#反向键索引" class="headerlink" title="反向键索引"></a>反向键索引</h4><p>优点</p><ol><li>将索引数据分散在多个索引块中</li><li>减少I/O瓶颈的发生<blockquote><p>反向键索引在保持顺序的情况下同时反转索引列的字节。反向键索引通过翻转索引键的数据值来实现</p></blockquote></li></ol><pre><code>create index index_name_keyName on tabName(keyName) reverse</code></pre><ul><li>index_name_keyName<ul><li>索引名</li></ul></li><li>keyName<ul><li>列名</li></ul></li></ul><pre><code>--主键创建反向键索引alter table tabName add constraint keyName primapt key(keyName) using index index_name_keyName</code></pre><hr><h4 id="位图索引"><a href="#位图索引" class="headerlink" title="位图索引"></a>位图索引</h4><p>优点</p><ol><li>最适于低基数列(即列的值是优先的，理论上不会无穷大的)。例如性别，只会有男，女。不会有更多的类型</li><li>对于大批即时查询，可以减少响应的时间</li><li>相比其他索引技术，占用空间明显减少</li><li>即使在配置很低的终端硬件上时，也能获得显著的性能<blockquote><p>注意：位图索引不应用在频繁发生insert，update，delete操作的表上。最适于数据仓库和决策支持系统</p></blockquote></li></ol><pre><code>--语法create bitmap index index_bit_job on tableName(keyName);</code></pre><hr><h4 id="其他索引"><a href="#其他索引" class="headerlink" title="其他索引"></a>其他索引</h4><blockquote><p>组合索引：在表内多列上创建索引<br><br>基于函数的索引：若使用的函数或表达式涉及正在索引的表中的一列或多列，则创建基于函数的索引。可以改为B数索引或位图索引</p></blockquote><pre><code>--语法create index index_name on tabName(upper(keyName))</code></pre><blockquote><p>注意：创建组合索引时将唯一性高(该列放的大部分数据时唯一的)的列放在第一位</p></blockquote><hr><h3 id="创建索引的原则"><a href="#创建索引的原则" class="headerlink" title="创建索引的原则"></a><em>创建索引的原则</em></h3><ol><li>频繁搜索的列可以作为索引</li><li>经常排序，分组的列作为索引</li><li>常用作连接的列(主键/外键)可作为索引</li><li>将索引放在一个单独的表空间中，不要放在有回退段，临时段和表的表空间中</li><li>对大型索引来说，考虑使用nologging子句创建大型索引</li><li>根据业务数据发生的频率，定期重新生成或重新组织索引，并进行碎片整理</li><li>仅包含几个不同值的列不可创建B数索引，可根据需求创建位图索引</li><li>不要在仅包含几行的表中创建索引</li></ol><hr><h3 id="删除索引"><a href="#删除索引" class="headerlink" title="删除索引"></a><em>删除索引</em></h3><pre><code>--语法drop index index_name</code></pre><p>什么时候删除索引</p><ol><li>应用程序不再需要索引</li><li>执行批量加载前。大量加载数据前删除索引，加载完后重建索引有以下好处：提高家在性能；更有效的使用索引控件；</li><li>索引已损坏</li></ol><hr><h3 id="重建索引"><a href="#重建索引" class="headerlink" title="重建索引"></a><em>重建索引</em></h3><pre><code>--将反向键改为B数索引语法alter index index_name rebuild noreveres</code></pre><p>什么时候重建索引</p><ol><li>用户表移动到新的表空间后，表上的所有不是自动转移。因此需要手动将索引移到指定表空间</li><li>索引中包含已删除的表项。对表频繁的删除，造成索引空间的浪费。</li><li>将现有的正常所有转换成反向键索引</li></ol><hr><h2 id="表分区"><a href="#表分区" class="headerlink" title="表分区"></a><strong>表分区</strong></h2><h3 id="什么是表分区"><a href="#什么是表分区" class="headerlink" title="什么是表分区"></a><em>什么是表分区</em></h3><blockquote><p>将一个表中的所有行分为几部分，并将这几部分存储在不同的位置，被分区的表称为分区表。分成的每一个部分称为一个分区</p></blockquote><hr><h3 id="表分区的优点"><a href="#表分区的优点" class="headerlink" title="表分区的优点"></a><em>表分区的优点</em></h3><ol><li>改善表的查询性能。分区后执行查询sql时只访问特点的分区而并未整个表</li><li>表更容易管理。因为分区表的数据存储在多个部分中。按区加载和删除更加容易</li><li>便于备份和恢复。可以独立的备份和恢复每个分区</li><li>提高数据安全性，将不同的分区分布在不同的磁盘。可以减小磁盘损坏时对所有数据同时损坏的可能性</li></ol><hr><h3 id="什么时候分区"><a href="#什么时候分区" class="headerlink" title="什么时候分区"></a><em>什么时候分区</em></h3><ol><li>数据大于2GB</li><li>已有的数据和新增的数据有明显的界限划分<blockquote><p>注意：要分区的表不能有LONG和LONG RAW类型的列</p></blockquote></li></ol><hr><h3 id="分区表的分类"><a href="#分区表的分类" class="headerlink" title="分区表的分类"></a><em>分区表的分类</em></h3><blockquote><p>可分为：范围分区，列表分区。散列分区，复合分区，间隔分区和虚拟分区等。间隔分区和虚拟分区是oracle 11g的新特性</p></blockquote><ol><li>范围分区<blockquote><p>范围分区是应用较广的表分区方式，他以列的值范围作为分区的划分条件。将记录存放到列值的所在range分区中</p></blockquote></li></ol><blockquote><p>注意：在分区时，某些分区暂时无法预测范围，则可以创建maxvalue分区，所有不指定范围的记录都会被储存到这个分区中</p></blockquote><pre><code>--语法partition by range(tabName_keyName)(partition a values less than(value),partition a values less than(maxvalue))</code></pre><ul><li>a<ul><li>第几区的名称</li></ul></li><li>less than<ul><li>小于</li></ul></li><li>value<ul><li>分区的条件。</li></ul></li><li>maxvalue<ul><li>超出最大值后的分区<blockquote><p>例：partition a values less than(to.date(‘2020-01-01’,’yyyy-MM-dd’))：意思就是如果时间小于2020-01-01就将该列放在a分区</p></blockquote></li></ul></li></ul><p>查看第n分区</p><pre><code>select * from user partition(n)</code></pre><p>删除第N分区</p><pre><code>delete from table partition(n)</code></pre><hr><ol start="2"><li>间隔分区<blockquote><p>范围分区的一种增强功能。可以实现范围分区的自动化</p></blockquote></li></ol><pre><code>partition by range(tabName_keyName)interval(numtoyminterval(3,&#39;month&#39;))(partition p1 values less than (to_date(‘2020-01-01&#39;,&#39;yyyy-MM-dd&#39;)))</code></pre><ul><li>interval<ul><li>间隔，按照后面括号中的定义间隔添加分区</li></ul></li><li>numtoyminterval(3,’month’)<ul><li>每3个月为一个分区。numtoyminterval(n,’b’) b可以为day,year或month，那样就表示为n天，n年或n月为一个分区</li></ul></li></ul><blockquote><p>使用该方法在查询数据时需要先知道自动生成的分区名称</p></blockquote><pre><code>--获取分区情况select table_name,partition_name from user_tab_partitions where table_name=upper(‘tabName_keyName&#39;)</code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Oracle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Oracle(一)</title>
      <link href="/2020/03/28/oracle-yi/"/>
      <url>/2020/03/28/oracle-yi/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是Oracle"><a href="#什么是Oracle" class="headerlink" title="什么是Oracle"></a>什么是Oracle</h1><blockquote><p>Oracle Database，又名Oracle RDBMS，或简称Oracle。是甲骨文公司的一款关系数据库管理系统。</p></blockquote><hr><h2 id="Oracle的特点"><a href="#Oracle的特点" class="headerlink" title="Oracle的特点"></a>Oracle的特点</h2><ol><li>支持多用户，大事务量的事务处理</li><li>在保存安全性和完整性方面性能优秀</li><li>支持分布式数据处理，将不同物理位置上的数据库用通信网络连接起来，组成一个逻辑上统一的数据库，完成数据处理任务</li><li>具有可以移植性，可在多个操作平台使用，而Sql Server只能在Windows运行</li></ol><hr><h2 id="常用的数据类型"><a href="#常用的数据类型" class="headerlink" title="常用的数据类型"></a><strong>常用的数据类型</strong></h2><h3 id="字符串数据类型"><a href="#字符串数据类型" class="headerlink" title="字符串数据类型"></a><em>字符串数据类型</em></h3><blockquote><p>字符串数据常用的有：char，varchar2，nchar</p></blockquote><ul><li>char<ul><li>需要使用固定长度的字符串时使用</li><li>长度可为1-2000字节，如在未指定大小则默认1字节</li><li>如果输入的字节小于指定长度则用空格填充至指定长度，如果值大于指定长度则报错</li></ul></li><li>varchar2<ul><li>支持可变长度字符串</li><li>大小为1-4000字节。在定义时应指定大小</li><li>如果输入的字节长度小于指定的字节长度则不会有任何变化，如果值大于指定长度则报错</li></ul></li><li>nchar<ul><li>国家字符集，用法和char相同</li><li>如果开发的项目需要国际化，那么数据类型选择nchar</li><li>nchar用来存储Unicode字符集类型，即双字节字符类型。如果插入’a’，char占用的字节数是1，nchar占用的字节数是2。如果插入中文，char会报错，而nchar不会</li></ul></li></ul><hr><h3 id="数值数据类型"><a href="#数值数据类型" class="headerlink" title="数值数据类型"></a><em>数值数据类型</em></h3><blockquote><p>数值数据常用的有：number</p></blockquote><ul><li>该类型可以存储正数，负数，零，定点数和精度为38位的浮点数</li></ul><p>用法：</p><pre><code>name number(p=38,s=0)name number(p)          //定点数name number(p,s)        //浮点数</code></pre><blockquote><p>p为精度，表示数字的有效数位，在1-38之间。从左边第一个不为0的数算起，小数点和负号不计入有效位数。s为范围,表示小数点右边数字的位数,在-84~+127之间.</p></blockquote><blockquote><p>规则：首先精确到小数点后面s位,并且四舍五入.如果精确后值的有效数≤p则正确，否则报错</p></blockquote><p>例：</p><ol><li>变量：123.14 number(4,2) 精确到小数点后面s位：123.14；有效数位为5，123.14大于规定的有效数位，报错</li><li>变量：123.1 number(5,2) 精确到小数点后面s位：123.10；有效数位为5，123.14等于规定的有效数位，输出123.10</li><li>变量：0.1 number(3,4) 精确到小数点后面s位：0.1000；有效数位为4，0.1000大于规定的有效数位，报错（左边第一个不为0的数算起）</li><li>变量：0.00001 number(3,4)  精确到小数点后面s位：0.0000；有效数位为0，0.0000小于规定的有效数位，输出0.0000</li></ol><hr><h3 id="日期时间数据类型"><a href="#日期时间数据类型" class="headerlink" title="日期时间数据类型"></a><em>日期时间数据类型</em></h3><blockquote><p>数值数据常用的有：date，timestamp</p></blockquote><ul><li>date<ul><li>使用7字节固定长度，每个字节分别存储：世纪，年，月，日，时，分，秒</li><li>函数sysdate是返回当前日期和时间</li></ul></li><li>timestamp<ul><li>用于存储：世纪，年，月，日，时，分，秒。秒精确到小数点后6位</li><li>函数systimestamp是返回当前日期，时间和时区</li></ul></li></ul><hr><h3 id="LOB数据类型"><a href="#LOB数据类型" class="headerlink" title="LOB数据类型"></a><em>LOB数据类型</em></h3><blockquote><p>又称大对象数据类型可以存储4GB的非结构化数据，如声音剪辑和视频剪辑等。LOB可以对数据高效，随机，分段的访问。LOB可以是外部的，也可以是内部的。取决于相对于数据库的位置</p></blockquote><blockquote><p>Oracle中的LOB数据类型有：CLOB，BLOB，BFILE和NCLOB</p></blockquote><ul><li>CLOB(Character LOB，字符LOB)<ul><li>存储大量字符文件可存储单字节字符数据和多字节字符数据</li><li>主要存储非结构化的XML文档，如新闻，内容介绍等含大量文本内容的文档</li></ul></li><li>BLOB(Binary LOB，二进制LOB)<ul><li>存储较大的二进制对象，如音频，视频剪辑和声音剪辑等</li></ul></li><li>BFILE(Binary File，二进制文件)<ul><li>可将二进制文件存储在数据库外部的操作系统文件中</li><li>BFILE列存储一个BFILE定位器，指向位于服务器文件系统的上的二进制文件，支持的大小为4GB</li></ul></li><li>NCLOB<ul><li>用于存储较大的nchar字符数据</li><li>NCLOB同时支持固定宽度字符和可变宽度字符(Unicode 字符数据)。大字符对象的大小不大于4GB</li><li>NCLOB的使用方法和CLOB类似</li></ul></li></ul><hr><h2 id="Oracle中的伪列"><a href="#Oracle中的伪列" class="headerlink" title="Oracle中的伪列"></a><strong>Oracle中的伪列</strong></h2><blockquote><p>伪列像是Oracl中的一个列，但他从未存储在表中。可以查询，但不能添加，删除和修改</p></blockquote><blockquote><p>常用的伪列有：rowid，rownum</p></blockquote><ul><li>rowid<ul><li>数据库中的每行都有一个行地址，rowid伪列返回该行地址</li><li>可用rowid来定位表中的一行。通常情况，rowid可以唯一的标识数据库中的一行<blockquote><p>用法：使用sql查看rowid的值：select rowid from user.emp</p></blockquote></li></ul></li><li>rownum<ul><li>返回的数值代表行的次序，第一行返回1，第二行返回2.以此类推</li><li>可以将此伪列用作where的条件判断，也可以用作显示的列<blockquote><p>使用sql限制返回的行数：select * from user.emp where rownum&lt;11</p></blockquote></li></ul></li></ul><blockquote><p>返回查询表的所有数据和对应的行数：select *,rownum from user.emp</p></blockquote><hr><h2 id="sql语言"><a href="#sql语言" class="headerlink" title="sql语言"></a><strong>sql语言</strong></h2><h3 id="数据库定义语言-DDL"><a href="#数据库定义语言-DDL" class="headerlink" title="数据库定义语言(DDL)"></a><em>数据库定义语言(DDL)</em></h3><blockquote><p>数据库定义语言为：create(创建),alter(更改),truncate(截断),drop(删除)</p></blockquote><ul><li>create</li></ul><pre><code>create Table [schema.] table (column datatype [,column datatype ])(创建表)</code></pre><p>schema：对象所有者，即模式名称。如果用户在自己的模式中创建表则不用指定<br>table：表名<br>column：列名<br>datatype：该列的数据类型即宽度<br>表的命名规范：</p><ol><li>首字符为字母</li><li>不能使用保留字作为表名</li><li>表名的最大字符为30</li><li>同一用户模式下表名不能相同</li><li>可以使用下划线，字母和数字</li><li>但是不能使用空格和单引号<blockquote><p>创建表后添加主键（主键必须not null）：alter table 表名 add constraint yy primary key(主键1，主键2);</p></blockquote></li></ol><hr><h3 id="数据库操纵语言-DML"><a href="#数据库操纵语言-DML" class="headerlink" title="数据库操纵语言(DML)"></a><em>数据库操纵语言(DML)</em></h3><blockquote><p>数据库定义语言为：insert(插入),select(选择),delete(删除),update(更新)</p></blockquote><ul><li>insert</li></ul><pre><code>--插入多条数据insert allinto 表名 values()into 表名 values()select 1 from dual;</code></pre><ul><li>distinct</li></ul><pre><code>--自动合并重复的行select distinct name from user.emp</code></pre><ul><li>使用现有的表创建新表</li></ul><pre><code>create table &lt;newTable&gt; as select {*|column(s)} from &lt;oldtable&gt; [where]</code></pre><blockquote><p>如果where条件为false，则不会复制表数据，只会复制表结构</p></blockquote><ul><li>取出列不重复的数据记录</li></ul><pre><code>select name,age from user.emp group by name having (count(name||age)&lt;2)</code></pre><hr><h3 id="事务控制语言-TCL"><a href="#事务控制语言-TCL" class="headerlink" title="事务控制语言(TCL)"></a><em>事务控制语言(TCL)</em></h3><blockquote><p>事务控制语言为：commit(提交),savepoint(保存点),rollback(回滚)</p></blockquote><ul><li>commit：提交事务</li><li>rollback：事务回滚</li><li>savepoint：在事务中创建存储点</li><li>rollback to&lt;name&gt;：将事务回滚到存储点</li></ul><hr><h2 id="sql操作符"><a href="#sql操作符" class="headerlink" title="sql操作符"></a><strong>sql操作符</strong></h2><blockquote><p>sql操作符可分为：算数操作符，比较操作符，逻辑操作符，集合操作符，连接字符串</p></blockquote><h3 id="算数操作符"><a href="#算数操作符" class="headerlink" title="算数操作符"></a>算数操作符</h3><blockquote><p>+，-，*，/</p></blockquote><h3 id="比较操作符"><a href="#比较操作符" class="headerlink" title="比较操作符"></a>比较操作符</h3><blockquote><p>=，！=，&lt;，&gt;，&lt;=，&gt;=，between…and(值是否在两个值之间)，or，in，like，is null</p></blockquote><h3 id="逻辑操作符"><a href="#逻辑操作符" class="headerlink" title="逻辑操作符"></a>逻辑操作符</h3><blockquote><p>and，not，or</p></blockquote><h3 id="集合操作符"><a href="#集合操作符" class="headerlink" title="集合操作符"></a>集合操作符</h3><blockquote><p>union，union all，intersect，minus</p></blockquote><ul><li>union<ul><li>union(并集)操作符返回两个查询选定的所有不重复的行<blockquote><p>例：select * from user union select * from student –获取两个表的所有不重复的行</p></blockquote></li></ul></li><li>union all<ul><li>union all(并集all)合并两个查询选定的所有行，包括重复的行<blockquote><p>例：select * from user union all select * from student –获取两个表的所有行</p></blockquote></li></ul></li><li>intersect<ul><li>intersect(交集)只返回两个表都有的行<blockquote><p>例：select * from user intersect select * from student –返回两个表都有的行</p></blockquote></li></ul></li><li>minus<ul><li>minus(减集)只返回被第一个查询选定的行而未被第二个查询选中的行</li></ul></li></ul><p>连接字符串</p><blockquote><p>||：用于将两个或多个字符串合并成一个字符串，或者将一个字符串和一个数值合并在一起。可以用于在查询语句中将多个列拼接在一起</p></blockquote><hr><h2 id="sql函数"><a href="#sql函数" class="headerlink" title="sql函数"></a><strong>sql函数</strong></h2><blockquote><p>sql函数可分为：单行函数，聚合函数，分析函数</p></blockquote><blockquote><blockquote><p>单行函数：字符函数，日期函数，数字函数，转换函数，其他函数<br><br><br>聚合函数：也称为分组函数。基于数据库的多行进行运算，返回一个结果。如对多行记录的某个字段求和，求最大值运算<br><br><br>分析函数：对一个查询结果中的每个结果进行分组运算</p></blockquote></blockquote><h3 id="转换函数"><a href="#转换函数" class="headerlink" title="转换函数"></a><em>转换函数</em></h3><blockquote><p>将一种数据类型转换成另一种数据类型</p></blockquote><table><thead><tr><th align="center">函数</th><th align="center">功能</th><th align="center"><center>实例</center></th><th align="center">结果</th></tr></thead><tbody><tr><td align="center">to_char()</td><td align="center">转换成字符串</td><td align="center">TO_CHAR(1234.5,’$9999.9’)</td><td align="center">$1234.5</td></tr><tr><td align="center">to_date()</td><td align="center">转换成日期类型</td><td align="center">TO_DATE(‘1980-01-01’,’yyyy-mm-dd’)</td><td align="center">01-1月-80</td></tr><tr><td align="center">to_number()</td><td align="center">转换成数值类型</td><td align="center">TO_NUMBER(‘1234.5’)</td><td align="center">1234.5</td></tr></tbody></table><blockquote><p>TO_CHAR(d| n [,fmt])</p></blockquote><p>d是日期，n是数字fmt是指定的日期或数字的格式。根据格式转换成varchar2数据类型。如果省略了fmt，日期将为默认日期格式转换。常用与格式化日期类型<br>例：</p><pre><code>TO_CHAR(date,&#39;YYYY&#39;年&#39;fmMM&#39;月&#39;fmDD&#39;日&#39; HH24:MI:SS&#39;) --使用fm避免空格和数字填充时间</code></pre><hr><blockquote><p>TO_DATE(CHAR[,fmt])</p></blockquote><p>将varchar或者char类型转换成日期格式。常用与将字符串类型的数据转换成日期格式</p><pre><code>TO_DATE(&#39;2020-01-01&#39;,&#39;yyyy-MM-dd&#39;)</code></pre><hr><h3 id="其他函数"><a href="#其他函数" class="headerlink" title="其他函数"></a><em>其他函数</em></h3><table><thead><tr><th align="center">函数</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">NVL(a,b)</td><td align="center">如果a的值为null则返回b的值</td></tr><tr><td align="center">NVL2(a,b,c)</td><td align="center">如果a的值为null则返回c的值，否则返回b的值</td></tr><tr><td align="center">DECODE(a,b,c,d,e,else)</td><td align="center">如果a等于b则返回c；如果a等于d则返回e，否则返回else</td></tr></tbody></table><hr><h3 id="分析函数"><a href="#分析函数" class="headerlink" title="分析函数"></a><em>分析函数</em></h3><blockquote><p>函数名([参数1]) over ([分区子句][排序子句])</p></blockquote><ul><li>函数名<ul><li>需要分析的函数名称</li></ul></li><li>参数<ul><li>函数需要传入的参数</li></ul></li><li>分区子句(PARTITION BY)<ul><li>根据列的值将数据分成不同的分区</li></ul></li><li>排序子句(ORDER BY)<ul><li>每个分区按照什么列进行排序</li></ul></li></ul><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a><em>函数</em></h3><ul><li>row_number<ul><li>返回唯一的值，遇见相同的数据时，按照排名顺序依次增加</li></ul></li><li>dense_rank<ul><li>返回唯一的值，遇见相同的数据时，所有数据的排名都是一致的</li></ul></li><li>rank<ul><li>返回位置的值，遇见相同的数据时，所有数据的排名都是一致的，同时会在最后一条相同记录和下一条不同记录的排名之间空出排名</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Oracle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring(一)</title>
      <link href="/2020/02/17/spring-yi/"/>
      <url>/2020/02/17/spring-yi/</url>
      
        <content type="html"><![CDATA[<h2 id="Spring是什么"><a href="#Spring是什么" class="headerlink" title="Spring是什么"></a><strong>Spring是什么</strong></h2><p>Spring是分层的Java SE/EE应用，full-stack（全栈式）轻量级开源框架。以IOC和AOP为内核</p><h2 id="Spring两大核心"><a href="#Spring两大核心" class="headerlink" title="Spring两大核心"></a><strong>Spring两大核心</strong></h2><p>Spring的两大核心分别是IOC和AOP</p><ul><li>IOC<ul><li>Inverse Of Control/反转控制/控制反转<br></li><li>降低程序间的耦合</li></ul></li><li>AOP<ul><li>Aspect Oriented Programming/面向切面编程<br></li><li>在不改变原有代码的基础上织入新的功能</li></ul></li></ul><h2 id="Spring的优势"><a href="#Spring的优势" class="headerlink" title="Spring的优势"></a><strong>Spring的优势</strong></h2><p>轻量级，开源，方便解耦，声明式（配置）事务的支持，AOP的支持，方便测试，方便集成其他框架</p><hr><h2 id="程序的耦合和解耦"><a href="#程序的耦合和解耦" class="headerlink" title="程序的耦合和解耦"></a><strong>程序的耦合和解耦</strong></h2><h3 id="什么是耦合"><a href="#什么是耦合" class="headerlink" title="什么是耦合"></a><em>什么是耦合</em></h3><p>简单的说，程序之间的依赖叫做耦合</p><ol><li>类之间的依赖</li><li>方法之间的依赖</li></ol><hr><h3 id="什么是解耦"><a href="#什么是解耦" class="headerlink" title="什么是解耦"></a><em>什么是解耦</em></h3><p>降低程序之间的依赖/降低耦合；叫做解耦</p><blockquote><p>开发中应做到：编译时不依赖，运行时才依赖</p></blockquote><hr><h2 id="IOC的概念和作用"><a href="#IOC的概念和作用" class="headerlink" title="IOC的概念和作用"></a><strong>IOC的概念和作用</strong></h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a><em>概念</em></h3><h4 id="什么是IOC？为什么叫控制反转？"><a href="#什么是IOC？为什么叫控制反转？" class="headerlink" title="什么是IOC？为什么叫控制反转？"></a><em>什么是IOC？为什么叫控制反转？</em></h4><blockquote><p>IOC是通过Bean工厂来实例化对象。由之前自己创建对象到将创建对象的权利交给工厂或框架来做，这就叫做控制反转</p></blockquote><h4 id="IOC的作用"><a href="#IOC的作用" class="headerlink" title="IOC的作用"></a><em>IOC的作用</em></h4><blockquote><p>削减计算机的耦合，但不能彻底消除耦合</p></blockquote><h4 id="为什么使用IOC"><a href="#为什么使用IOC" class="headerlink" title="为什么使用IOC"></a><em>为什么使用IOC</em></h4><blockquote><p>通常的实例化对象如果出现类名的变动，由于类之间的高耦合。需要将实例化全部修改一遍，而用了IOC解耦后只需要修改配置文件即可</p></blockquote><hr><h3 id="基于xml的IOC环境搭建"><a href="#基于xml的IOC环境搭建" class="headerlink" title="基于xml的IOC环境搭建"></a><em>基于xml的IOC环境搭建</em></h3><blockquote><p>首先获取Spring的常用jar包(可去maven官网下载，或使用maven项目)</p></blockquote><ul><li>commons-logging</li><li>mysql-connector</li><li>spring-aop</li><li>spring-beans</li><li>spring-context</li><li>spring-core</li><li>spring-expression</li><li>spring-jcl<blockquote><p>配置applicationContext.xml文件</p></blockquote></li></ul><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans        https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;    &lt;!-- 将实例化对象交给Spring --&gt;    &lt;bean id=&quot;UserDaoImpl&quot; class=&quot;cn.jbit.news.dao.Impl.UserDaoImpl&quot;&gt;&lt;/bean&gt;    &lt;bean id=&quot;UserServetImpl&quot; class=&quot;cn.jbit.news.servet.impl.UserServetImpl&quot;&gt;&lt;/bean&gt;&lt;/beans&gt;</code></pre><blockquote><p>创建对应的bean，可以通过对应的方法创建对象。这样就降低了程序之间的耦合</p></blockquote><h4 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a><em>创建对象</em></h4><h5 id="立即加载"><a href="#立即加载" class="headerlink" title="立即加载"></a>立即加载</h5><blockquote><p>创建对象是采用立即加载，读取完配置文件所有对象就已经被创建</p></blockquote><pre><code>ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;applicationContext.xml/文件位置&quot;);IUserDao userDao = (IUserDao)ac.getBean(&quot;xml配置的id&quot;);</code></pre><p>提示：(IUserDao)ac.getBean(“xml配置的id”);和ac.getBean(“xml配置的id”,IUserDao.class);是一样的</p><hr><h5 id="延迟加载"><a href="#延迟加载" class="headerlink" title="延迟加载"></a>延迟加载</h5><blockquote><p>创建对象是采用延迟加载，等实例化时才创建对象</p></blockquote><pre><code>Resource resource = new ClassPathResource(&quot;bean.xml&quot;);BeanFactory factory = new XmlBeanFactory(resource);IUserDao userDao = (IUserDao)factory.getBean(&quot;UserDaoImpl&quot;);</code></pre><h4 id="Spring对Bean的管理"><a href="#Spring对Bean的管理" class="headerlink" title="Spring对Bean的管理"></a><em>Spring对Bean的管理</em></h4><ol><li><p>采用默认构造函数</p><blockquote><p>在Spring配置文件中使用bean标签，配上id和class属性后，且没有其他属性和标签时，采用的就是默认构造函数创建bean对象。如这时候类中无默认构造函数则对象无法创建</p></blockquote><pre><code> &lt;bean id=&quot;UserDaoImpl&quot; class=&quot;cn.jbit.news.dao.Impl.UserDaoImpl&quot;&gt;&lt;/bean&gt;</code></pre></li><li><p>使用普通工厂中的方法创建对象（使用某个类中的方法创建对象，并存入Spring容器）</p><blockquote><p>例：A工厂有一个方法返回了B对象，如果这时候想获取B对象，但是由于A工厂没有默认构造函数。所以只能采用第二张方法来创建bean对象</p></blockquote><pre><code> &lt;bean id=”工厂名称” class=”工厂全限定类名”&gt;&lt;/bean&gt; &lt;bean id=”B对象名称” factory-bean=”工厂名称/id” factory-method=”工厂里返回B对象的方法名”&gt;&lt;/bean&gt;</code></pre></li><li><p>使用工厂中的静态方法创建对象（使用某个类中的静态方法创建对象，并存入Spring容器）</p><pre><code> &lt;bean id=”B对象名称” class=”工厂全限定类名” factory-method=”工厂里返回B对象的方法名”&gt;&lt;/bean&gt;</code></pre></li></ol><h4 id="bean对象的作用范围调整"><a href="#bean对象的作用范围调整" class="headerlink" title="bean对象的作用范围调整"></a><em>bean对象的作用范围调整</em></h4><blockquote><p>bean标签的scope属性</p></blockquote><blockquote><p>作用：指定bean的作用范围;取值：(常用的是单例和多例)</p></blockquote><ul><li>singleton：<ul><li>单例（默认值）</li></ul></li><li>prototype：<ul><li>多例</li></ul></li><li>request：<ul><li>作用于web应用的请求范围</li></ul></li><li>session：<ul><li>作用于web应用的会话范围</li></ul></li></ul><h4 id="bean的生命周期"><a href="#bean的生命周期" class="headerlink" title="bean的生命周期"></a><em>bean的生命周期</em></h4><blockquote><p>单例对象</p></blockquote><p>出生：容器被创建时<br><br>活着：只要容器在，对象一直活着<br><br>死亡：容器销毁 <br></p><blockquote><p>多例对象</p></blockquote><p>出生：对象被使用时<br><br>活着：对象在使用过程中一直活着<br><br>死亡：对象长时间不使用，且没有被别的对象引用时，由java的垃圾回收器回收<br></p><hr><h2 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a><strong>依赖注入</strong></h2><h3 id="常用的注入方式"><a href="#常用的注入方式" class="headerlink" title="常用的注入方式"></a><em>常用的注入方式</em></h3><blockquote><p>能注入的数据有三类:1.基本类型和String;2.其他bean类型(在配置文件中或注解配置过的bean);3.负责类型/集合类型</p></blockquote><blockquote><p>注入的方式</p></blockquote><ol><li>使用构造函数</li><li>使用set方法（常用）</li><li>使用注解</li><li>p命名空间注入</li></ol><h4 id="构造函数注入"><a href="#构造函数注入" class="headerlink" title="构造函数注入"></a><em>构造函数注入</em></h4><ol><li>在类中定义可注入的变量</li><li>创建有参的构造器<blockquote><p>经常变化的数据不适合注入</p></blockquote></li></ol><p>标签：constructor-arg<br><br>位置：bean内部<br><br>属性：<br></p><ul><li>type：<ul><li>用于指定要注入的数据类型，该类型也是构造函数中的某个参数类型</li></ul></li><li>index：<ul><li>用于指定注入的数据给构造函数中指定索引位置的参数赋值，索引从0开始</li></ul></li><li>name：<ul><li>用于指定给构造函数中指定名称的参数赋值（常用）</li></ul></li><li>value：<ul><li>用于提供基本类型和String类型的数据</li></ul></li><li>ref：<ul><li>用于指定其他的bean类型数据。它指的是在IOC核心容器中出现的bean对象。无法注入集合</li></ul></li></ul><pre><code>&lt;bean id=&quot;UserDaoImpl&quot; class=&quot;cn.jbit.news.dao.Impl.UserDaoImpl&quot;&gt;    &lt;constructor-arg name=”age/构造函数中的数据名称” value=”赋值”&gt;&lt;/constructor-arg&gt;    &lt;constructor-arg name=”Time” ref=”time”&gt;&lt;/constructor-arg&gt;&lt;/bean&gt;&lt;bean id=”time” class=”java.util.Date”&gt;&lt;/bean&gt;</code></pre><p>优点<br><br>    在获取bean对象时，注入数据时必须的操作，否则对象无法创建成功<br><br>缺点<br><br>    改变了bean对象的实例化方式。如果在实例化时用不到这些参数也必须提供</p><blockquote><p>注意：使用时需创建有参和无参构造器。如果constructor-arg没有指定name，则按有参构造器的参数顺序依次赋值</p></blockquote><h4 id="使用set方法"><a href="#使用set方法" class="headerlink" title="使用set方法"></a><em>使用set方法</em></h4><ol><li>类里提供set方法</li></ol><p>标签：property<br><br>位置：bean内<br><br>属性<br></p><ul><li>name：<ul><li>类中的set方法去掉set后名称</li></ul></li><li>value：<ul><li>用于提供基本类型和String类型的数据</li></ul></li><li>ref：<ul><li>用于指定其他的bean类型数据。它指的是在IOC核心容器中出现的bean对象。无法注入集合</li></ul></li></ul><pre><code>&lt;bean id=&quot;UserDaoImpl&quot; class=&quot;cn.jbit.news.dao.Impl.UserDaoImpl&quot;&gt;    &lt;property name=”age/set方法中去掉set后的名称” value=”赋值”&gt;&lt;/property&gt;    &lt;property name=”Time” ref=”time”&gt;&lt;/property&gt;    &lt;/bean&gt;&lt;bean id=”time” class=”java.util.Date”&gt;&lt;/bean&gt;</code></pre><p>优势<br><br>    创建对象时没有限制，可以使用默认构造函数<br><br>缺点<br><br>    如果某个成员必须有值，则获取对象有可能set方法没有执行<br></p><h4 id="p命名空间注入"><a href="#p命名空间注入" class="headerlink" title="p命名空间注入"></a><em>p命名空间注入</em></h4><p>属性：p<br><br>位置：bean的属性<br><br>用法：p:属性=”value”<br></p><pre><code>&lt;bean id=&quot;UserDaoImpl&quot; class=&quot;cn.jbit.news.dao.Impl.UserDaoImpl&quot; p:name=&quot;张三&quot;&gt;</code></pre><p>注意：</p><ol><li>在beans标签里加入属性xmlns:p=”<a href="http://www.springframework.org/schema/p&quot;" target="_blank" rel="noopener">http://www.springframework.org/schema/p&quot;</a></li><li>多个p直接用空格分隔</li><li>如果需要引用bean属性，则使用p:属性-rep=”bean属性的id”</li></ol><h3 id="注入复杂数据"><a href="#注入复杂数据" class="headerlink" title="注入复杂数据"></a><em>注入复杂数据</em></h3><ol><li>使用set注入</li></ol><p>位置：property内<br><br>用于给list集合结构注入的标签：list,array,set<br><br>用于给map集合结构注入的标签：map,props<br></p><blockquote><p>结构相同，标签可以互换</p></blockquote><pre><code>&lt;bean id=&quot;UserDaoImpl&quot; class=&quot;cn.jbit.news.dao.Impl.UserDaoImpl&quot;&gt;    &lt;property name=”集合的set名称”&gt;        &lt;array&gt;            &lt;value&gt;aaa&lt;/value&gt;            &lt;value&gt;bbb&lt;/value&gt;            &lt;value&gt;ccc&lt;/value&gt;        &lt;/array&gt;    &lt;/property&gt;    &lt;property name=”集合的set名称”&gt;        &lt;list&gt;            &lt;value&gt;aaa&lt;/value&gt;            &lt;value&gt;bbb&lt;/value&gt;            &lt;value&gt;ccc&lt;/value&gt;        &lt;/list&gt;    &lt;/property&gt;    &lt;property name=”集合的set名称”&gt;        &lt;map&gt;            &lt;entry key=”” value=””&gt;&lt;/entry&gt;        &lt;/map&gt;    &lt;/property&gt;&lt;/bean&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> IOC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringMVC</title>
      <link href="/2020/02/13/springmvc/"/>
      <url>/2020/02/13/springmvc/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是MVC"><a href="#什么是MVC" class="headerlink" title="什么是MVC"></a>什么是MVC</h1><blockquote><p>全名ModelViewController，是模型(model)视图(view)控制器(controller)的缩写。是一种用于设计创建Web应用程序表现层(servlet)的模式</p></blockquote><hr><h2 id="web-xml配置"><a href="#web-xml配置" class="headerlink" title="web.xml配置"></a><strong>web.xml配置</strong></h2><ol><li><font size="4"><strong><a href="#配置控制器">前端控制器</a></strong></font> <em>(核心)</em></li><li><font size="4"><strong><a href="#请求参数">编码过滤器</a></strong></font> <em>(处理参数提交乱码)</em></li></ol><hr><h2 id="springmvc-xml配置"><a href="#springmvc-xml配置" class="headerlink" title="springmvc.xml配置"></a><strong>springmvc.xml配置</strong></h2><ol><li><font size="4"><strong><a href="#注解扫描">注解扫描</a></strong></font> <em>(可以使用注解:RequestMapping,ResponseBody…)</em></li><li><font size="4"><strong><a href="#视图解析器对象">视图解析器对象</a></strong></font> <em>(将返回的字符串作为相应地址/返回的字符串作为跳转的文件名)</em></li><li><font size="4"><strong><a href="#响应参数">SpringMVC框架注解支持</a></strong></font> <em>(处理返回参数的乱码)</em></li><li><font size="4"><strong><a href="#静态资源映射">静态资源映射</a></strong></font> <em>(js文件加载失败)</em></li><li><font size="4"><strong><a href="#配置文件解析器">文件上传解析器</a></strong></font> <em>(让File控件能上传文件)</em></li><li><font size="4"><strong><a href="#配置拦截器">拦截器</a></strong></font> <em>(在请求处理之前或之后或者视图渲染之后进行操作)</em></li></ol><hr><h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a><strong>环境配置</strong></h2><h3 id="配置控制器"><a href="#配置控制器" class="headerlink" title="配置控制器"></a><strong>配置控制器</strong></h3><blockquote><p>在Web.xml文件内添加控制器</p></blockquote><pre><code>&lt;servlet&gt;    &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt;    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;    &lt;init-param&gt;        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;        &lt;!-- src根目录下的xml --&gt;        &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt;    &lt;/init-param&gt;    &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;    &lt;/servlet&gt;    &lt;servlet-mapping&gt;        &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt;    &lt;url-pattern&gt;/&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;</code></pre><blockquote><p>根据springmvc.xml创建的位置不同，param-value的路径也不同。如果不加这个标签，默认路径在WEB-INF。如：</p></blockquote><pre><code>&lt;param-value&gt;classpath:resources/springmvc.xml&lt;/param-value&gt;</code></pre><hr><h3 id="配置springmvc-xml"><a href="#配置springmvc-xml" class="headerlink" title="配置springmvc.xml"></a><strong>配置springmvc.xml</strong></h3><blockquote><p>Web项目在src目录下创建springmvc.xml文件，maven项目在resource目录下创建</p></blockquote><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;    xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;    xmlns:context=&quot;http://www.springframework.org/schema/context&quot;    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;    xsi:schemaLocation=&quot;        http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd        http://www.springframework.org/schema/mvc        http://www.springframework.org/schema/mvc/spring-mvc.xsd        http://www.springframework.org/schema/context        http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;&lt;/beans&gt;</code></pre><hr><h3 id="开启注解扫描"><a href="#开启注解扫描" class="headerlink" title="开启注解扫描"></a><strong>开启注解扫描</strong></h3><pre><code>&lt;context:component-scan base-package=&quot;cn.SpringMVC.controller(servlet路径)&quot;/&gt;</code></pre><hr><h3 id="视图解析器对象"><a href="#视图解析器对象" class="headerlink" title="视图解析器对象"></a><strong>视图解析器对象</strong></h3><pre><code>&lt;bean id=&quot;viewResolver&quot; class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;    &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/pages/(跳转的文件位置)&quot;/&gt;    &lt;property name=&quot;suffix&quot; value=&quot;.jsp(跳转的文件后缀)&quot;/&gt;&lt;/bean&gt;</code></pre><hr><h3 id="配置类"><a href="#配置类" class="headerlink" title="配置类"></a><strong>配置类</strong></h3><blockquote><p>使用注解：@Controller；@RequestMapping；@ResponseBody；</p></blockquote><ol><li>在类名上面添加<font color="red"><strong>@Controller</strong></font></li><li>在方法名上添加@RequestMapping(path=”访问名称”)/可简写成@RequestMapping()</li></ol><p>注意：</p><ul><li>方法的返回值通常为String，List，对象</li><li><font color="red"><strong>@RequestMapping(name=”/index”,method=RequestMethod.GET)</strong></font>：<br><br>name：字符串即为跳转的页面名称<br><br>method：指定该方法为post的提交方式还是get提交方式，只有对应的提交方式才能进入对应的方法。所以可以通过不同的提交方式进入同名称，提交方式不同的方法内</li><li><font color="red"><strong>@ResponseBody()</strong></font>；返回的字符串即为json格式的字符串</li></ul><hr><h2 id="接收参数"><a href="#接收参数" class="headerlink" title="接收参数"></a><strong>接收参数</strong></h2><blockquote><p>当传递的参数名和方法的参数名对不上时，方法的参数不会被赋值。需要在方法参数前面加上：@RequestParam(“传递的参数名”)</p></blockquote><h3 id="返回值为String"><a href="#返回值为String" class="headerlink" title="返回值为String"></a><strong>返回值为String</strong></h3><ul><li>接收get，post数据<ul><li>方法可以写成public void getUser(User user){}</li><li>传递的参数会自动封装到对应的对象里去</li><li>如果传递的参数是对象内的对象属性，可以使用：对象属性.属性的方法进行传递,例：card.cardNO=123</li></ul></li><li>接收json数据<ul><li>在方法前面加上 <strong><font color="red">@RequestBody</font></strong> 就可以将接收的json格式的参数对应到方法的参数内</li></ul></li></ul><hr><h3 id="返回值为List，对象"><a href="#返回值为List，对象" class="headerlink" title="返回值为List，对象"></a><strong>返回值为List，对象</strong></h3><blockquote><p>只需在方法上面加上@ResponseBody。该方法会将返回的List，对象转化成json格式的字符串，然后返回</p></blockquote><hr><h2 id="处理中文乱码"><a href="#处理中文乱码" class="headerlink" title="处理中文乱码"></a><strong>处理中文乱码</strong></h2><h3 id="请求参数"><a href="#请求参数" class="headerlink" title="请求参数"></a><strong>请求参数</strong></h3><blockquote><p>传递参数时，如果是中文，有时候会出现乱码。这时候需要在web.xml里添加编码过滤器来解决乱码问题</p></blockquote><pre><code>&lt;filter&gt;    &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt;    &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;        &lt;init-param&gt;            &lt;param-name&gt;encoding&lt;/param-name&gt;            &lt;param-value&gt;utf-8&lt;/param-value&gt;        &lt;/init-param&gt;        &lt;init-param&gt;            &lt;param-name&gt;forceEncoding&lt;/param-name&gt;            &lt;param-value&gt;true&lt;/param-value&gt;        &lt;/init-param&gt;    &lt;/filter&gt;    &lt;filter-mapping&gt;        &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt;    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt;</code></pre><hr><h3 id="响应参数"><a href="#响应参数" class="headerlink" title="响应参数"></a><strong>响应参数</strong></h3><blockquote><p>由于返回字符串和返回对象，lsit集合的字符编码不同，所以返回对象，list集合不用进行乱码配置。只有返回字符串才需要对乱码进行修改</p></blockquote><ul><li>方法一<blockquote><p>将方法的注释上改为：@RequestMapping(value=”访问名称”,produces=”application/html;charset=utf-8”)</p></blockquote></li><li>方法二<blockquote><p>对servlet.xml进行全局配置</p></blockquote></li></ul><pre><code>&lt;mvc:annotation-driven&gt;    &lt;mvc:message-converters register-defaults=&quot;true&quot;&gt;        &lt;bean class=&quot;org.springframework.http.converter.StringHttpMessageConverter&quot;&gt;            &lt;property name=&quot;supportedMediaTypes&quot; value=&quot;text/plain;charset=UTF-8&quot;/&gt;        &lt;/bean&gt;    &lt;/mvc:message-converters&gt;&lt;/mvc:annotation-driven&gt;</code></pre><hr><h2 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a><strong>Ajax</strong></h2><blockquote><p>SpringMVC的Ajax使用方法和普通方法没有区别。需要注意的是加载js或者jquery文件时会报错。可配置静态资源解析器来解决这个问题。</p></blockquote><hr><h2 id="静态资源映射"><a href="#静态资源映射" class="headerlink" title="静态资源映射"></a><strong>静态资源映射</strong></h2><blockquote><p>springmvc.xml里加入</p></blockquote><pre><code>&lt;mvc:resources location=&quot;/js/&quot; mapping=&quot;/js/*&quot;/&gt;</code></pre><p>注意：<font color="red">文件夹位置一定要和WEB-INF同级</font>，否则会报错not mapping for Get/项目/js文件夹/js文件</p><hr><h3 id="转发"><a href="#转发" class="headerlink" title="转发"></a><strong>转发</strong></h3><p><strong><center>原版</center></strong></p><pre><code>@RequestMapping(num1)public void test1(HttpServletRequest request,HttpServletResponse response){    //重定向    Response.sendRedirect(&quot;跳转地址.jsp&quot;);}</code></pre><p><strong><center>SpringMVC</center></strong></p><pre><code>@RequestMapping(num2)public String Test2(){    //转发;    return &quot;&quot;;}</code></pre><hr><h3 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a><strong>重定向</strong></h3><p><strong><center>原版</center></strong></p><pre><code>@RequestMapping(num1)public void test1(HttpServletRequest request,HttpServletResponse response){    //转发    Request.getRequestDispatcher(跳转地址.jsp).forward(request,response);}</code></pre><p><strong><center>SpringMVC</center></strong></p><pre><code>@RequestMapping(num2)public String Test2(){    //重定向;    return &quot;redirect:地址.jsp&quot;;}</code></pre><hr><p>注意：</p><ul><li>转发：字符串返回结果默认为转发</li><li>重定向：如果后缀有.jsp则跳转到页面，如果没有后缀则可以跳转到RequestMapping的方法内</li></ul><blockquote><p>提示：<br>如果不同的servlet有相同的方法名，使用转发或重定向时会出现冲突。这时候可以在类的上面加入@RequestMapping(类名)。这时跳转当前的servlet方法不需要加上类名，从ajax或jsp访问方法则需要加上’类名/方法’。这样可以防止多个servle出现重名方法。<br>当给类起名后，返回字符串的文件名前面需要加’/‘</p></blockquote><hr><h2 id="传递参数"><a href="#传递参数" class="headerlink" title="传递参数"></a><strong>传递参数</strong></h2><blockquote><p>当需要吧数据存放至Request或者Session时可以使用原版的方法或者Model</p></blockquote><p><strong>原版</strong>：</p><ul><li>使用HttpServletRequest的setAttribute(“key”,”value”)进行传递</li><li><em>Model*</em>:</li><li>使用Model的addAttribute(“key”,”value”)进行传递</li></ul><hr><h2 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a><strong>文件上传</strong></h2><h3 id="配置文件解析器"><a href="#配置文件解析器" class="headerlink" title="配置文件解析器"></a><strong>配置文件解析器</strong></h3><blockquote><p>在springmvc.xml里加入</p></blockquote><pre><code>&lt;bean id=&quot;multipartResolver&quot; class=&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;&gt;    &lt;!-- 设置字符编码集 --&gt;    &lt;property name=&quot;defaultEncoding&quot; value=&quot;utf-8&quot;&gt;&lt;/property&gt;    &lt;!-- 设置文件大小 --&gt;    &lt;property name=&quot;maxUploadSize&quot; value=&quot;1024000&quot;&gt;&lt;/property&gt;&lt;/bean&gt;</code></pre><hr><h3 id="上传单个文件"><a href="#上传单个文件" class="headerlink" title="上传单个文件"></a><strong>上传单个文件</strong></h3><p><strong>Jsp页面</strong></p><pre><code>&lt;form action=&quot;跳转地址&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt;    &lt;input type=&quot;file&quot; name=&quot;file&quot;/&gt;    &lt;input type=&quot;submit&quot; name=&quot;上传按钮&quot;/&gt;&lt;/form&gt;</code></pre><p><strong>servlet页面</strong></p><pre><code>public String uoload(MultipartFile 表单名){}</code></pre><hr><h3 id="上传多个文件"><a href="#上传多个文件" class="headerlink" title="上传多个文件"></a>上传多个文件</h3><p><strong>Jsp页面</strong></p><pre><code>&lt;form action=&quot;跳转地址&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt;    &lt;input type=&quot;file&quot; name=&quot;file&quot;/&gt;    &lt;input type=&quot;file&quot; name=&quot;file&quot;/&gt;    &lt;input type=&quot;file&quot; name=&quot;file&quot;/&gt;    &lt;input type=&quot;file&quot; name=&quot;file&quot;/&gt;    &lt;input type=&quot;submit&quot; name=&quot;上传按钮&quot;/&gt;&lt;/form&gt;</code></pre><p><strong>servlet页面</strong></p><pre><code>public String uoload(MultipartFile[] 表单名){    for(MultipartFile multipartFile : 表单名){    //遍历文件名    System.out.print(multipartFile.getOriginalFilename());    }}</code></pre><hr><h2 id="拦截器和拦截器站"><a href="#拦截器和拦截器站" class="headerlink" title="拦截器和拦截器站"></a><strong>拦截器和拦截器站</strong></h2><h3 id="什么是拦截器"><a href="#什么是拦截器" class="headerlink" title="什么是拦截器"></a><strong>什么是拦截器</strong></h3><blockquote><p>拦截器是一个SpringMVC控件，用来对数据进行一些处理</p></blockquote><hr><h3 id="拦截器有什么用"><a href="#拦截器有什么用" class="headerlink" title="拦截器有什么用"></a><strong>拦截器有什么用</strong></h3><ol><li>在请求进入处理器之前做一些操作</li><li>在处理器完成任务之后做一些操作</li><li>在视图渲染之后做一些操作</li></ol><hr><h3 id="拦截器站是什么"><a href="#拦截器站是什么" class="headerlink" title="拦截器站是什么"></a><strong>拦截器站是什么</strong></h3><blockquote><p>多个拦截器组成一个拦截器</p></blockquote><hr><h3 id="配置拦截器"><a href="#配置拦截器" class="headerlink" title="配置拦截器"></a><strong>配置拦截器</strong></h3><blockquote><p>在springmvc.xml里写入</p></blockquote><pre><code>&lt;mvc:interceptors&gt;    &lt;mvc:interceptor&gt;        &lt;!-- SpringMVC开头的路径都拦截 --&gt;        &lt;mvc:mapping path=&quot;/Springmvc/**&quot;/&gt;        &lt;!-- 拦截器路径 --&gt;        &lt;bean class=&quot;cn.SpringMVC.interceptor.FirstInterceptor&quot;&gt;&lt;/bean&gt;    &lt;/mvc:interceptor&gt;&lt;/mvc:interceptors&gt;</code></pre><blockquote><p>配置多个拦截器<br>将下列代码复制粘贴至&lt;mvc:interceptors&gt;标签内，修改拦截器路径即可</p></blockquote><pre><code>&lt;mvc:interceptor&gt;    &lt;!-- SpringMVC开头的路径都拦截 --&gt;    &lt;mvc:mapping path=&quot;/Springmvc/**&quot;/&gt;    &lt;!-- 拦截器路径 --&gt;    &lt;bean class=&quot;cn.SpringMVC.interceptor.FirstInterceptor&quot;&gt;&lt;/bean&gt;&lt;/mvc:interceptor&gt;</code></pre><hr><h3 id="使用拦截器"><a href="#使用拦截器" class="headerlink" title="使用拦截器"></a><strong>使用拦截器</strong></h3><p>关键方法：</p><ul><li>Boolean preHandle()    //进入控制器之前的操,作如果返回true则进入控制器或下一个控制器</li><li>Void postHandle() //控制器完成任务后的操作</li><li>Void afterCompletion()    //视图渲染之后的操作</li></ul><p>创建拦截器</p><ol><li>创建interceptor包，然后创建拦截器FirstInterceptor.java</li><li>实现HandlerInterceptor接口</li><li>重写HandlerInterceptor的关键方法<br>提示：<blockquote><p>可使用抽象方法secondInterceptor实现HandlerInterceptor的两个无返回值的方法，后续拦截器只需要继承secondInterceptor并实现preHandle就行</p></blockquote></li></ol><hr><h3 id="拦截器站的运行顺序"><a href="#拦截器站的运行顺序" class="headerlink" title="拦截器站的运行顺序"></a><strong>拦截器站的运行顺序</strong></h3><blockquote><p>控制器完成任务之前按照配置文件的顺序加载preHandle。等控制器执行完成之后执行顺序将反过来，最后配置的最先运行</p></blockquote><hr><h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a><strong>异常处理</strong></h2><h3 id="局部异常"><a href="#局部异常" class="headerlink" title="局部异常"></a><strong>局部异常</strong></h3><blockquote><p>出错后跳转到error.jsp页面.该方法只能在一个控制器起作用</p></blockquote><pre><code>@ExceptionHandlerpublic String handleException(Exception exception){    Exception.printStackTrace();    return &quot;error&quot;;}</code></pre><hr><h3 id="全局异常"><a href="#全局异常" class="headerlink" title="全局异常"></a><strong>全局异常</strong></h3><ul><li>注解<ol><li>创建一个类</li><li>在类名上加上注解：@ControllerAdvice</li><li>创建一个局部异常处理方法</li></ol></li><li>配置xml文件<blockquote><p>使用配置文件解决异常</p></blockquote></li></ul><pre><code>&lt;bean class=&quot;org.springframework.web.servlet.handler.SimpleMappingExceptionResolver.class&quot;&gt;    &lt;property name=&quot;exceptionMappings&quot;&gt;        &lt;props key=&quot;java.lang.Exception&quot;&gt;            &lt;prop key=&quot;java.lang.Exception&quot;&gt;error&lt;/prop&gt;        &lt;/props&gt;    &lt;/property&gt;&lt;/bean&gt;</code></pre><hr><h2 id="额外增加的注解"><a href="#额外增加的注解" class="headerlink" title="额外增加的注解"></a><strong>额外增加的注解</strong></h2><h3 id="RequestParam"><a href="#RequestParam" class="headerlink" title="@RequestParam"></a><em>@RequestParam</em></h3><p>该注解有三个参数</p><ul><li><p>value</p><ul><li>传入的参数名</li></ul></li><li><p>required</p><ul><li>该参数是否为必须的，默认为true。表示传入的参数必须包含对应的参数名，如果不存在就抛出异常。false表示传入的参数名可以没有指定的value。</li></ul></li><li><p>defaultValue</p><ul><li>默认参数名。不推荐使用</li></ul><hr></li></ul><h3 id="ModelAttribute"><a href="#ModelAttribute" class="headerlink" title="@ModelAttribute"></a><em>@ModelAttribute</em></h3><pre><code>public void test(@ModelAttribute(&quot;user&quot;)User user){    return &quot;index&quot;;}</code></pre><blockquote><p>该注解将属性添加到模型中，效果等同于：</p></blockquote><pre><code>public void test(User user, Model model){    model.addAttribue(&quot;user&quot;,user);    return &quot;index&quot;;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ajax </tag>
            
            <tag> 入门 </tag>
            
            <tag> 框架 </tag>
            
            <tag> SpringMVC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis框架(三)</title>
      <link href="/2020/02/01/mybatis-kuang-jia-san/"/>
      <url>/2020/02/01/mybatis-kuang-jia-san/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是延迟加载"><a href="#什么是延迟加载" class="headerlink" title="什么是延迟加载"></a>什么是延迟加载</h2><blockquote><p>在真正使用数据时才发起查询，不用的时候不查询。按需加载（也叫做懒查询）</p></blockquote><hr><h2 id="什么是立即加载"><a href="#什么是立即加载" class="headerlink" title="什么是立即加载"></a>什么是立即加载</h2><blockquote><p>只要一调用方法，不管数据是否正在使用。马上发起查询</p></blockquote><hr><h2 id="怎么使用延迟加载"><a href="#怎么使用延迟加载" class="headerlink" title="怎么使用延迟加载"></a>怎么使用延迟加载</h2><blockquote><p>在一对多，多对多中，通常采用延迟加载。在多对一，一对一中，通常采用立即加载</p></blockquote><hr><h3 id="一对一使用延迟加载"><a href="#一对一使用延迟加载" class="headerlink" title="一对一使用延迟加载"></a>一对一使用延迟加载</h3><ol><li>将&lt;select&gt;里的多表查询语句改成单表查询。查询sql写成select * from 账户表</li><li>将&lt;resultMap&gt;的子标签&lt;association&gt;清空，然后添加属性select=”用户表.xml的mapper标签的属性namespace属性.用户表的根据用户id查询所有信息的方法”(&lt;association&gt;标签的column属性即为查询的用户id)</li><li>在SqlMapConfig.xml的&lt;configuration&gt;标签下 添加标签</li></ol><pre><code>&lt;settings&gt;    &lt;!--开启Mybatis支持延迟加载--&gt;    &lt;setting name=&quot;lazyLoadingEnabled&quot; value=&quot;true&quot;/&gt;    &lt;!--开启Mybatis支持延迟加载--&gt;    &lt;setting name=&quot;aggressiveLazyLoading&quot; value=&quot;false&quot;/&gt;&lt;/settings&gt;</code></pre><hr><h3 id="一对多使用延迟加载"><a href="#一对多使用延迟加载" class="headerlink" title="一对多使用延迟加载"></a>一对多使用延迟加载</h3><ol><li>将&lt;select&gt;里的多表查询语句改成单表查询。查询sql写成select * from 用户表</li><li>将&lt;resultMap&gt;的子标签&lt;collection&gt;清空，然后添加属性column=”传入用户的id” 和select=”账户表.xml的mapper标签的属性namespace属性.账户表根据用户id查询所有信息的方法”</li><li>在SqlMapConfig.xml的&lt;configuration&gt;标签下 添加标签</li></ol><pre><code>&lt;settings&gt;    &lt;!--开启Mybatis支持延迟加载--&gt;    &lt;setting name=&quot;lazyLoadingEnabled&quot; value=&quot;true&quot;/&gt;    &lt;!--开启Mybatis支持延迟加载--&gt;    &lt;setting name=&quot;aggressiveLazyLoading&quot; value=&quot;false&quot;/&gt;&lt;/settings&gt;</code></pre><hr><h2 id="Mybatis中的缓存"><a href="#Mybatis中的缓存" class="headerlink" title="Mybatis中的缓存"></a>Mybatis中的缓存</h2><h3 id="什么是缓存"><a href="#什么是缓存" class="headerlink" title="什么是缓存"></a>什么是缓存</h3><blockquote><p>存在于内存中的临时数据，在下次使用时将直接调用缓存的数据</p></blockquote><h3 id="为什么使用缓存"><a href="#为什么使用缓存" class="headerlink" title="为什么使用缓存"></a>为什么使用缓存</h3><blockquote><p>减少和数据库的交互次数，提高执行效率</p></blockquote><h3 id="什么数据能使用缓存，什么数据不能使用"><a href="#什么数据能使用缓存，什么数据不能使用" class="headerlink" title="什么数据能使用缓存，什么数据不能使用"></a>什么数据能使用缓存，什么数据不能使用</h3><blockquote><p><strong>适用于</strong>：<em>经常查询并且不经常改变的。数据的正确与否对最终结果影响不大的</em></p></blockquote><blockquote></blockquote><blockquote><p><strong>不适用于</strong>：<em>经常改变的数据。数据的正确与最终影响很大的</em></p></blockquote><h3 id="一级缓存和二级缓存"><a href="#一级缓存和二级缓存" class="headerlink" title="一级缓存和二级缓存"></a>一级缓存和二级缓存</h3><h4 id="一级缓存"><a href="#一级缓存" class="headerlink" title="一级缓存"></a>一级缓存</h4><ul><li>Mybatis中sqlSession对象的缓存</li><li>当执行查询后，查询的结果会同时存入到SqlSession里。然后提供一块区域。该区域的结构是一个Map。当我们再次查询同样的数据，Mybatis会先去SqlSession中查看，如果有的话会拿出来使用</li><li>当SqlSession消失时一级缓存就消失了</li><li>当调用SqlSession的增，删，改，commit()，colse()等方法时会清空一级缓存</li></ul><h4 id="二级缓存"><a href="#二级缓存" class="headerlink" title="二级缓存"></a>二级缓存</h4><ul><li>Mybatis中SqlSessionFactory对象的缓存。由同一个SqlSessionFactory对象创建的SqlSession共享缓存</li></ul><blockquote><p>二级缓存的使用步骤</p></blockquote><ol><li><p><strong>让Mybatis框架支持二级缓存（在SqlMapConfig.xml中配置）</strong></p><p>在configuration标签中添加</p></li></ol><pre><code>    &lt;settings&gt;&lt;setting name=”cacheEnabled”  value=”true”&gt;&lt;/settings&gt;</code></pre><ol start="2"><li><strong>让当前映射文件支持二级缓存（在Dao.xml中配置）</strong></li></ol><p>在Mapper标签中添加</p><pre><code>&lt;cache/&gt;</code></pre><ol start="3"><li><strong>让当前操作支持二级缓存（在select标签中配置）</strong></li></ol><p>在select标签内加入属性</p><pre><code>useCache=”true”</code></pre><blockquote><p>二级缓存虽然不用再次查询数据库，但是因为每次拿取都会将数据存储到一个新的对象中</p></blockquote><hr><h2 id="Mybatis中的注解开发"><a href="#Mybatis中的注解开发" class="headerlink" title="Mybatis中的注解开发"></a>Mybatis中的注解开发</h2><h3 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h3><blockquote><p>创建SqlMapConfig.xml</p></blockquote><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration  PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;  &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt;    &lt;propeties resoure=”jdbcConfig.properties”&gt;&lt;/propeties&gt;    &lt;package name=”实体类全路径名”&gt;&lt;/package&gt;    &lt;environments default=&quot;mysql&quot;&gt;        &lt;environment id=&quot;mysql&quot;&gt;            &lt;transactionManager type=&quot;JDBC&quot;/&gt;            &lt;dataSource type=&quot;POOLED&quot;&gt;                &lt;property name=&quot;driver&quot; value=&quot;${Driver/propeties里的Driver名称}&quot;/&gt;                &lt;property name=&quot;url&quot; value=&quot;${url}&quot;/&gt;                &lt;property name=&quot;username&quot; value=&quot;${username}&quot;/&gt;                &lt;property name=&quot;password&quot; value=&quot;${userpassword}&quot;/&gt;            &lt;/dataSource&gt;        &lt;/environment&gt;    &lt;/environments&gt;    &lt;mappers&gt;        &lt;package name=”dao的文件夹全路径”&gt;&lt;/package&gt;    &lt;/mappers&gt;&lt;/configuration&gt;</code></pre><h3 id="单表CRUD操作（代理Dao方式）"><a href="#单表CRUD操作（代理Dao方式）" class="headerlink" title="单表CRUD操作（代理Dao方式）"></a>单表CRUD操作（代理Dao方式）</h3><blockquote><p>使用注解的时候存在dao.xml控制台会报错。如果写注解就要删除dao.xml</p></blockquote><blockquote></blockquote><blockquote><p>四个常用注解：@Select,@Insert,@Update,@Delete</p></blockquote><p>使用：</p><blockquote><p>在接口的方法上面直接使用 @Select(value=”Sql”)</p></blockquote><ul><li>如果只传sql，value可以省略。直接写@Select(“sql”)</li><li>如果需要传参则和xml的使用方法一致，使用#{name}即可</li><li>如果传入到数据库出现中文乱码，在数据库url后面加上：?characterEncoding=utf8&amp;autoReconnect=true&amp;useSSL=false</li></ul><h3 id="实体类属性名和数据库列名的相对应"><a href="#实体类属性名和数据库列名的相对应" class="headerlink" title="实体类属性名和数据库列名的相对应"></a>实体类属性名和数据库列名的相对应</h3><blockquote><p>使用@Results()注解</p></blockquote><p>例：</p><pre><code>@Select(“select * from user”)@Results(id=”名称，其他方法可以通过id引用这个注解”,value={    @Result(id=true/如果是主键则将id设为true,property=”实体类属性名”,column=”数据库列名”),    @Result(property=”实体类属性名”,column=”数据库列名”),    @Result(property=”实体类属性名”,column=”数据库列名”),})public void addUser(User user);</code></pre><ul><li>其他方法想引用@Results注解需要在开头加上@ResultMap(value={“Id名称”});</li><li>只有一个数据，value可以省略，只写@ResultMap(“Id名称”);</li></ul><h3 id="多表查询操作"><a href="#多表查询操作" class="headerlink" title="多表查询操作"></a>多表查询操作</h3><ul><li>多对一，一对一</li></ul><pre><code>@Select(“select * from user”)@Results(id=”名称，其他方法可以通过id引用这个注解”,value={    @Result(id=true/如果是主键则将id设为true;,property=”实体类属性名”,column=”数据库列名”),    @Result(property=”实体类属性名”,column=”数据库列名”),    @Result(property=”实体类属性名”,column=”数据库列名”),    @Result(property=”实体类对象属性名”,column=”根据id查询的条件”,one=@One(select=”全路径名(dao的package内容).dao接口.根据id查询的方法名”,fetchType=FetchType.EAGER(立即加载))),})</code></pre><ul><li>一对多，多对多</li></ul><pre><code>@Select(“select * from user”)@Results(id=”名称，其他方法可以通过id引用这个注解”,value={    @Result(id=true/如果是主键则将id设为true,property=”实体类属性名”,column=”数据库列名”),    @Result(property=”实体类属性名”,column=”数据库列名”),    @Result(property=”实体类属性名”,column=”数据库列名”),    @Result(property=”实体类对象属性名”,column=”根据id查询的条件”,many=@Many(select=”全路径名(dao的package内容).dao接口.根据id查询的方法名”,fetchType=FetchType.LAZY(稍后加载))),    })</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 入门 </tag>
            
            <tag> Mybatis </tag>
            
            <tag> 框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis框架(二)</title>
      <link href="/2020/01/18/mybatis-kuang-jia-er/"/>
      <url>/2020/01/18/mybatis-kuang-jia-er/</url>
      
        <content type="html"><![CDATA[<h2 id="获取新添加的ID"><a href="#获取新添加的ID" class="headerlink" title="获取新添加的ID"></a><strong>获取新添加的ID</strong></h2><blockquote><p>将&lt;selectKey&gt;标签写在&lt;insert&gt;标签里。这样就能在对象执行添加方法后将新增ID添加到调用的对象内</p></blockquote><pre><code>&lt;selectKey keyProperty=&quot;id/对应实体类&quot; keyColumn=&quot;数据库id/对应数据库的列名&quot; resultType=&quot;数据类型/int&quot; order=&quot;AFTER(之后)/BEFORE(之前)(先执行还是后执行)&quot;&gt;    Select last_insert_id()&lt;/selectKey&gt;</code></pre><hr><h2 id="传递属性的封装"><a href="#传递属性的封装" class="headerlink" title="传递属性的封装"></a><strong>传递属性的封装</strong></h2><blockquote><p>如果方法需要传递多个参数，例如2个对象。这时候如果使用之前的方法就不合适，因为parameterType只能传递一个路径/一个参数，所以这时候就要使用QueryVo和OGNL表达式完成该操作。</p></blockquote><p><font size="2">OGNL:<strong>Object</strong>(对象)<strong>Graphic</strong>(图)<strong>Navigation</strong>(导航)<strong>Language</strong>(语言)</font></p><blockquote><p>之前传递一个路径时直接使用对象属性就可以获取参数，而使用OGNL后则需要使用对象.属性的方法获取属性。这样就可以同时使用对象1.属性和对象2.属性了。所以OGNL就是创建一个类，在类中将实体类作为一个属性，并提供对应的get和set方法。然后在<strong>parameterType</strong>只需要传入该类的路径即可做到传递多个属性的操作。在dao的传递方法中记得将传递参数改为该类。</p></blockquote><p>例：</p><ol><li>在(实体类)src/main/java/entiy中创建QueryVo.java</li><li>将所有实体类作为属性在QueryVo.java中创建。并进行封装。</li><li>将dao接口的方法参数改为QueryVo：void addUser(QueryVo vo);</li><li>将<insert>标签中的parameterType属性路径改为QueryVo.java的路径：src.main.java.entiy.QueryVo</insert></li><li>然后在sql语句中调用对应的参数：insert into user values(#{对象1.属性},#{对象2.属性})</li><li>在测试类的调用方法时使用QueryVo作为参数传递：</li><li>QueryVo vo = new QueryVo()</li><li>Vo.setUser(user/对象);//将对象存储至QueryVo</li><li>User.adduser(vo)    //调用添加方法并将QueryVo传递过去</li></ol><hr><h2 id="输出结果的封装"><a href="#输出结果的封装" class="headerlink" title="输出结果的封装"></a>输出结果的封装</h2><blockquote><p>一般用于查询操作。实体类属性名和数据库列名不一致的解决方法</p></blockquote><ul><li>在sql语句写别名，用as将数据库列名和实体类属性名一一对应</li><li>使用<resultMap>标签</resultMap></li></ul><pre><code>//该标签写在dao.xml的\&lt;mapper\&gt;下&lt;resultMap id=&quot;自己起的名称&quot; type=&quot;实体类的路径名&quot;&gt;    &lt;!-- 主键字段对应 --&gt;    &lt;id property=&quot;实体类的属性名&quot; column=&quot;数据库列名&quot;&gt;&lt;/id&gt;    &lt;!-- 非主键字段对应 --&gt;    &lt;result property=&quot;实体类的属性名&quot; column=&quot;数据库列名&quot;&gt;&lt;/result&gt;&lt;/resultMap&gt;</code></pre><blockquote><p>将&lt;select&gt;的resultType去掉，换成resultMap=”上面的id名称”</p></blockquote><p><font size="4"><strong>注意：这种执行效率不如第一种起别名的方法，但是比上一种开发效率更快。因为写过一次之后其他的操作可以直接调用。而第一种需要写一次sql语句起一次别名。根据个人喜好选择其中一种</strong></font></p><hr><h2 id="package"><a href="#package" class="headerlink" title="package"></a>package</h2><blockquote><p>使用该标签可以给路径起别名。这样可以节约每次必须写全路径名的时间<br>在SqlMapConfig.xml的configuration标签里进行配置</p></blockquote><pre><code>&lt;typeAliases&gt;    &lt;package name=&quot;src.main.java.entity&quot;&gt;&lt;/package&gt;&lt;/typeAliases&gt;</code></pre><p>这样在使用resultType标签或者parameterType标签时就可以直接使用src/main/java/entity下面的类名了。例如调用src/main/java/entity/user可以简写成parameterType=”user</p><blockquote><p>在<mappers>加入<package>标签可以省略resource或class</package></mappers></p></blockquote><pre><code>&lt;package name=&quot;src.main.java.dao&quot;&gt;&lt;/package&gt;即可使用dao文件夹下的所有dao.xml配置</code></pre><hr><h2 id="Mybatis连接处和事务"><a href="#Mybatis连接处和事务" class="headerlink" title="Mybatis连接处和事务"></a>Mybatis连接处和事务</h2><h3 id="Mybatis连接池"><a href="#Mybatis连接池" class="headerlink" title="Mybatis连接池"></a>Mybatis连接池</h3><hr><p><strong>什么是连接池？</strong></p><blockquote><p>连接池就是用于存储多个连接的一个<strong>容器</strong>。该容器是一个<strong>集合对象</strong>。该集合<strong>必须是安全的线程</strong>，不能两个线程拿到同一连接。该集合还必须实现队列的特效：<strong>先进先出</strong><br>连接池中有多个连接，需要时从连接池拿取。用完后将连接返还给连接池等待下次使用</p></blockquote><p><strong>为什么要用连接池？</strong></p><blockquote><p>每次不用新建一个连接。可以减少获取连接所消耗的时间</p></blockquote><p><strong>Mybatis中的连接池</strong></p><blockquote><p>在主配置文件SqlMapConfig.xml中的dataSource标签。Type属性表示采用什么连接池方式</p></blockquote><center><font size="2">Type的取值</font></center><table><thead><tr><th align="center">取值</th><th align="center"><center>说明</center></th></tr></thead><tbody><tr><td align="center">POOLED</td><td align="center">采用传统的javax.sql.DataSource规范中的连接池。Mybatis中有针对规范的实现。<strong>每次从池中获取连接，运行完后将连接返还</strong></td></tr><tr><td align="center">UNPOOLED</td><td align="center">采用传统的连接方式。虽然也是采用的javax.sql.DataSource，但是没有池的概念。也就是说<strong>每次用都是获取的一个新的连接</strong></td></tr><tr><td align="center">JNDI</td><td align="center">采用的是服务器提供的JNDI技术实现，来获取DataSource对象不同的服务器拿到的DataSource各不同。如果不是web或者maven的war工程，是不能使用的</td></tr></tbody></table><h3 id="Mybatis事务控制"><a href="#Mybatis事务控制" class="headerlink" title="Mybatis事务控制"></a>Mybatis事务控制</h3><p><font size="5">什么是事务？</font></p><blockquote><p>是数据库操作的最小工作单元，是作为单个逻辑工作单元执行的一系列操作；这些操作作为一个整体一起向系统提交，要么都执行、要么都不执行；事务是一组不可再分割的操作集合（工作逻辑单元）</p></blockquote><blockquote><p>缩略：是一组不可分割的操作集合。一系列操作要么都执行，要么都不执行</p></blockquote><hr><p><font size="5">事务的四大特性ACID是什么？</font></p><blockquote><p>原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持续性（Durability）</p></blockquote><ul><li><strong>原子性</strong>：一系列操作要么都不做，要么都做</li><li><strong>一致性</strong>：一系列操作如果全部提交成功则数据库处于一致性状态，如果有一个提交失败则初一不一致状态</li><li><strong>隔离性</strong>：各个事务之间应该是隔离的，并发执行的各个事务之间不能互相干扰</li><li><strong>持续性</strong>：一旦事务提交它对数据库的操作应该是永久性的。接下来的其他操作或故障不应该对执行结果有任何影响</li></ul><hr><p><font size="5">不考虑隔离性会产生的3个问题是什么？</font></p><blockquote><p>脏读，不可重复读，幻象读</p></blockquote><ul><li><strong>脏读</strong>：一个事务正在访问并修改数据的途中另一个事务使用了这个正在修改的数据，这个时候另一个事务所读取的数据称为脏数据。依照脏数据所做的操作肯定是不正确的</li><li><strong>不可重复读</strong>：一个事务两次读取同一个数据，读取到第二次的时候如果这时候第二个事务修改了数据。这时候第一个事务两次读取的数据时不一样的。这种情况称为不可重复读</li><li><strong>幻象读</strong>：一个事务先后读取一个范围的记录，但两次读取的纪录数不同，我们称之为幻象读（两次执行同一条 select 语句会出现不同的结果，第二次读会增加一数据行，并没有说这两次执行是在同一个事务中）</li></ul><hr><p><font size="5">解决方法：四种隔离性分别是什么？</font></p><center><font size="2">√：可能会出现&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;×：不会出现</font></center><table><thead><tr><th align="center">隔离级别</th><th align="center">脏读</th><th align="center">不可重复读</th><th align="center">幻想毒</th></tr></thead><tbody><tr><td align="center">read uncommited（读未提交）</td><td align="center">√</td><td align="center">√</td><td align="center">√</td></tr><tr><td align="center">read commited（读提交）</td><td align="center">×</td><td align="center">√</td><td align="center">√</td></tr><tr><td align="center">read repeatable（读重复）</td><td align="center">×</td><td align="center">×</td><td align="center">√</td></tr><tr><td align="center">serializable（序列化）</td><td align="center">×</td><td align="center">×</td><td align="center">×</td></tr></tbody></table><ul><li>read uncommited：是最低的事务隔离级别，它允许另外一个事务可以看到这个事务未提交的数据。</li><li>read commited：保证一个事物提交后才能被另外一个事务读取。另外一个事务不能读取该事物未提交的数据。</li><li>repeatable read：这种事务隔离级别可以防止脏读，不可重复读。但是可能会出现幻象读。它除了保证一个事务不能被另外一个事务读取未提交的数据之外还避免了以下情况产生（不可重复读）。</li><li>serializable：这是花费最高代价但最可靠的事务隔离级别。事务被处理为顺序执行。除了防止脏读，不可重复读之外，还避免了幻象读。</li></ul><hr><p><strong>Mybatis中的事务</strong></p><blockquote><p>通过sqlsession对象的commit方法和rollback方法实现事务的提交和回滚</p></blockquote><blockquote><p>将SqlSessionFactory.openSession()方法给传一个true，即为SqlSessionFactory.openSession(true)就可以实现自动提交，不需要每次都手动提交了。该方法一般用于单表操作。多表操作一般用手动提交防止误操作</p></blockquote><hr><h2 id="Mybatis基于XML配置的动态SQL语句使用"><a href="#Mybatis基于XML配置的动态SQL语句使用" class="headerlink" title="Mybatis基于XML配置的动态SQL语句使用"></a>Mybatis基于XML配置的动态SQL语句使用</h2><h3 id="常用标签"><a href="#常用标签" class="headerlink" title="常用标签"></a>常用标签</h3><blockquote><p>&lt;if&gt;，&lt;where&gt;，&lt;forerch&gt;，&lt;sql&gt;</p></blockquote><h4 id="lt-if-gt"><a href="#lt-if-gt" class="headerlink" title="&lt;if&gt;"></a><strong>&lt;if&gt;</strong></h4><blockquote><p>写在&lt;select&gt;标签的sql语句里用作判断</p></blockquote><pre><code>&lt;select id=&quot;getAll&quot; resulType=&quot;src.main.java.user&quot; parameterType=&quot;src.main.java.user&quot;&gt;    Select * from user where 1=1    &lt;if test=&quot;name!=null&quot;&gt;        name=#{name}    &lt;/if&gt;&lt;/select&gt;</code></pre><p>说明：如果名字不等于空，则查询条件为1=1并且名字等于输入的名字</p><hr><h4 id="lt-where-gt"><a href="#lt-where-gt" class="headerlink" title="&lt;where&gt;"></a><strong>&lt;where&gt;</strong></h4><blockquote><p>写在&lt;select&gt;标签的sql语句里用作判断。如果有多个if需要加入可以使用where</p></blockquote><pre><code>&lt;select id=&quot;getAll&quot; resulType=&quot;src.main.java.user&quot; parameterType=&quot;src.main.java.user&quot;&gt;    Select * from user    &lt;where&gt;        &lt;if test=&quot;name!=null&quot;&gt;            name=#{name}        &lt;/if&gt;        &lt;if test=&quot;sex!=null&quot;&gt;            sex=#{sex}        &lt;/if&gt;    &lt;/where&gt;&lt;/select&gt;</code></pre><p>说明：如果名称不为空就将名称作为查询条件，如果性别不为空就将性别作为查询条件。如果两个都不为空就将两个都作为查询条件。多个条件之间用and进行拼接</p><hr><h4 id="lt-forerch-gt"><a href="#lt-forerch-gt" class="headerlink" title="&lt;forerch&gt;"></a><strong>&lt;forerch&gt;</strong></h4><blockquote><p>多用于子查询(in)</p></blockquote><pre><code>//实现Sql语句：select * from user where id in(1,2,3,4,5)select * from user&lt;where&gt;    &lt;if test=&quot;list!=null and list.size()&gt;0&quot;&gt;    //为了防止list集合为空的情况发生        &lt;foreach collection=&quot;lsit/需要遍历的集合&quot; open=&quot;and id in(/where条件的前半部分，表示循环后的内容都添加到这个后面&quot; close=&quot;)/表示where条件的结尾，所有循环结束之后添加的内容 &quot; item=&quot;id/遍历出来的内容临时存放地方&quot; separator=&quot;,/循环添加的内容直接用什么分隔&quot;&gt;            #{id/遍历出来的内容,item起的名字}        &lt;/foreach&gt;    &lt;/if&gt;&lt;/where&gt;</code></pre><blockquote><p>若传入的是list集合，collection的值为list；若传入的是数组，collection的值为array；若传入的是多参数，则需要封装为一个Map进行处理</p></blockquote><hr><h4 id="lt-sql-gt"><a href="#lt-sql-gt" class="headerlink" title="&lt;sql&gt;"></a><strong>&lt;sql&gt;</strong></h4><blockquote><p>当有多个查询的方法时，会写很多次select * from user。他们的区别一般都是where条件不同。这时候可以使用sql标签将重复的语句抽象出来</p></blockquote><pre><code>&lt;sql id=&quot;selectAll&quot;&gt;    Select * from user&lt;/sql&gt;</code></pre><blockquote><p>使用时：&lt;include refid=”selectAll”&gt;&lt;/include&gt;</p></blockquote><hr><h2 id="Mybatis中的多表操作"><a href="#Mybatis中的多表操作" class="headerlink" title="Mybatis中的多表操作"></a>Mybatis中的多表操作</h2><blockquote><p>创建一对多，一对一的实体类时需要的步骤</p></blockquote><ol><li>让有主外键关系的用户表和账户表分别创建实体类<ul><li>让用户和账户的实体类能体现一对多的关系(在用户实体类中创建List的泛型账户实体类) (在账户类中创建一个用户类的属性)</li></ul></li><li>建立两个配置文件<ul><li>用户的配置文件</li><li>账户的配置文件</li></ul></li><li>实现配置<ul><li>当查询用户时能获取多个属于该用户的账户</li><li>当查询账户时能获取属于这个账户的全部用户信息</li></ul></li></ol><p>注意：所有实体类都需要无参构造器，否则报错：Error querying database. Cause: org.apache.ibatis.executor.ExecutorException: No constructor found in 实体类名</p><h3 id="一对多"><a href="#一对多" class="headerlink" title="一对多"></a>一对多</h3><blockquote><p>在实体类的配置文件的标签&lt;mapper&gt;里加入&lt;resultMap&gt;</p></blockquote><pre><code>&lt;resultMap id=&quot;&quot; type=&quot;&quot;&gt;    //将用户实体类里的与数据库列名对应的属性填进去    &lt;id property=&quot;实体类名&quot; column=&quot;数据库列名&quot;&gt;&lt;/id&gt;    &lt;result property=&quot;实体类名&quot; column=&quot;数据库列名&quot;&gt;&lt;/result&gt;    //将用户表对应的账户表信息封装到用户实体类的账户集合里面去    &lt;collection property=&quot;用户表里的账户实体类属性名&quot; ofType=&quot;list的泛型类型/账户实体类名&quot;&gt;        //将账户实体类里的与数据库列名对应的属性填进去        &lt;id property=&quot;实体类名&quot; column=&quot;数据库列名&quot;&gt;&lt;/id&gt;        &lt;result property=&quot;实体类名&quot; column=&quot;数据库列名&quot;&gt;&lt;/result&gt;    &lt;/collection&gt;&lt;resultMap&gt;</code></pre><h3 id="一对一"><a href="#一对一" class="headerlink" title="一对一"></a>一对一</h3><blockquote><p>在实体类的配置文件的标签&lt;mapper&gt;里加入&lt;resultMap&gt;</p></blockquote><pre><code>&lt;resultMap id=&quot;&quot; type=&quot;&quot;&gt;    //将账户实体类里的与数据库列名对应的属性填进去    &lt;id property=&quot;实体类名&quot; column=&quot;数据库列名&quot;&gt;&lt;/id&gt;    &lt;result property=&quot;实体类名&quot; column=&quot;数据库列名&quot;&gt;&lt;/result&gt;    //将账户表对应的用户表信息封装到账户实体类的用户实体类属性里    &lt;association property=&quot;账户表里的用户实体类属性名&quot; column=&quot;数据库对应的列名/起的别名&quot; javaType=&quot;用户实体类的全地址&quot;&gt;        //将用户实体类里的与数据库列名对应的属性填进去        &lt;id property=&quot;实体类名&quot; column=&quot;数据库列名&quot;&gt;&lt;/id&gt;        &lt;result property=&quot;实体类名&quot; column=&quot;数据库列名&quot;&gt;&lt;/result&gt;    &lt;/association&gt;&lt;resultMap&gt;</code></pre><h3 id="多对多"><a href="#多对多" class="headerlink" title="多对多"></a>多对多</h3><blockquote><p>多对多数据表的创建</p></blockquote><p>示例：一个角色可以有多个身份。一个身份可以是多个角色的</p><blockquote><p>创建多对多实体类的步骤</p></blockquote><ol><li>创建两个多对多关系的表。需要使用中间表。中间表包含各自的主键，在中间表中是外键</li><li>让两个实体类各自包含对方的一个集合引用</li><li>实体类的配置文件</li><li>查询用户时能获得用户的角色信息，查询角色信息时能获得用户信息</li></ol><p><strong>什么表是多对多？</strong></p><blockquote><p>当一个表除主键以外有多个相同数据的列，只有一个列和这个列相关的数据不同。那么可以将这个列和相关的列单独做一个表，然后创一个中间表作为连接。这样就是多对多的关系</p></blockquote><center><font size="2">用户表</font><table><thead><tr><th align="center">id</th><th align="center">姓名</th><th align="center">性别</th><th align="center">年龄</th><th align="center">角色</th><th align="center">角色说明</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">张三</td><td align="center">男</td><td align="center">18</td><td align="center">学生</td><td align="center">学习</td></tr><tr><td align="center">2</td><td align="center">李四</td><td align="center">男</td><td align="center">20</td><td align="center">学生</td><td align="center">学习</td></tr><tr><td align="center">3</td><td align="center">王五</td><td align="center">男</td><td align="center">22</td><td align="center">学生</td><td align="center">学习</td></tr><tr><td align="center">4</td><td align="center">马六</td><td align="center">男</td><td align="center">24</td><td align="center">学生</td><td align="center">学习</td></tr><tr><td align="center">5</td><td align="center">马六</td><td align="center">男</td><td align="center">24</td><td align="center">子女</td><td align="center">服从父母</td></tr><tr><td align="center"></td></tr></tbody></table></center><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><blockquote><p>这时候马六除了角色这一列还有和角色相关的列之外其他的数据都相同。这个时候可以将角色和角色说明单独作为一个表，然后建立一个中间表形成多对多的关系</p></blockquote><center><table><thead><tr><th align="center">id</th><th align="center">姓名</th><th align="center">性别</th><th align="center">年龄</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">张三</td><td align="center">男</td><td align="center">18</td></tr><tr><td align="center">2</td><td align="center">李四</td><td align="center">男</td><td align="center">20</td></tr><tr><td align="center">3</td><td align="center">王五</td><td align="center">男</td><td align="center">22</td></tr><tr><td align="center">4</td><td align="center">马六</td><td align="center">男</td><td align="center">24</td></tr><tr><td align="center">5</td><td align="center">马六</td><td align="center">男</td><td align="center">24</td></tr></tbody></table><p><font size="2">学生表</font></p></center><p></p><center><table><thead><tr><th align="center">id</th><th align="center">角色</th><th align="center">角色说明</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">学生</td><td align="center">上学</td></tr><tr><td align="center">2</td><td align="center">子女</td><td align="center">服从父母</td></tr></tbody></table><p><font size="2">角色表</font></p></center><p></p><center><table><thead><tr><th align="center">学生id</th><th align="center">角色id</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">1</td></tr><tr><td align="center">2</td><td align="center">1</td></tr><tr><td align="center">3</td><td align="center">1</td></tr><tr><td align="center">4</td><td align="center">1</td></tr><tr><td align="center">5</td><td align="center">1</td></tr><tr><td align="center">6</td><td align="center">2</td></tr></tbody></table><p><font size="2">中间表</font></p></center><br>这就是表的多对多关系。中间表需要将两个表的主键作为外键<p></p><blockquote><p>在实体类的配置文件的标签&lt;mapper&gt;里加入&lt;resultMap&gt;</p></blockquote><blockquote><p>创建实体类需要满足：查询用户时能获得用户的角色信息，查询角色信息时能获得用户信息（List泛型可解决问题）</p></blockquote><pre><code>&lt;resultMap id=&quot;&quot; type=&quot;&quot;&gt;    //将用户实体类里的与数据库列名对应的属性填进去    &lt;id property=&quot;实体类名&quot; column=&quot;数据库列名&quot;&gt;&lt;/id&gt;    &lt;result property=&quot;实体类名&quot; column=&quot;数据库列名&quot;&gt;&lt;/result&gt;    //将用户表对应的角色表信息封装到用户实体类的角色集合里面去    &lt;collection property=&quot;用户表里的角色实体类属性名&quot; ofType=&quot;list的泛型类型/角色实体类名&quot;&gt;        //将角色实体类里的与数据库列名对应的属性填进去        &lt;id property=&quot;实体类名&quot; column=&quot;数据库列名&quot;&gt;&lt;/id&gt;        &lt;result property=&quot;实体类名&quot; column=&quot;数据库列名&quot;&gt;&lt;/result&gt;    &lt;/collection&gt;&lt;resultMap&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 入门 </tag>
            
            <tag> Mybatis </tag>
            
            <tag> 框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis框架(一)</title>
      <link href="/2020/01/15/mybatis-kuang-jia-yi/"/>
      <url>/2020/01/15/mybatis-kuang-jia-yi/</url>
      
        <content type="html"><![CDATA[<h1 id="Mybatis的概述"><a href="#Mybatis的概述" class="headerlink" title="Mybatis的概述"></a>Mybatis的概述</h1><blockquote><p>Mybatis是由Java编写的一个持久层（Dao）框架。他封装了很多jdbc的操作细节（加载驱动，创建连接…），使开发者只需要关注sql语句。同时，它使用了ORM思想实现了结果集的封装。</p></blockquote><h2 id="什么是框架"><a href="#什么是框架" class="headerlink" title="什么是框架"></a>什么是框架</h2><blockquote><p>他是我们软件开发中的一套解决方案。不同的框架决绝不同的问题</p></blockquote><h2 id="什么是ORM"><a href="#什么是ORM" class="headerlink" title="什么是ORM"></a>什么是ORM</h2><blockquote><p>Object Relational Mappging ：对象关系映射。把数据库表和实体类的属性一一对应，让我们可以操作实体类就实现操作数据库表</p></blockquote><div align="center"><img src="/2020/01/15/mybatis-kuang-jia-yi/../img/44824/orm.jpg" width="300px" height="300px"></div><h2 id="为什么使用框架？-使用框架的好处"><a href="#为什么使用框架？-使用框架的好处" class="headerlink" title="为什么使用框架？/使用框架的好处"></a>为什么使用框架？/使用框架的好处</h2><blockquote><p>封装了很多的细节，使开发者可以使用极简的方法实现功能。大大提高开发效率</p></blockquote><hr><h2 id="使用Mybatis的准备"><a href="#使用Mybatis的准备" class="headerlink" title="使用Mybatis的准备"></a><strong>使用Mybatis的准备</strong></h2><h3 id="Mybatis环境搭建"><a href="#Mybatis环境搭建" class="headerlink" title="Mybatis环境搭建"></a>Mybatis环境搭建</h3><ul><li>创建Web项目<blockquote><p>右键空白处创建新项目——选择Maven——勾选Create a simple project(skip archetype selection)——输入Group(项目路径 如cn.Mybatis)，Artfact id（项目名称）——Finish</p></blockquote></li><li>加载jar包<blockquote><p>打开pom.xml——添加&lt;packaging]&gt;jar&lt;packaging&gt;（打包方式：jar）——添加&lt;dependencies&gt;标签。在&lt;dependencies&gt;标签内加入下列代码</p></blockquote></li></ul><pre><code>//加载Mybatis的jar包&lt;dependency&gt;    &lt;groupId&gt;org.mybatis&lt;/groupId&gt;    &lt;artifactId&gt;mybatis&lt;/artifactId&gt;    &lt;version&gt;3.4.5&lt;/version&gt;&lt;/dependency&gt;//加载数据库的jar包&lt;dependency&gt;    &lt;groupId&gt;mysql&lt;/groupId&gt;    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;    &lt;version&gt;5.1.6&lt;/version&gt;&lt;/dependency&gt;//加载日志的jar包&lt;dependency&gt;    &lt;groupId&gt;log4j&lt;/groupId&gt;    &lt;artifactId&gt;log4j&lt;/artifactId&gt;    &lt;version&gt;1.2.12&lt;/version&gt;&lt;/dependency&gt;//单元测试的jar包&lt;dependency&gt;    &lt;groupId&gt;junit&lt;/groupId&gt;    &lt;artifactId&gt;junit&lt;/artifactId&gt;    &lt;version&gt;4.10&lt;/version&gt;&lt;/dependency&gt;</code></pre><p>配置完后稍等，左侧菜单可能会报错。等待程序自己加载jar包</p><h3 id="创建实体类和Dao接口"><a href="#创建实体类和Dao接口" class="headerlink" title="创建实体类和Dao接口"></a>创建实体类和Dao接口</h3><blockquote><p>在项目路径src/main/java/里创建Dao。在创建实体类时注意实现Serializable接口。导入io的包</p></blockquote><h3 id="创建Mybatis主配置文件SqlMapConfig-xml"><a href="#创建Mybatis主配置文件SqlMapConfig-xml" class="headerlink" title="创建Mybatis主配置文件SqlMapConfig.xml"></a>创建Mybatis主配置文件SqlMapConfig.xml</h3><blockquote><p>在项目路径scr/main/resources/里创建SqlMapConfig.xml文件。并写入约束（可去官网查找复制）：</p></blockquote><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration  PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;  &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt;  &lt;environments default=&quot;mysql&quot;&gt;    &lt;environment id=&quot;mysql&quot;&gt;      &lt;transactionManager type=&quot;JDBC&quot;/&gt;      &lt;dataSource type=&quot;POOLED&quot;&gt;        &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;        &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/chatbbs&quot;/&gt;        &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;        &lt;property name=&quot;password&quot; value=&quot;root&quot;/&gt;      &lt;/dataSource&gt;    &lt;/environment&gt;  &lt;/environments&gt;  &lt;mappers&gt;    &lt;mapper resource=&quot;Mybatis/test1/Dao/bbsuserDao.xml&quot;/&gt;  &lt;/mappers&gt;&lt;/configuration&gt;</code></pre><hr><h2 id="准备Dao的配置文件"><a href="#准备Dao的配置文件" class="headerlink" title="准备Dao的配置文件"></a>准备Dao的配置文件</h2><h3 id="创建Dao的映射配置文件xml"><a href="#创建Dao的映射配置文件xml" class="headerlink" title="创建Dao的映射配置文件xml"></a>创建Dao的映射配置文件xml</h3><blockquote><p>在项目路径Dao接口下创建和Dao接口一样的映射配置文件Dao.xml。并写入约束：</p></blockquote><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;Mybatis.test1.Dao.bbsuserDao&quot;&gt;    &lt;!-- 执行的sql语句 --&gt;    &lt;select id=&quot;getAll&quot; resultType=&quot;用来接收的对象全路径名&quot;&gt;        select * from bbsuser    &lt;/select&gt;&lt;/mapper&gt;</code></pre><p>环境搭建的注意事项：</p><ol><li>创建userDao.xml和userDao.java时名称是为了和之前学习时保持一致。在Mybatis中把持久层的操作接口文件和映射也叫做：Mapper。所以userDao和userMapper是一样的</li><li>映射配置文件的mapper标签namespace属性的取值必须是dao的全限定类名（cn.jbit.dao.userDao）</li><li>映射配置文件的操作配置(select标签)，id的属性取值必须是dao接口的方法名</li></ol><hr><h2 id="使用Mybatis"><a href="#使用Mybatis" class="headerlink" title="使用Mybatis"></a>使用Mybatis</h2><blockquote><p>在指定路径src/test/java下创建运行文件</p></blockquote><pre><code>//1.读取配置文件InputStream in = Resources.getResourceAsStream(&quot;SqlMapConfig.xml&quot;);//2.创建SqlSessionFactory工厂SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(in);//3.使用工厂生产一个SqlSession对象SqlSession session = factory.openSession();//4.使用SqlSession创建Dao接口的代理对象bbsuserDao BbsuserDao = session.getMapper(bbsuserDao.class);//5.使用代理对象执行方法List&lt;bbsuser&gt; list = BbsuserDao.getAll();for(bbsuser user : list){    System.out.println(user);}//6.释放资源session.close();in.close();</code></pre><p>注意事项：</p><ol><li>做项目时2-4都可省略，只留下InputStream in = Resources.getResourceAsStream(“SqlMapConfig.xml”).getMapper(bbsuserDao.class);</li></ol><hr><h2 id="进行数据库操作"><a href="#进行数据库操作" class="headerlink" title="进行数据库操作"></a>进行数据库操作</h2><blockquote><p>当语句需要赋值的时候使用#{name}来将parameterType引用的对象属性给赋进去，例如：<br><insert id="addUser" parametertype="src/main/java/entiy/user" resulttype="Integer"><br>insert into bbsuser values(#{id},#{name},#{password})<br><insert></insert></insert></p></blockquote><ul><li>传递参数用#{属性名}进行传递。如果是自动生成的set,get输入属性名就行，手写的set，get则需要输入set后面的方法名</li><li>1增删改数据最后需要手动提交事务sqlSession.commit();</li></ul><h3 id="增加"><a href="#增加" class="headerlink" title="增加"></a>增加</h3><pre><code>&lt;insert id=&quot;方法名&quot; parameterType=&quot;用来赋值的对象路径名&quot; resultType=&quot;用来接收的对象全路径名&quot;&gt;    Sql语句&lt;insert&gt;</code></pre><ul><li>如果结果要返回int则需要加上resultType=”integer”</li></ul><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><pre><code>&lt;delete id=&quot;方法名&quot; parameterType=&quot;Integer&quot;&gt;    Sql语句&lt;/update&gt;</code></pre><p>如果只有一个参数时，调用对象的占位符名称可以随便写，例如：#{a}或者写成#{abc}都可以</p><h3 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h3><pre><code>&lt;update id=&quot;方法名&quot; parameterType=&quot;用来赋值的对象全路径名&quot;&gt;    Sql语句&lt;/update&gt;</code></pre><h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><hr><h4 id="查询所有"><a href="#查询所有" class="headerlink" title="查询所有"></a>查询所有</h4><pre><code>&lt;select id=&quot;方法名&quot; resultType=&quot;用来接收的对象全路径名&quot;&gt;    select * from bbsuser&lt;/select&gt;</code></pre><p>如果有where条件可以加入属性:parameterType</p><h4 id="模糊查询"><a href="#模糊查询" class="headerlink" title="模糊查询"></a>模糊查询</h4><pre><code>&lt;select id=&quot;方法名&quot;  parameterType=&quot;用来赋值的对象路径名&quot; resultType=&quot;用来接收的对象全路径名&quot;&gt;    select * from bbsuser where name like #{name}&lt;/select&gt;</code></pre><ul><li>如果没有参数传递可以不用加parameterType标签</li><li>如果使用模糊查询则需要在传递参数的时候给参数加上对应的%，例如需要模糊查询姓张的学生则需要传入参数：张%</li><li>模糊查询还可以写成name like ‘%${value}%’，这样就不用再传参数的时候给参数加%了</li><li>参数加符号的方法是用的preparedStatement的占位符。而${value}用的是Statement用的是字符串的拼接，第一种因为是预处理，所以效率更高。而第二张则可能会被sql注入。所以大多使用第一种方法</li></ul><hr><h2 id="使用注解完成数据库操作"><a href="#使用注解完成数据库操作" class="headerlink" title="使用注解完成数据库操作"></a>使用注解完成数据库操作</h2><ul><li>在方法上面直接写@Select(sql语句)就可以不用配置Dao.xml直接使用。如果使用注解，SqlMapConfig.xml文件里的&lt;mapper resource=”Dao.xml路径”/&gt;就需要改成&lt;mapper class=”Dao.Java路径”/&gt;。如果使用xml文件，路径之间用”/“分隔如果使用注解，路径之间用”.”分隔</li><li>在方法上面使用@Before  表示在方法执行之前先调用该方法,只有执行@Test注解时才会调用</li><li>在方法上面使用@After  表示在方法执行之后调用该方法,只有执行@Test注解时才会调用</li><li>在方法上面使用@Test  表示执行该方法</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 入门 </tag>
            
            <tag> Mybatis </tag>
            
            <tag> 框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ajax交互拓展</title>
      <link href="/2020/01/11/ajax-jiao-hu-tuo-zhan/"/>
      <url>/2020/01/11/ajax-jiao-hu-tuo-zhan/</url>
      
        <content type="html"><![CDATA[<h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a><strong>说明</strong></h1><blockquote><p>由于通过原生JavaScript实现Ajax并处理响应相对比较复杂，还要考虑浏览器兼容性等一系列问题。JQuery中将Ajax相关的操作都进行了封装，提供了$.get()等方以简化Ajax开发。</p></blockquote><a id="more"></a><h2 id="get"><a href="#get" class="headerlink" title="$.get()"></a>$.get()</h2><pre><code>$.get(url[,data][,success][,dataType]) //语法</code></pre><center><font size="2">$.get()可选参数</font></center><table><thead><tr><th align="center">参数</th><th align="center">类型</th><th align="left"><center>说明</center></th></tr></thead><tbody><tr><td align="center">url</td><td align="center">String</td><td align="left"><font size="4" color="red"><strong>必选</strong></font>，规定请求发送到说明地方</td></tr><tr><td align="center">data</td><td align="center">PlainObject或String</td><td align="left"><font size="4" color="red"><strong>可选</strong></font>，回调函数。发送到服务器的数据</td></tr><tr><td align="center">success</td><td align="center">Function name(PlainObject data,String textStatus,jqXHR jqxhr){}</td><td align="left"><font size="4" color="red"><strong>可选</strong></font>，<em>请求成功后调用的参数</em><br><strong>Data</strong>：<font size="4" color="red"><strong>可选</strong></font>，<em>服务器返回的结果数据<br><strong>TextStatus</strong>：<font size="4" color="red"><strong>可选</strong></font>。描述请求状态的字符串</em><br><strong>jqxhr</strong>：<font size="4" color="red"><strong>可选</strong></font>，<em>jqXHR是XMLHttpReauest的超集如果指定了dataType参数则必须提供此参数。如果没有试镜需要处理，可以使用null或jQuery.noop()空方法做占位符</em></td></tr><tr><td align="center">dataType</td><td align="center">String</td><td align="left"><font size="4" color="red"><strong>可选</strong></font>，<em>预计服务器返回数据类型，可用类型有：</em> <strong>XML</strong>，<strong>HTML</strong>，<strong>SCRIPT</strong>，<strong>JSON</strong>，<strong>JSONS</strong>，<strong>Text</strong></td></tr></tbody></table><blockquote><blockquote><p>例：使用get方法将name为张三的信息传递到Serverlet里去并接受返回Text类型的数据</p></blockquote></blockquote><pre><code>$.get(“ServerletUrl”,”name=张三”,function name(data){},”Text”)</code></pre><hr><h2 id="post"><a href="#post" class="headerlink" title="$.post()"></a><strong>$.post()</strong></h2><pre><code>$.post(url[,data][,success][,dataType])    //语法</code></pre><center><font size="2">$.post()可选参数</font></center><table><thead><tr><th align="center">参数</th><th align="center">类型</th><th align="left"><center>说明</center></th></tr></thead><tbody><tr><td align="center">url</td><td align="center">String</td><td align="left"><font size="4" color="red"><strong>必选</strong></font>，规定请求发送到说明地方</td></tr><tr><td align="center">data</td><td align="center">PlainObject或String</td><td align="left"><font size="4" color="red"><strong>可选</strong></font>，回调函数。发送到服务器的数据</td></tr><tr><td align="center">success</td><td align="center">Function name(PlainObject data,String textStatus,jqXHR jqxhr){}</td><td align="left"><font size="4" color="red"><strong>可选</strong></font>，<em>请求成功后调用的参数</em><br><strong>Data</strong>：<font size="4" color="red"><strong>可选</strong></font>，<em>服务器返回的结果数据<br><strong>TextStatus</strong>：<font size="4" color="red"><strong>可选</strong></font>。描述请求状态的字符串</em><br><strong>jqxhr</strong>：<font size="4" color="red"><strong>可选</strong></font>，<em>jqXHR是XMLHttpReauest的超集如果指定了dataType参数则必须提供此参数。如果没有试镜需要处理，可以使用null或jQuery.noop()空方法做占位符</em></td></tr><tr><td align="center">dataType</td><td align="center">String</td><td align="left"><font size="4" color="red"><strong>可选</strong></font>，<em>预计服务器返回数据类型，可用类型有：</em> <strong>XML</strong>，<strong>HTML</strong>，<strong>SCRIPT</strong>，<strong>JSON</strong>，<strong>JSONS</strong>，<strong>Text</strong></td></tr></tbody></table><blockquote><blockquote><p>例：使用post方法将name为张三的信息传递到Serverlet里去并接受返回Text类型的数据</p></blockquote></blockquote><pre><code>$.post(“ServerletUrl”,”name=张三”,function name(data){},”Text”)</code></pre><hr><h2 id="getJSON"><a href="#getJSON" class="headerlink" title="$.getJSON()"></a><strong>$.getJSON()</strong></h2><blockquote><p>由于经常使用JSON格式作为相应内容的载体，为了简化方法调用。Jquery提供了$.getJSON()方法，需要注意的是getJSON的提交方式默认是get，也只能是get</p></blockquote><pre><code>$.getJSON(url[,data][,success]) //语法</code></pre><center><font size="2">$.getJSON()可选参数</font></center><table><thead><tr><th align="center">参数</th><th align="center">类型</th><th align="left"><center>说明</center></th></tr></thead><tbody><tr><td align="center">url</td><td align="center">String</td><td align="left"><font size="4" color="red"><strong>必选</strong></font>，规定请求发送到说明地方</td></tr><tr><td align="center">data</td><td align="center">PlainObject或String</td><td align="left"><font size="4" color="red"><strong>可选</strong></font>，回调函数。发送到服务器的数据</td></tr><tr><td align="center">success</td><td align="center">Function name(PlainObject data,String textStatus,jqXHR jqxhr){}</td><td align="left"><font size="4" color="red"><strong>可选</strong></font>，<em>请求成功后调用的参数</em><br><strong>Data</strong>：<font size="4" color="red"><strong>可选</strong></font>，<em>服务器返回的结果数据<br><strong>TextStatus</strong>：<font size="4" color="red"><strong>可选</strong></font>。描述请求状态的字符串</em><br><strong>jqxhr</strong>：<font size="4" color="red"><strong>可选</strong></font>，<em>jqXHR是XMLHttpReauest的超集如果指定了dataType参数则必须提供此参数。如果没有试镜需要处理，可以使用null或jQuery.noop()空方法做占位符</em></td></tr></tbody></table><blockquote><blockquote><p>例：将name为张三的信息传递到Serverlet里去并默认用JSON格式接受数据</p></blockquote></blockquote><pre><code>$.getJSON(“ServerletUrl”,”name=张三”,function name(data){})</code></pre><hr><h2 id="在ajax中直接返回HTML内容"><a href="#在ajax中直接返回HTML内容" class="headerlink" title="在ajax中直接返回HTML内容"></a><strong>在ajax中直接返回HTML内容</strong></h2><blockquote><p>从Serverlet获取的结果在JSP页面显示出来会增加很多代码量，使用该方法可以在Serverlet页面将结果转换成Html标签，然后直接在节点上显示出来</p></blockquote><pre><code>$(selectedor).load(url[,data][,complete])   //语法 </code></pre><center><font size="2">$.getJSON()可选参数</font></center><table><thead><tr><th align="center">参数</th><th align="center">类型</th><th align="left"><center>说明</center></th></tr></thead><tbody><tr><td align="center">url</td><td align="center">String</td><td align="left"><font size="4" color="red"><strong>必选</strong></font>，规定请求发送到说明地方</td></tr><tr><td align="center">data</td><td align="center">PlainObject或String</td><td align="left"><font size="4" color="red"><strong>可选</strong></font>，回调函数。发送到服务器的数据</td></tr><tr><td align="center">complete</td><td align="center">Function name(PlainObject data,String textStatus,jqXHR jqxhr){}</td><td align="left"><font size="4" color="red"><strong>可选</strong></font>，<em>请求成功后调用的参数</em><br><strong>Data</strong>：<font size="4" color="red"><strong>可选</strong></font>，<em>服务器返回的结果数据</em><br><strong>TextStatus</strong>：<font size="4" color="red"><strong>可选</strong></font>,<em>描述请求状态的字符串</em><br><strong>jqxhr</strong>：<font size="4" color="red"><strong>可选</strong></font>，<em>jqXHR是XMLHttpReauest的超集。</em></td></tr></tbody></table><blockquote><p>该方法直接将返回的HTML类型的内容直接添加到指定的元素中。该方法默认使用get方法发送请求。除非提供的data是一个对象则使用post方式发送请求</p></blockquote><hr><h2 id="使用jQuery解析表单数据"><a href="#使用jQuery解析表单数据" class="headerlink" title="使用jQuery解析表单数据"></a><strong>使用jQuery解析表单数据</strong></h2><blockquote><p>serializeArray()</p></blockquote><p>该方法会将一组表单元素中检测有效控件，将其序列化为name和value两个属性构成的JSON对象数组。该方法的规则是：</p><ol><li>元素不能被禁用</li><li>元素必须有name属性</li><li>选中的checkbox才是有效的</li><li>选中的radio才是有效的</li><li>只有出发提交时间的submit按钮才是有效的</li><li>File元素不会被序列化</li></ol><p>使用时最后一步需要将其转化成请求<font color="red">字符串</font><br><br>该方法是将数据转为<em>JSON<em>格式 *</em>[{“name”:”张三”,”age”:”18”},{“name”:”李四”,”age”:”20”}]**。<br>如果需要把内容变成name=张三&amp;age=李四这种格式的字符串则需要用</em>$.param()*方法将其转换</p><hr><h2 id="使用FastJSON生成JSON字符串"><a href="#使用FastJSON生成JSON字符串" class="headerlink" title="使用FastJSON生成JSON字符串"></a><strong>使用FastJSON生成JSON字符串</strong></h2><blockquote><p>为什么要使用FastJSON？</p></blockquote><p>将多个对象转换成JSON格式传递给页面如果用手写会很复杂，如果使用FastJSON则能节约代码</p><blockquote><p>怎么使用FastJSON？</p></blockquote><p>在<a href="https://github.com/alibaba/fastjson/releases" target="_blank" rel="noopener">官网</a>选择对应版本jar文件和源代码下载路径<br>由于FastJSON方法大多是static修饰的，所以可以直接通过类名.方法使用。入口类com.alibaba.fastjson.JSON</p><center><font size="2">常用方法</font></center><table><thead><tr><th align="center">方法</th><th align="left"><center>说明</center></th></tr></thead><tbody><tr><td align="center">Public static String toJSONString(Object object)</td><td align="left">将java对象转换成JSON字符串，不能转换日期格式的属性，会报错</td></tr><tr><td align="center">Public static String toJSONString(Object object,boolean fprettyFormat)</td><td align="left">fprettyFormat为true时产生带格式的JSON字符串，为false与toJSONString(Object object)相同</td></tr><tr><td align="center">Public static String toJSONString(Object oject,SerializeFeatrue…featrue)</td><td align="left">可以通过featrue参数指定更多序列化规则</td></tr><tr><td align="center">Public static String toJSONStringWithDateFormat(Object object,String DateFormat,SerialiFeatrue…featrue)</td><td align="left">可以通过dateFormat参数指定日期类型的输入格式。<br>可以转换时间类型    (yyyy-MM-dd HH:mm:ss/年月日时分秒)</td></tr></tbody></table><p><font size="5">SerializeFeatrue定义了多种序列化属性，属性及说明如下</font></p><pre><code>QuoteFiedldNames    //输出JSON的字段名时使用双引号，默认引用WriteMapNullValue   //输出值为null的字段，默认不输出WriteNullListAsEmpty    //将值为null的list字段输出为[]WriteNullStringAsEmpty  //将值为null的String字段输出为””WriteNullNumberAsEmpty  //将值为null的数值字段输出为0WriteNullBooleanAsFalse //将值为null的Boolean字段输出为falseSkipTransienFiedld  //忽略transient字段，默认及忽略PrettyFormat    //格式化JSON字符串，默认不格式化</code></pre><blockquote><p>例：JSON.toJSONStringWithDateFormat(list,”yyyy-MM-dd HH:mm:ss”,WriteMapNullValue,WriteNullListAsEmpty,WriteNullListAsEmpty);</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ajax </tag>
            
            <tag> 入门 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ajax的基本运用</title>
      <link href="/2020/01/08/ajax-de-ji-ben-yun-yong/"/>
      <url>/2020/01/08/ajax-de-ji-ben-yun-yong/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h2 id="Ajax是什么"><a href="#Ajax是什么" class="headerlink" title="Ajax是什么"></a>Ajax是什么</h2><blockquote><p>Ajax是一种技术方案，但并不是一种新技术。它依赖现有的CSS/HTML/JavaScript，而其中最核心的依赖是浏览器提供的XMLHttpRequest对象，这个对象使得浏览器可以发出HTTP请求与接收HTTP响应。实现了在页面不刷新的情况下和服务器进行数据交互。</p></blockquote><h2 id="为什么要使用Ajax-Ajax的好处"><a href="#为什么要使用Ajax-Ajax的好处" class="headerlink" title="为什么要使用Ajax / Ajax的好处"></a>为什么要使用Ajax / Ajax的好处</h2><blockquote><p>在传统的web应用中，每次请求都生成新的页面，前一个请求没响应则后一个请求不能发送。Ajax就是为了弥补的不足而诞生的。使用Ajax可以进行局部刷新数据。</p></blockquote><h2 id="ajax的常用参数"><a href="#ajax的常用参数" class="headerlink" title="$.ajax的常用参数"></a>$.ajax的常用参数</h2><table><thead><tr><th align="center"><strong><center>参数</center></strong></th><th align="center"><strong><center>类型</center></strong></th><th align="left"><strong><center>说明</center></strong></th></tr></thead><tbody><tr><td align="center">url</td><td align="center">String</td><td align="left"><strong>发送请求的地址，默认为当前地址;</strong></td></tr><tr><td align="center">type</td><td align="center">String</td><td align="left"><strong>请求方式</strong>（<em>post/get;默认get</em>）<strong>，1.9.0后可用method替换</strong>;</td></tr><tr><td align="center">data</td><td align="center">PlainObject或String或Arra</td><td align="left"><strong>发送到服务器的数据</strong>;</td></tr><tr><td align="center">dataType</td><td align="center">String</td><td align="left"><strong>预期返回的数据类型，可用的有</strong> <em>XML，HTML，Scipt，JSON，JSONP，Text</em>;</td></tr><tr><td align="center">beforeSend</td><td align="center">function(jqXHR jqxhr,PlainObject settings){}</td><td align="left"><strong>发送请求前调用的函数，返回false将终止发送参数</strong>;<br><br><strong>jqxhr</strong>：<em>可选，是XMLHttpRequest的超集</em>;<br><br><strong>settings</strong>：<em>可选，当前ajax方法的settings对象</em>;</td></tr><tr><td align="center">success</td><td align="center">function(任意类型 result,String textStatus,jqXHR jqxhr){}</td><td align="left"><strong>请求成功后调用的参数参数</strong>;<br><br><strong>result</strong>：<em>可选，由服务器返回的数据</em>;<br><br><strong>textStatus</strong>：<em>可选，描述请求状态的字符串</em>;<br><br><strong>jqxhr</strong>：<em>可选</em>;</td></tr><tr><td align="center">error</td><td align="center">function(jqXHR jqxhr,String textStatus,String errorThrown){}</td><td align="left"><strong>请求失败时调用的函数参数</strong><br><br><strong>jqxhr</strong>：<em>可选</em><br><br><strong>textStatus</strong>：<em>可选，错误信息</em><br><br><em>errorThrown*<em>：</em>可选，文本描述的Http状态</em></td></tr><tr><td align="center">complete</td><td align="center">function(任意类型 result,String textStatus){}</td><td align="left"><strong>请求完成后调用的函数（请求成功或失败均调用）</strong>;<br><br> <strong>jqxhr</strong>：<em>可选</em>;<br><br><strong>textStatus</strong>：<em>可选，描述请求状态的字符串</em>;</td></tr><tr><td align="center">timeout</td><td align="center">Number</td><td align="left"><strong>设置请求超时时间</strong></td></tr><tr><td align="center">global</td><td align="center">Boolean</td><td align="left"><strong>默认为</strong> <em>true</em> <strong>，表示是否出触发全局Ajax事件</strong></td></tr></tbody></table><center><font size="2">$.ajax 常用参数</font></center><hr><h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><pre><code>$.ajax([settings])  //[settings]:配置项，均为键值对格式</code></pre><ul><li><h2 id="JSP页面"><a href="#JSP页面" class="headerlink" title="JSP页面"></a>JSP页面</h2></li></ul><pre><code>$.ajax({    &quot;url&quot;:&quot;Serverlet&quot;,                    //提交的url(Serverlet名字)路径    &quot;type&quot;:&quot;get/post&quot;,                    //提交方式(分为get和post)    &quot;data&quot;:&quot;name=&quot;+userName,            //传递参数    &quot;dataType&quot;:&quot;text&quot;,                    //返回类型(预计返回类型，有：XML，HTML，Scipt，JSON，JSONP，Text)    &quot;success&quot;:function(data){  },        //执行成功后运行方法    &quot;error&quot;:&quot;function(data){  }&quot;        //执行失败后运行方法})</code></pre><hr><ul><li><h2 id="Serverlet类"><a href="#Serverlet类" class="headerlink" title="Serverlet类"></a>Serverlet类</h2></li></ul><blockquote><p>注意：servlet类需要继承httpservlet，然后实现get和post方法。根据提交的方式不同，进入的方法也不相同</p></blockquote><pre><code>public void doPost(HttpServletRequest request,HttpServletResponse response){    response.setContentType(&quot;text/html;charset=UTF-8&quot;);    PrintWriter out = response.getWriter();    Out.print();    //将结果返回给JSP页面    Out.flush();    Out.close();}</code></pre><hr><h2 id="JSON格式的处理"><a href="#JSON格式的处理" class="headerlink" title="JSON格式的处理"></a>JSON格式的处理</h2><ul><li><strong><font size="2">当dataType为JSON时，处理JSON格式的相应数据</font></strong></li></ul><blockquote><p>JSON（JavaScript Object Notation）是一种轻量级的数据交互格式。JSON类似于实体类对象。通常用语服务器和客户端之间传递数据</p></blockquote><ul><li><p><strong>JSON定义</strong></p><ol><li><p>定义单个对象</p><pre><code> let user = {&quot;name&quot;:&quot;张三&quot;,&quot;age&quot;:&quot;18,:&quot;sex&quot;:&quot;男&quot;}</code></pre><p> 该JSON存储了一个user对象，拥有属性name，age，sex。并拥有默认值。键值对之间 用‘:’分隔。属性之间用‘,’分隔。</p></li><li><p>定义多个对象</p><pre><code> let user = [{&quot;name&quot;:&quot;张三&quot;,&quot;age&quot;:&quot;18,:&quot;sex&quot;:&quot;男&quot;},{&quot;name&quot;:&quot;李四&quot;,&quot;age&quot;:&quot;18,:&quot;sex&quot;:&quot;男&quot;]</code></pre><p> 该JSON存储了2个对象，都有属性name,age,sex，并给了默认值。存储多个对象式需要用[]进行包裹。对象与对象之间用‘，’分隔。</p></li></ol></li></ul>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ajax </tag>
            
            <tag> 入门 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JSTL和EL</title>
      <link href="/2019/12/30/jstl-he-el/"/>
      <url>/2019/12/30/jstl-he-el/</url>
      
        <content type="html"><![CDATA[<h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a><strong>说明</strong></h1><blockquote><p>从后端接收数据并显示出来时如果使用JAVA代码展示数据会让页面变得臃肿。而使用JSTL和EL可以实现无JAVA代码嵌入的JSP页面开发的同时提高可读性</p></blockquote><a id="more"></a><h2 id="EL表达式"><a href="#EL表达式" class="headerlink" title="EL表达式"></a>EL表达式</h2><h3 id="什么是EL表达式"><a href="#什么是EL表达式" class="headerlink" title="什么是EL表达式"></a><strong>什么是EL表达式</strong></h3><blockquote><p>全称是Expression Language。它是一种借鉴了JavaScript和XPath的表达式语言。它能够使开发人员更方便的访问上下文，而无需再JSP页面嵌入Java代码。从而使开发人员不必熟悉Java也能轻松编写JSP程序</p></blockquote><h3 id="EL表达式语法"><a href="#EL表达式语法" class="headerlink" title="EL表达式语法"></a><strong>EL表达式语法</strong></h3><pre><code>${EL 表达式}//语法</code></pre><h3 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a><strong>操作符</strong></h3><ul><li>“.”操作符<blockquote><p>  可以通过”.”来访问对象的属性，例如${user.name} 就是通过EL表达式获取user对象里面的私有属性name</p></blockquote></li><li>“[]”操作符</li></ul><blockquote><p>  可以通过[]来访问对象的属性，例如${user[“name”]} 与”.”不同的是就算属性名包含”.”或者”-“等特殊字符，[]也能访问</p></blockquote><blockquote><p>  []还可以访问数组的元素，例如${list[0]} </p></blockquote><blockquote><p>  []还可以实现动态访问，例如${user[name]} 这时，name是一个变量名，通过改变变量名就可以实现获取user里面不同的属性</p></blockquote><h4 id="关系操作符"><a href="#关系操作符" class="headerlink" title="关系操作符"></a><strong>关系操作符</strong></h4><center>在表达式里可以写关系操作符来获取结果</center><table><thead><tr><th align="center">关系操作符</th><th align="center">说明</th><th align="center">示例</th><th align="center">结果</th></tr></thead><tbody><tr><td align="center">==或eq</td><td align="center">等于</td><td align="center">${“name” == “name”}</td><td align="center">true</td></tr><tr><td align="center">!=或ne</td><td align="center">不等于</td><td align="center">${“name” != “name”}</td><td align="center">false</td></tr><tr><td align="center">&lt;或者lt</td><td align="center">小于</td><td align="center">${10 &lt; 20}</td><td align="center">false</td></tr><tr><td align="center">&gt;或gt</td><td align="center">大于</td><td align="center">${10 &gt; 20}</td><td align="center">false</td></tr><tr><td align="center">==或eq</td><td align="center">小于等于</td><td align="center">${10 &lt;= 10}</td><td align="center">true</td></tr><tr><td align="center">==或eq</td><td align="center">大于等于</td><td align="center">${10 &gt;=10}</td><td align="center">true</td></tr></tbody></table><h4 id="逻辑操作符"><a href="#逻辑操作符" class="headerlink" title="逻辑操作符"></a><strong>逻辑操作符</strong></h4><pre><code>|逻辑操作符|说明|示例|结果||:--:|:--:|:--:|:--:||&amp;&amp;或and|逻辑与|如果A为true B为false 例：${A &amp;&amp; B}|False||&amp;##124;&amp;##124;或or|逻辑或|如果A为true B为false 例：${A &amp;##124;&amp;##124; B}|True||!或not|逻辑非|如果A为true 例：${!A}|False|</code></pre><h4 id="Empty操作符"><a href="#Empty操作符" class="headerlink" title="Empty操作符"></a><strong>Empty操作符</strong></h4><blockquote><p>Empty是一个前缀操纵符，用于检测一个变量是否为null 或者为empty(如长度为0的字符串变量或集合变量) 例 变量a不存在， ${Empty a} 返回为true ${not Empty a}返回为false</p></blockquote><h3 id="EL表达式隐式对象"><a href="#EL表达式隐式对象" class="headerlink" title="EL表达式隐式对象"></a><strong>EL表达式隐式对象</strong></h3><blockquote><p>JSP提供了page、request、session、application、pageContext等若干隐式对象。EL隐式对象按照途径的不同分为作用域访问对象，参数访问对象和JSP隐式对象</p></blockquote><table><thead><tr><th align="center">对象名称</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">pageScope</td><td align="center">与页面作用域(page)中的属性关联的Map类</td></tr><tr><td align="center">requestScope</td><td align="center">与请求作用于(request)中的属性关联的Map类</td></tr><tr><td align="center">sessionScope</td><td align="center">与会话作用域(session)中的属性关联的Map类</td></tr><tr><td align="center">applicationScope</td><td align="center">与应用程序作用域(application)中的属性关联的Map类</td></tr></tbody></table><center>作用域访问对象</center><blockquote><p>当使用EL表达式访问变量时，应制定查找范围。如${requestScope.name} 即在作用域范围内查找name变量。如果不指定范围，如${name} 则会按照page-request-session-application的顺序进行查找变量name</p></blockquote><hr><h2 id="JSTL"><a href="#JSTL" class="headerlink" title="JSTL"></a><strong>JSTL</strong></h2><h3 id="什么是JSTL"><a href="#什么是JSTL" class="headerlink" title="什么是JSTL"></a><strong>什么是JSTL</strong></h3><blockquote><p>JSTL的全称是Java Server Pages Standard Tag Library。它包含了开发JSP页面时经常用到的一组标准标签，这些标签提供了一种不用嵌入Java代码就能开发复杂的JSP页面的途径</p></blockquote><h3 id="为什么使用JSTL"><a href="#为什么使用JSTL" class="headerlink" title="为什么使用JSTL"></a><strong>为什么使用JSTL</strong></h3><blockquote><p>由于EL表达式不能实现逻辑控制，遍历，循环等功能。如果在开发JSP页面时除了编写Java脚本，还能使用JSTL来实现这个功能</p></blockquote><h3 id="如何使用JSTL"><a href="#如何使用JSTL" class="headerlink" title="如何使用JSTL"></a><strong>如何使用JSTL</strong></h3><blockquote><ul><li>导入jstl.jar和standard.jar两个jar包</li><li>在创建Web项目时，勾选J2EE 如果选中更低的版本则需要勾选下面的 Add JSTL Libraries to WEB-INF/lib folder</li><li>3.在需要使用JSTL的页面使用taglib指令导入标签库描述符文件：&lt;%@ taglib url=”<a href="http://java.sun.com/jsp/jstl/core&quot;" target="_blank" rel="noopener">http://java.sun.com/jsp/jstl/core&quot;</a> prefix=”c”%&gt;</li></ul></blockquote><h3 id="JSTL核心标签库"><a href="#JSTL核心标签库" class="headerlink" title="JSTL核心标签库"></a><strong>JSTL核心标签库</strong></h3><p>除了设置的变量名，都可以用EL表达式</p><h4 id="通用标签库"><a href="#通用标签库" class="headerlink" title="通用标签库"></a>通用标签库</h4><blockquote><p>通用标签库用于在JSP页面设置，显示和删除变量。它包含三个标签：&lt;c:set&gt;，&lt;c:out&gt;，&lt;c:remove&gt;</p></blockquote><h5 id="lt-c-set-gt-标签"><a href="#lt-c-set-gt-标签" class="headerlink" title="&lt;c:set&gt;标签"></a>&lt;c:set&gt;标签</h5><ol><li><strong>将a存储到范围为request的变量b中</strong></li></ol><pre><code>&lt;c:set var=&quot;b&quot; value=&quot;a&quot; scope=&quot;request&quot;&gt;</code></pre><p>Var：变量名<br>Value：变量的值<br>Scope：变量的作用域，可替换为request，session，page，application</p><ol start="2"><li><strong>将a作为变量存储到对象c里</strong></li></ol><pre><code>&lt;c:set value=&quot;a&quot; target=&quot;c&quot; property=&quot;b&quot;&gt;</code></pre><p>Value：存储到对象里面的值<br>Property：存储到对象里的名称<br>Target：存储的对象名</p><hr><h5 id="lt-c-out-gt-标签"><a href="#lt-c-out-gt-标签" class="headerlink" title="&lt;c:out&gt;标签"></a>&lt;c:out&gt;标签</h5><blockquote><p>类似JSP中的&lt;%=%&gt;</p></blockquote><pre><code>&lt;c:out value=&quot;a&quot; default=&quot;b&quot;&gt;</code></pre><p>Value：输出的变量名<br>Default：value的值为空的时候输出的内容，该属性可以不写</p><hr><h5 id="lt-c-remove-gt-标签"><a href="#lt-c-remove-gt-标签" class="headerlink" title="&lt;c:remove&gt;标签"></a>&lt;c:remove&gt;标签</h5><pre><code>&lt;c:remover var=&quot;a&quot; scope=&quot;page&quot;&gt;</code></pre><p>Var：移除的变量名<br>Scope：移除的变量范围，默认为page。可选的范围有：page，request，session，application</p><hr><h4 id="条件标签库"><a href="#条件标签库" class="headerlink" title="条件标签库"></a>条件标签库</h4><blockquote><p>JSTL的条件标签包括&lt;c:if&gt;，&lt;c:choose&gt;，&lt;c:when&gt;，&lt;c:otherwise&gt;</p></blockquote><h5 id="lt-c-if-gt"><a href="#lt-c-if-gt" class="headerlink" title="&lt;c:if&gt;"></a>&lt;c:if&gt;</h5><pre><code>&lt;c:if test=&quot;${user.flag}&quot; var=&quot;a&quot; scope=&quot;request&quot;&gt;    内容&lt;/c:if&gt;</code></pre><p>Test：判断条件当结果为true时执行里面的内容<br>Var：定义变量，用来存储判断结果。可省略<br>Scope：指定var变量的存储范围，可省略。可选值有：page，request，session，application</p><hr><h5 id="lt-c-choose-gt-，-lt-c-when-gt-，-lt-c-otherwise-gt"><a href="#lt-c-choose-gt-，-lt-c-when-gt-，-lt-c-otherwise-gt" class="headerlink" title="&lt;c:choose&gt;，&lt;c:when&gt;，&lt;c:otherwise&gt;"></a>&lt;c:choose&gt;，&lt;c:when&gt;，&lt;c:otherwise&gt;</h5><blockquote><p>和&lt;c:when&gt;，&lt;c:otherwise&gt;一起使用类似Java的 if-else if-else</p></blockquote><pre><code>&lt;c:choose var=&quot;${user.flag}&quot; scope=&quot;page&quot;&gt;    &lt;c:when test=&quot;${user.flag}&quot;&gt;        内容    &lt;/c:when&gt;    &lt;c:otherwise&gt;        内容    &lt;/c:otherwise&gt;&lt;/c:choose&gt;</code></pre><p>&lt;c:when&gt;：必须写在&lt;c:choose&gt;里面。作为Java里面的if和else if存在。必须在&lt;c:otherwise&gt;之前存在。可写多个，从上至下运行。当一个test=true时，进入代码块，其他的&lt;c:when&gt;不会执行</p><p>&lt;c:otherwise&gt;：必须写在&lt;c:choose&gt;里面。当没有&lt;c:choose&gt;执行时，执行该代码块</p><hr><h4 id="迭代标签库"><a href="#迭代标签库" class="headerlink" title="迭代标签库"></a>迭代标签库</h4><blockquote><p>用于遍历集合对象，例如list，lterator等。它包含一个标签：&lt;c:forEach&gt;</p></blockquote><h5 id="遍历集合对象"><a href="#遍历集合对象" class="headerlink" title="遍历集合对象"></a><strong>遍历集合对象</strong></h5><pre><code>&lt;c:forEach var=&quot;&quot; items=&quot;&quot; varStatus=&quot;&quot; begin=&quot;&quot; end=&quot;&quot; step=&quot;&quot;&gt;    主题&lt;/c:forEach&gt;</code></pre><p>Var：对当前成员的引用，如循环到第一个成员，则引用第一个成员。如果循环到第二个成员，则用第二个成员。以此类推<br>Items：被迭代的对象，可用EL表达式<br>VarStatus：用于存放var引用成员的相关信息，如索引。类似for循环的i<br>Begin：开始位置，默认0。可省略<br>End：结束位置。可省略<br>Step：循环的步长，默认为1。可省略</p><hr><h5 id="指定语句的执行次数"><a href="#指定语句的执行次数" class="headerlink" title="指定语句的执行次数"></a><strong>指定语句的执行次数</strong></h5><pre><code>&lt;c:forEach var=&quot;&quot; varStatus=&quot;&quot; begin=&quot;&quot; end=&quot;&quot; step=&quot;&quot;&gt;    主题&lt;/c:forEach&gt;</code></pre><p>Var：当前成员的引用<br>VarStatus：用于存放var引用成员的相关信息，如索引。类似for循环的i<br>Begin：开始位置，默认0。可省略<br>End：结束位置。可省略<br>Step：循环的步长，默认为1。可省略</p>]]></content>
      
      
      <categories>
          
          <category> JSP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JSTL </tag>
            
            <tag> EL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Tomcat的基本操作</title>
      <link href="/2019/12/29/tomcat-de-ji-ben-cao-zuo/"/>
      <url>/2019/12/29/tomcat-de-ji-ben-cao-zuo/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是Tomcat"><a href="#什么是Tomcat" class="headerlink" title="什么是Tomcat"></a>什么是Tomcat</h1><p><img src="/2019/12/29/tomcat-de-ji-ben-cao-zuo/../img/47459/TomcatImg.jpg" alt="Tomcat"></p><blockquote><p>Tmocat是一个免费的开源的Web容器。作为Jsp的容器，是在Sun公司的JSWDK（Java Server Web Development Kit）基础上发展起来的一个JSP标准实现。</p></blockquote><a id="more"></a><hr><h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a><strong>目录</strong></h1><ul><li><h2 id="Tomcat的获取和安装"><a href="#Tomcat的获取和安装" class="headerlink" title="Tomcat的获取和安装"></a>Tomcat的获取和安装</h2><ul><li>Tomcat的获取</li><li>Tomcat的安装</li></ul></li><li><h2 id="Tomcat的目录结构"><a href="#Tomcat的目录结构" class="headerlink" title="Tomcat的目录结构"></a>Tomcat的目录结构</h2><ul><li>目录说明</li></ul></li><li><h2 id="将Tomcat部署到Myeclipse"><a href="#将Tomcat部署到Myeclipse" class="headerlink" title="将Tomcat部署到Myeclipse"></a>将Tomcat部署到Myeclipse</h2><ul><li>在Myeclipse中配置Tomcat</li><li>将Tomcat部署到Myeclipse</li></ul></li></ul><hr><h2 id="Tomcat-的获取和安装"><a href="#Tomcat-的获取和安装" class="headerlink" title="Tomcat 的获取和安装"></a><strong>Tomcat 的获取和安装</strong></h2><ul><li><p><strong>Tomcat的获取</strong></p><ul><li>从<a href="http://tomcat.apache.org/" target="_blank" rel="noopener">Apache官方网站</a>获取Tomcat最新版本。Tomcat提供了安装版本和解压缩版本的文件，可以根据需要进行下载</li></ul></li><li><p><strong>Tomcat的安装</strong></p><ul><li><p>Tomcat的安装根据提示点击下一步进行安装。需要注意的是解压缩版本在安装完毕后还要设置CATALINA_HOME环境变量，设置方法个设置Java环境变量的步骤类似</p><ol><li><p>右击我的电脑——属性——高级系统设置——环境变量——新建</p><p> <img src="/2019/12/29/tomcat-de-ji-ben-cao-zuo/../img/47459/Path.png" alt="环境变量"></p></li><li><p>添加环境变量，变量名为CATALINA-HOME，变量值为Tomcat的安装路径</p></li></ol></li></ul></li></ul><hr><h2 id="Tomcat的目录结构-1"><a href="#Tomcat的目录结构-1" class="headerlink" title="Tomcat的目录结构"></a><strong>Tomcat的目录结构</strong></h2><table><thead><tr><th align="center">目录</th><th align="left">说明</th></tr></thead><tbody><tr><td align="center">bin</td><td align="left">存放各种平台下用于启动和停止Tomcat的脚本文件</td></tr><tr><td align="center">conf</td><td align="left">存放Tomcat服务器的各种配置文件</td></tr><tr><td align="center">lib</td><td align="left">存放Tomcat服务器所需的各种JAR文件</td></tr><tr><td align="center">loge</td><td align="left">存放Tomcat的日志文件</td></tr><tr><td align="center">temp</td><td align="left">Tomcat运行时用于存放临时文件</td></tr><tr><td align="center">webapps</td><td align="left">Web应用的发布目录</td></tr><tr><td align="center">work</td><td align="left">Tomcat吧由Jsp生成的Servlet存放与此目录下</td></tr></tbody></table><hr><h2 id="将Tomcat部署到Myeclipse-1"><a href="#将Tomcat部署到Myeclipse-1" class="headerlink" title="将Tomcat部署到Myeclipse"></a><strong>将Tomcat部署到Myeclipse</strong></h2><blockquote><p>在部署之前，需要先在Myeclipse中配置Tomcat</p></blockquote><ul><li><p>打开Myeclipse——上方任务栏中的Window——Preferences</p><p>  <img src="/2019/12/29/tomcat-de-ji-ben-cao-zuo/../img/47459/MyeclipsePrompt.png" alt="配置"></p></li><li><p>在弹出的对话框中选择Myeclipse —— Servers —— Tomcat —— Tomcat 7.X —— 勾选右侧的单选按钮Enable —— 点击Tomcat home directory后面的Browse按钮，选择Tomcat的安装路径 —— 点击下方的Apply</p><p>  <img src="/2019/12/29/tomcat-de-ji-ben-cao-zuo/../img/47459/MyeclipsePrompt2.png" alt="配置2"></p></li><li><p>选择Tomcat 7.X 下的JDK —— 单击ADD按钮 —— 在弹出的对话框中单击Directory —— 选择JDK安装路径 —— 单击Finish</p><p>  <img src="/2019/12/29/tomcat-de-ji-ben-cao-zuo/../img/47459/MyeclipsePrompt3.png" alt="配置3"></p><p>  <img src="/2019/12/29/tomcat-de-ji-ben-cao-zuo/../img/47459/MyeclipsePrompt4.png" alt="配置4"></p></li><li><p>单击Apply —— OK —— 配置完成</p><p>  <img src="/2019/12/29/tomcat-de-ji-ben-cao-zuo/../img/47459/MyeclipsePrompt5.png" alt="配置5"></p></li></ul><blockquote><p>配置完成后开始部署</p></blockquote><ul><li><p>点击上方菜单栏中的部署图标</p><p>  <img src="/2019/12/29/tomcat-de-ji-ben-cao-zuo/../img/47459/MyeclipsePrompt6.png" alt="配置6"></p></li><li><p>在弹出的对话框中选择部署的项目（必须是Web Project）—— 点击Add —— 在弹出的对话框中选择刚才配置的Tomcat版本（Tomcat 7.0）—— 单击Finish ——部署完毕</p><p>  <img src="/2019/12/29/tomcat-de-ji-ben-cao-zuo/../img/47459/MyeclipsePrompt7.png" alt="配置7"></p><p>  <img src="/2019/12/29/tomcat-de-ji-ben-cao-zuo/../img/47459/MyeclipsePrompt8.png" alt="配置8"></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 软件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tomcat </tag>
            
            <tag> 入门 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一篇文章</title>
      <link href="/2019/12/28/di-yi-pian-bo-ke-wen-zhang/"/>
      <url>/2019/12/28/di-yi-pian-bo-ke-wen-zhang/</url>
      
        <content type="html"><![CDATA[<h1 id="自己在创建博客过程中遇见的问题"><a href="#自己在创建博客过程中遇见的问题" class="headerlink" title="自己在创建博客过程中遇见的问题"></a><strong>自己在创建博客过程中遇见的问题</strong></h1><p><img src="/2019/12/28/di-yi-pian-bo-ke-wen-zhang/../img/32733/test1.jpg" alt="图片" title="测试图片"></p><h2 id="部署到Github时-GitBash-报错"><a href="#部署到Github时-GitBash-报错" class="headerlink" title="部署到Github时 GitBash 报错"></a>部署到Github时 GitBash 报错</h2><p> 描述：<strong>使用 hexo d 进行部署时出现了错误提示</strong></p><p> 例：</p><pre><code>暂无截图</code></pre><p> 解决方法：去Github查看是否已部署完成</p><hr><h1 id="常用hexo命令"><a href="#常用hexo命令" class="headerlink" title="常用hexo命令"></a><strong>常用hexo命令</strong></h1><p>使用hexo命令时需要通过cd进入到对应的博客位置才能正常使用</p><blockquote><pre><code>hexo cl    //清空hexo g     //重新加载hexo c     //开启本地服务hexo d     //部署到Github上</code></pre></blockquote><p>需要注意的是在用hexo d部署时，第一次输入的是在Github注册的用户名,第二次输入的密码是token。需要在Github获取才行</p><p><strong>！！！注意！！！</strong></p><p>token只会在获取后显示一次，如果第一次显示后没有保存则需要删除token后再次获取</p><h2 id="如何写一篇博客文章"><a href="#如何写一篇博客文章" class="headerlink" title="如何写一篇博客文章"></a>如何写一篇博客文章</h2><blockquote><ol><li>在BitBash或者在cmd命令窗口使用hexo n “博客标题”来在指定位置创建文章</li><li>打开创建的文件，使用工具来编写Markdown文档</li><li>将博客先部署到本机，查看博客内容是否完成</li><li>完成后重新将hexo部署到Github上</li><li>等待一段时间后刷新网页看是否创已经上传到Github上</li></ol></blockquote><h2 id="部署时一直弹出输入用户名和密码"><a href="#部署时一直弹出输入用户名和密码" class="headerlink" title="部署时一直弹出输入用户名和密码"></a>部署时一直弹出输入用户名和密码</h2><p>描述：<strong>在输入hexo d部署到Github时，每次都需要输入用户名，密码。然后在Git Bash里又要再次输入用户名和Token密码</strong></p><p>例：</p><p>   暂无图片</p><p>解决方法：在Github里面设置了ssh后就不用多次输入用户名密码，只需要在Git Bash里输入用户名和Token密码就行了</p><p><a href="http://www.baidu.com/" target="_blank" rel="noopener" title="百度一下">百度</a></p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 测试 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
