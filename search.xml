<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>SSM整合</title>
      <link href="/2020/04/30/ssm-zheng-he/"/>
      <url>/2020/04/30/ssm-zheng-he/</url>
      
        <content type="html"><![CDATA[<h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><blockquote><p>本文章内容为SSM所需的配置文件</p></blockquote><blockquote><p>，说明了所需的jar包(可根据需求自行增加)。</p></blockquote><h1 id="SSM整合"><a href="#SSM整合" class="headerlink" title="SSM整合"></a><strong>SSM整合</strong></h1><h2 id="所需jar包："><a href="#所需jar包：" class="headerlink" title="所需jar包："></a>所需jar包：</h2><h1 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a><strong>配置文件</strong></h1><p>beans配置</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;     xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;     xsi:schemaLocation=&quot;        http://www.springframework.org/schema/beans         http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;&lt;/beans&gt;</code></pre><h2 id="resoueces目录下的applicationContext-mybatis-xml"><a href="#resoueces目录下的applicationContext-mybatis-xml" class="headerlink" title="/resoueces目录下的applicationContext-mybatis.xml"></a>/resoueces目录下的applicationContext-mybatis.xml</h2><pre><code>&lt;!-- 获取数据源 --&gt;&lt;bean id=&quot;dataSource&quot; class=&quot;org.apache.commons.dbcp2.BasicDataSource&quot; destroy-method=&quot;close&quot; scope=&quot;singleton&quot;&gt;    &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;/&gt;    &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/smbms?serverTimezone=UTC&quot;/&gt;    &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;    &lt;property name=&quot;password&quot; value=&quot;root&quot;/&gt;&lt;/bean&gt;</code></pre><hr><h1 id="配置aop"><a href="#配置aop" class="headerlink" title="配置aop"></a><strong>配置aop</strong></h1><pre><code>&lt;!-- 配置aop --&gt;&lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;    &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;&lt;/bean&gt;&lt;aop:aspectj-autoproxy/&gt;&lt;aop:config proxy-target-class=&quot;true&quot;&gt;    &lt;aop:pointcut expression=&quot;execution(* *cn.jbit.service..*(..))&quot; id=&quot;transService&quot;/&gt;    &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut-ref=&quot;transService&quot;/&gt;&lt;/aop:config&gt;&lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;transactionManager&quot;&gt;    &lt;tx:attributes&gt;        &lt;tx:method name=&quot;*&quot; propagation=&quot;REQUIRED&quot;/&gt;    &lt;/tx:attributes&gt;&lt;/tx:advice&gt;</code></pre><h2 id="配置mybatis的SqlSessionFactoryBean"><a href="#配置mybatis的SqlSessionFactoryBean" class="headerlink" title="配置mybatis的SqlSessionFactoryBean"></a><em>配置mybatis的SqlSessionFactoryBean</em></h2><pre><code>&lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;    &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;    &lt;property name=&quot;configLocation&quot; value=&quot;classpath:mybatis-config.xml&quot;/&gt;&lt;/bean&gt;</code></pre><blockquote><p>注意：如果不想配置mybatis.config.xml文件可以将configLocation更换成mapperLocations，如：</p></blockquote><pre><code>&lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;    &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;    &lt;property name=&quot;mapperLocations&quot; value=&quot;classpath:cn/jbit/dao/*.xml&quot;/&gt;    &lt;property name=&quot;typeAliasesPackage&quot; value=&quot;cn.jbit.entity&quot;/&gt;&lt;/bean&gt;</code></pre><ul><li>mapperLocations<ul><li>设置dao.xml文件的路径，这样就会自动扫描映射文件</li></ul></li><li>typeAliasesPackage<ul><li>设置实体类路径，在映射文件里写实体类时就不用写全路径了</li></ul></li></ul><h2 id="配置MapperScannerConfigurer，自动注册dao接口对应的xml并配置成bean"><a href="#配置MapperScannerConfigurer，自动注册dao接口对应的xml并配置成bean" class="headerlink" title="配置MapperScannerConfigurer，自动注册dao接口对应的xml并配置成bean"></a><em>配置MapperScannerConfigurer，自动注册dao接口对应的xml并配置成bean</em></h2><pre><code>&lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt;    &lt;property name=&quot;basePackage&quot; value=&quot;cn.jbit.dao&quot;&gt;&lt;/property&gt;&lt;/bean&gt;</code></pre><p>配置context标签自动扫描cn.jbit.service包下的控制器</p><pre><code>&lt;context:component-scan base-package=&quot;cn.jbit.service&quot;/&gt;</code></pre><h2 id="配置mybatis-config-xml"><a href="#配置mybatis-config-xml" class="headerlink" title="配置mybatis-config.xml"></a><em>配置mybatis-config.xml</em></h2><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration  PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;  &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt;  &lt;settings&gt;    &lt;!--开启Mybatis支持延迟加载--&gt;    &lt;setting name=&quot;lazyLoadingEnabled&quot; value=&quot;true&quot;/&gt;    &lt;!--开启Mybatis支持延迟加载--&gt;    &lt;setting name=&quot;aggressiveLazyLoading&quot; value=&quot;false&quot;/&gt;    &lt;!-- 配置log为log4j --&gt;    &lt;setting name=&quot;logImpl&quot; value=&quot;STDOUT_LOGGING&quot;/&gt;  &lt;/settings&gt;  &lt;typeAliases&gt;      &lt;package name=&quot;cn.jbit.entity&quot;&gt;&lt;/package&gt;  &lt;/typeAliases&gt;  &lt;mappers&gt;    &lt;package name=&quot;cn.jbit.dao&quot;/&gt;  &lt;/mappers&gt;&lt;/configuration&gt;</code></pre><h2 id="配置springmvc-servlet-xml"><a href="#配置springmvc-servlet-xml" class="headerlink" title="配置springmvc-servlet.xml"></a><em>配置springmvc-servlet.xml</em></h2><p>配置context标签自动扫描cn.jbit.controller包下的控制器</p><pre><code>&lt;context:component-scan base-package=&quot;cn.jbit.controller&quot;/&gt;</code></pre><h2 id="配置mvc-annotation-driven标签和消息转换器"><a href="#配置mvc-annotation-driven标签和消息转换器" class="headerlink" title="配置mvc:annotation-driven标签和消息转换器"></a><em>配置mvc:annotation-driven标签和消息转换器</em></h2><pre><code>&lt;mvc:annotation-driven conversion-service=&quot;myConversionService&quot;&gt;    &lt;mvc:message-converters register-defaults=&quot;true&quot;&gt;        &lt;bean class=&quot;org.springframework.http.converter.StringHttpMessageConverter&quot;&gt;            &lt;property name=&quot;supportedMediaTypes&quot; value=&quot;text/plain;charset=UTF-8&quot;/&gt;        &lt;/bean&gt;    &lt;/mvc:message-converters&gt;&lt;/mvc:annotation-driven&gt;&lt;!-- 加载自定义转换器 --&gt;&lt;bean id=&quot;myConversionService&quot; class=&quot;org.springframework.context.support.ConversionServiceFactoryBean&quot;&gt;    &lt;property name=&quot;converters&quot;&gt;        &lt;list&gt;            &lt;bean class=&quot;cn.jbit.tool.StringToDateConverter&quot;&gt;                &lt;constructor-arg type=&quot;java.lang.String&quot; value=&quot;yyyy-MM-dd&quot;/&gt;            &lt;/bean&gt;        &lt;/list&gt;    &lt;/property&gt;&lt;/bean&gt;</code></pre><h2 id="配置mvc-resources标签加载静态资源"><a href="#配置mvc-resources标签加载静态资源" class="headerlink" title="配置mvc:resources标签加载静态资源"></a><em>配置mvc:resources标签加载静态资源</em></h2><pre><code>&lt;mvc:resources location=&quot;/statics/&quot; mapping=&quot;/statics/**&quot;/&gt;</code></pre><h2 id="配置支持文件上传"><a href="#配置支持文件上传" class="headerlink" title="配置支持文件上传"></a><em>配置支持文件上传</em></h2><pre><code>&lt;bean id=&quot;multipartResolver&quot; class=&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;&gt;    &lt;property name=&quot;maxUploadSize&quot; value=&quot;5000000&quot;&gt;&lt;/property&gt;    &lt;property name=&quot;defaultEncoding&quot; value=&quot;UTF-8&quot;&gt;&lt;/property&gt;&lt;/bean&gt;</code></pre><h2 id="配置多视图解析器"><a href="#配置多视图解析器" class="headerlink" title="配置多视图解析器"></a><em>配置多视图解析器</em></h2><pre><code>&lt;bean id=&quot;viewResolver&quot; class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;    &lt;property name=&quot;prefix&quot; value=&quot;/jsp/&quot;/&gt;    &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt;&lt;/bean&gt;</code></pre><h2 id="配置拦截器"><a href="#配置拦截器" class="headerlink" title="配置拦截器"></a><em>配置拦截器</em></h2><pre><code>&lt;mvc:interceptors&gt;    &lt;mvc:interceptor&gt;        &lt;!-- *开头的路径都拦截 --&gt;        &lt;mvc:mapping path=&quot;/smbm/**&quot;/&gt;        &lt;!-- 拦截器路径 --&gt;        &lt;bean class=&quot;cn.SpringMVC.interceptor.FirstInterceptor&quot;&gt;&lt;/bean&gt;    &lt;/mvc:interceptor&gt;&lt;/mvc:interceptors&gt;</code></pre><h2 id="配置web-xml"><a href="#配置web-xml" class="headerlink" title="配置web.xml"></a><em>配置web.xml</em></h2><p>配置springmvc.xmlc扫描</p><pre><code>&lt;servlet&gt;       &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt;    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;    &lt;init-param&gt;        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;        &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt;    &lt;/init-param&gt;    &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt;    &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt;       &lt;url-pattern&gt;/&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;</code></pre><p>传参乱码解决</p><pre><code>&lt;filter&gt;    &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt;    &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;    &lt;init-param&gt;        &lt;param-name&gt;encoding&lt;/param-name&gt;        &lt;param-value&gt;utf-8&lt;/param-value&gt;    &lt;/init-param&gt;    &lt;init-param&gt;        &lt;param-name&gt;forceEncoding&lt;/param-name&gt;        &lt;param-value&gt;true&lt;/param-value&gt;    &lt;/init-param&gt;&lt;/filter&gt;&lt;filter-mapping&gt;    &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt;    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt;</code></pre><p>Spring监听器</p><pre><code>&lt;context-param&gt;    &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;    &lt;param-value&gt;classpath:applicationContext-*.xml&lt;/param-value&gt;&lt;/context-param&gt;&lt;listener&gt;    &lt;listener-class&gt;        org.springframework.web.context.ContextLoaderListener    &lt;/listener-class&gt;&lt;/listener&gt;</code></pre><hr><h1 id="ajax返回参数的方式更换"><a href="#ajax返回参数的方式更换" class="headerlink" title="ajax返回参数的方式更换"></a><strong>ajax返回参数的方式更换</strong></h1><blockquote><p>在ajax返回参数时，可以试着返回一个自定义的类。类里面有执行状态(int)，状态说明(String)，需要传递的对象(Object)这三个属性。在jsp页面就可以根据执行状态来觉得执行什么内容，</p></blockquote><blockquote><p>比如说传递了自定义的类，根据类的有参构造器，传入了执行状态：200，状态说明：执行成功，传递的对象：User。这时候在jsp页面就可以判断，如果data.执行状态=200，就执行登录操作</p></blockquote><p>首先创建一个枚举类</p><pre><code>enum ResultCode</code></pre><p>然后在枚举类里创建几个数据的状态，例如执行成功(SUCCESS(200,”成功”))，执行失败(FAIL(303,”失败”))，对象为空(EMPTY(250,”空值”))。这个数据状态是可以根据需求添加的</p><pre><code>SUCCESS(200,&quot;成功&quot;),FAIL(303,&quot;失败&quot;),EMPTY(250,&quot;空值&quot;),ERROR(101,&quot;错误&quot;);</code></pre><p>在枚举类里创建两个属性：执行状态和状态说明。并提供set和get方法</p><pre><code>private int code ;private String desc;</code></pre><p>最后提供有参和无参的构造器</p><hr><p>创建一个自定义状态类：ResponseMsg<br><br>并让该类实现Serializable。<br><br>在该类里面有三个私有属性：</p><pre><code>Integer statusString msgObject data</code></pre><p>并提供对应的set和get方法<br><br>根据需求提供对应的有参和无参构造器</p><hr><p>根据枚举类里的数据状态写对应的静态方法</p><pre><code>public static  ResponseMsg BySuccess(String msg,Object data) {    return new ResponseMsg(ResultCode.SUCCESS.getCode(),msg,data);}</code></pre><p>这个方法就是执行成功需要返回的自定义类方法。在返回时，传入说明和一个对象。同时，在调用这个方法时会自动获取对应的枚举：ResultCode.SUCCESS.getCode()</p><pre><code>public static ResponseMsg ByFail(String msg) {    return new ResponseMsg(ResultCode.FAIL.getCode(),msg);}</code></pre><p>这个方法就是执行失败返回的自定义方法，在返回时，只需要提供说明即可。这样返回的就是对应的枚举和一个说明</p><blockquote><p>注意：写不同的方法时，需要改变对应的枚举，比如执行成功就是传入的ResultCode.SUCCESS.getCode()，执行失败就是传入的ResultCode.FAIL.getCode()。</p></blockquote><p>在写不同的方法时需要不同的有参构造器，比如说执行成功就需要全参构造器</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mybatis </tag>
            
            <tag> Spring </tag>
            
            <tag> 框架 </tag>
            
            <tag> SpringMVC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringMVC(二)</title>
      <link href="/2020/04/24/springmvc-er/"/>
      <url>/2020/04/24/springmvc-er/</url>
      
        <content type="html"><![CDATA[<h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><blockquote><p>本篇作为SpringMVC（一）的补充</p></blockquote><h2 id="返回参数"><a href="#返回参数" class="headerlink" title="返回参数"></a><strong>返回参数</strong></h2><blockquote><p>使用ModelAndView返回的方法可在jsp页面直接使用EL表达式(${name})获取参数</p></blockquote><pre><code>public ModelAndView index(String name){    ModelAndView mView = new ModelAndView ();    mView .addObject(&quot;name&quot;,&quot;value&quot;);    mView.setViewName(&quot;index&quot;);    return mview;}</code></pre><ul><li>addObject<ul><li>添加键值对，也可以只传入value，这样name默认就是传入的value，如果value是一个变量名，那么name就是变量名</li></ul></li><li>setViewName：跳转地址<ul><li>根据xml配置的地址进行跳转<blockquote><p>使用Model作为传递的参数也可在jsp页面直接使用EL表达式(${name})获取参数</p></blockquote></li></ul></li></ul><pre><code>public String index(String name, Model model){    model.addAttribute(&quot;name&quot;,&quot;value&quot;);    return &quot;index&quot;;}</code></pre><ul><li>addAttribute<ul><li>添加键值对，也可以只传入value，这样name默认就是传入的value，如果value是一个变量名，那么name就是变量名</li></ul></li></ul><hr><h2 id="传参的设置"><a href="#传参的设置" class="headerlink" title="传参的设置"></a><strong>传参的设置</strong></h2><pre><code>@RequestParam(value=&quot;&quot;,required=true,defaultValue=?) String name</code></pre><ul><li><p>value</p><ul><li>传入的参数名称</li></ul></li><li><p>required</p><ul><li>该参数是否为必传，当为true时，该参数必须有，否则会报错。如果为false，表示该参数可不传</li></ul></li><li><p>defaultValue</p><ul><li>当没有传入属性时的默认值</li></ul><hr></li></ul><h2 id="单文件上传"><a href="#单文件上传" class="headerlink" title="单文件上传"></a><strong>单文件上传</strong></h2><p>在spring-mvc.xml配置bean</p><pre><code>&lt;bean id=&quot;multipartResolver&quot; class=&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;&gt;    &lt;property name=&quot;maxUploadSize&quot; value=&quot;5000000&quot;&gt;&lt;/property&gt;    &lt;property name=&quot;defaultEncoding&quot; value=&quot;UTF-8&quot;&gt;&lt;/property&gt;&lt;/bean&gt;</code></pre><p>jsp页面</p><pre><code>form表单的编码类型必须是multipart/form-data类型，提交类型必须是post&lt;form enctype=&quot;multipart/form-data&quot; method=&quot;post&quot; action=&quot;test/index&quot;&gt;    &lt;input type=&quot;file&quot; name=&quot;image&quot; value=&quot;&quot;/&gt;&lt;/form&gt;</code></pre><p>Controller页面</p><pre><code>public String addUser(User user,HttpServletRequest request ,HttpSession session ,@RequestParam(value=&quot;image&quot;,required=false) MultipartFile attach){    //判断是否有上传文件    if(!attach.isEmpty()){        //获取文件路径        String path = request.getSession().getServletContext().getRealPath(&quot;statics&quot;+File.separator+&quot;uploadfiles&quot;);        //获取原文件名        String name = attach.getOriginalFilename();        //获取原文件后缀        String prefix = FilenameUtlis.getExtension(name);        //判断文件大小        if(attach.getSize() &gt; 5000){            //文件大于500KB        }else if(prefix.equalsIgnoreCase(&quot;jpg&quot;)){//判断文件后缀            //创建新的文件名称            String fileName = System.currentTimeMillis()+RandomUtils.nextInt(1000000)+&quot;test.jpg&quot;;//新的名称为当前时间+随机数+&quot;test.jpg&quot;            //定义上传到服务器的路径。该路径是相对路径            String fileUrl = &quot;uploadfiles&quot;+File.separator+fileName;            //将地址和名称存储到一个file对象，该对象用来接收上传的文件流。该地址是绝对路径            File file = new File(path,fileName);            //如果地址不存在则创建一个地址            if(!file.exists()){                file.mkdirs();            }            //将文件上传至服务器            try{                attach.transferTo(file)            }cath{                //文件上传失败            }            //将文件位置添加到add的User对象中            user.setImage(fileUrl);        }else{            //文件格式不对        }    }}</code></pre><p>注意：生成随机数需要加载commons-lang的jar包</p><hr><h2 id="上传多个文件"><a href="#上传多个文件" class="headerlink" title="上传多个文件"></a><strong>上传多个文件</strong></h2><p>在jsp页面的多个file组件的name必须一致<br><br>Controller页面：</p><pre><code>public String addUser(User user,HttpServletRequest request ,HttpSession session ,@RequestParam(value=&quot;image&quot;,required=false) MultipartFile[] attachs){    for(int i=0;i&lt;attachs.length;i++){        MultipartFile attach = attachs[i];        //和上传单个文件相似        //给两个不同的user文件名称赋值        String FileName = path+File.separator+fileName;        if(i==0){            user.setTest1(FileName )        }else if(i==1){            user.setTest2(FileName )        }    }}</code></pre><p>注意：如果是上传多个文件，MultipartFile名称前必须加上@RequestParam注解，否则会报错</p><hr><h2 id="传递的乱码"><a href="#传递的乱码" class="headerlink" title="传递的乱码"></a><strong>传递的乱码</strong></h2><p>在解决传递的乱码时，text/plain可以换成application/json来解决json传递中文出现的乱码</p><pre><code>&lt;mvc:annotation-driven&gt;    &lt;mvc:message-converters register-defaults=&quot;true&quot;&gt;        &lt;bean class=&quot;org.springframework.http.converter.StringHttpMessageConverter&quot;&gt;            &lt;property name=&quot;supportedMediaTypes&quot; value=&quot;text/plain;charset=UTF-8&quot;/&gt;        &lt;/bean&gt;    &lt;/mvc:message-converters&gt;&lt;/mvc:annotation-driven&gt;</code></pre><hr><h2 id="日期格式的乱码"><a href="#日期格式的乱码" class="headerlink" title="日期格式的乱码"></a><strong>日期格式的乱码</strong></h2><p>在spring-mvc.xml里配置消息转换器<br><br>在上面的代码mvc:message-converters里面加入子标签</p><pre><code>&lt;bean class=&quot;com.alibaba.fastjson.support.spring.FastJsonHttpMessageConverter&quot;&gt;    &lt;property name=&quot;supportedMediaTypes&quot;&gt;        &lt;list&gt;            &lt;value&gt;text/html;charset=utf-8&lt;/value&gt;            &lt;value&gt;application/json&lt;/value&gt;        &lt;/list&gt;    &lt;/property&gt;    &lt;property name=&quot;features&quot; value=&quot;WriteDateUserFormat&quot;/&gt;&lt;/bean&gt;</code></pre><p>注意：若只配置&lt;property name=”features” value=”WriteDateUserFormat”/&gt;，则会输入yyyy-MM-dd HH:mm:ss格式的日期</p><hr><p>同时也可以只指定某个日期属性的格式<br><br>在属性上加上注解：@JSONField(format=”yyyy-MM-dd”)<br><br>因为这种方式具有强入侵性，紧耦合。并且修改麻烦，所有尽量使用配置bean的方式解决日期格式的问题。<br></p><p>注意：使用@ResponseBody后返回类型直接是需要返回的对象就行，这样对象返回就是json格式的字符串</p><hr><h2 id="多视图解析器"><a href="#多视图解析器" class="headerlink" title="多视图解析器"></a><strong>多视图解析器</strong></h2><p>可以通过同路径，设置MIME格式控制服务器返回的数据类型。从而获得不同的返回内容<br><br>在spring-mvc.xml里配置bean</p><pre><code>&lt;bean class=&quot;org.springframework.web.servlet.view.ContentNegotiatingViewResolver&quot;&gt;    &lt;property name=&quot;favorParameter&quot; value=&quot;true&quot;/&gt;    &lt;property name=&quot;defaultContentType&quot; value=&quot;text/html&quot;/&gt;    &lt;property name=&quot;mediaTypes&quot;&gt;        &lt;map&gt;            &lt;entry key=&quot;html&quot; value=&quot;text/json;charset=utf-8&quot;/&gt;            &lt;entry key=&quot;json&quot; value=&quot;application/json;charset=utf-8&quot;/&gt;            &lt;entry key=&quot;xml&quot; value=&quot;application/xml;charset=utf-8&quot;/&gt;        &lt;/map&gt;    &lt;/property&gt;    &lt;property name=&quot;viewResolvers&quot;&gt;        &lt;list&gt;            &lt;bean id=&quot;viewResolver&quot; class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;                &lt;property name=&quot;prefix&quot; value=&quot;/jsp/&quot;/&gt;                &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt;            &lt;/bean&gt;        &lt;/list&gt;    &lt;/property&gt;&lt;/bean&gt;</code></pre><ul><li>favorParameter<ul><li>默认为true，表示支持参数匹配，可以根据请求参数的值确定MIME类型，默认的请求参数为format</li></ul></li><li>mediaTypes<ul><li>contentType以什么格式展示，若url的后缀为.json，则会以application/json的格式进行数据展示。</li></ul></li></ul><p>连接url改变：</p><pre><code>smbms/tool/showUser.json</code></pre><hr><h2 id="编写自定义转换器"><a href="#编写自定义转换器" class="headerlink" title="编写自定义转换器"></a><strong>编写自定义转换器</strong></h2><blockquote><p>用于解决日期格式的转换问题</p></blockquote><p>创建工具类StringToDateConverter，然后继承org.springframework.core.convert.converter包下的Converter</p><pre><code>public class StringToDateConverter implements Converter&lt;String, Date&gt;{    private String datePattern;    public StringToDateConverter(String datePattern) {        this.datePattern = datePattern;    }    public Date convert(String s) {        Date date = null;        try {            date = new SimpleDateFormat(datePattern).parse(s);        } catch (ParseException e) {            e.printStackTrace();        }        return date;    }}</code></pre><p>在springmvc.xml加载转换器</p><pre><code>&lt;mvc:annotation-driven conversion-service=&quot;myConversionService&quot;&gt;    &lt;mvc:message-converters register-defaults=&quot;true&quot;&gt;        &lt;bean class=&quot;org.springframework.http.converter.StringHttpMessageConverter&quot;&gt;            &lt;property name=&quot;supportedMediaTypes&quot; value=&quot;text/plain;charset=UTF-8&quot;/&gt;        &lt;/bean&gt;    &lt;/mvc:message-converters&gt;&lt;/mvc:annotation-driven&gt;&lt;!-- 加载自定义转换器 --&gt;&lt;bean id=&quot;myConversionService&quot; class=&quot;org.springframework.context.support.ConversionServiceFactoryBean&quot;&gt;    &lt;property name=&quot;converters&quot;&gt;        &lt;list&gt;            &lt;bean class=&quot;cn.jbit.tool.StringToDateConverter&quot;&gt;                &lt;constructor-arg type=&quot;java.lang.String&quot; value=&quot;yyyy-MM-dd&quot;/&gt;            &lt;/bean&gt;        &lt;/list&gt;    &lt;/property&gt;&lt;/bean&gt;</code></pre><h2 id="REST风格"><a href="#REST风格" class="headerlink" title="REST风格"></a><strong>REST风格</strong></h2><p>使用该风格可以简化访问路径</p><pre><code>@RequestMapping(&quot;/test/{id}&quot;)public String test1(@PathVariable String id){}</code></pre><p>访问时输入/test/name即可访问对应的方法</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ajax </tag>
            
            <tag> 入门 </tag>
            
            <tag> 框架 </tag>
            
            <tag> SpringMVC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring配置补充</title>
      <link href="/2020/04/24/spring-pei-zhi-bu-chong/"/>
      <url>/2020/04/24/spring-pei-zhi-bu-chong/</url>
      
        <content type="html"><![CDATA[<h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><blockquote><p>JDBC是由数据库中间服务商提供的，用于连接数据库的Java API。一组类和接口（对接数据库），JNDI是为应用服务器（Tomcat）管理资源所设置的目录样式的唯一标识。（数据库、网页、文档等）</p></blockquote><h2 id="配置DataSource"><a href="#配置DataSource" class="headerlink" title="配置DataSource"></a><strong>配置DataSource</strong></h2><p>将配置文件写在properties文件中，通过读取的方式配置DataSource</p><pre><code>&lt;bean class=&quot;org.springframework.beans.factory.config.PropertyPlaceholderConfigurer&quot;&gt;    &lt;property name=&quot;location&quot;&gt;    &lt;value&gt;classpath:database.properties&lt;/value&gt;    &lt;/property&gt;&lt;/bean&gt;</code></pre><ul><li>value<ul><li>配置文件路径</li></ul></li></ul><p>使用后在applicationContext.xml配置文件里可以使用${key}来获取配置的值，例如：</p><pre><code>&lt;bean id=&quot;dataSource&quot; class=&quot;org.apache.commons.dbcp2.BasicDataSource&quot; destroy-method=&quot;close&quot;&gt;    &lt;property name=&quot;driverClassName&quot; value=&quot;${Driver}&quot;/&gt;    &lt;property name=&quot;url&quot; value=&quot;${url}&quot;&gt;&lt;/property&gt;    &lt;property name=&quot;username&quot; value=&quot;${username}&quot;/&gt;    &lt;property name=&quot;password&quot; value=&quot;${password}&quot;/&gt;&lt;/bean&gt;</code></pre><hr><h2 id="使用JNDI连接数据库"><a href="#使用JNDI连接数据库" class="headerlink" title="使用JNDI连接数据库"></a><strong>使用JNDI连接数据库</strong></h2><blockquote><p>NDI和DBCP的区别：dbcp是针对当前项目的，只能当前项目使用。而jndi是存储在服务器中的。服务器中可以有多个项目，多个项目可以共用数据源</p></blockquote><p>首先在tomcat安装目录配置jndi数据源<br><br>打开context.xml文件，在context标签内配置：</p><pre><code>&lt;Resource name=&quot;jndi/smbms&quot; auth=&quot;Container&quot;        type=&quot;javax.sql.DataSource&quot;        maxActice=&quot;100&quot; maxIdle=&quot;30&quot;        maxWait=&quot;3000&quot; username=&quot;root&quot; password=&quot;root&quot;        driverClassName=&quot;com.mysql.jdbc.Driver&quot;    url=&quot;jdbc:mysql://localhost:3306/forum?userUnicode=true&amp;amp;characterEncoding=utf-8&quot;/&gt;</code></pre><p>然后在xml文件内配置bean</p><pre><code>&lt;bean id=&quot;dataSource&quot; class=&quot;org.springframework.jndi.JndiObjectFactoryBean&quot;&gt;    &lt;property name=&quot;jndiName&quot;&gt;    &lt;value&gt;java:comp/env/jdbc/smbms&lt;/value&gt;    &lt;/property&gt;&lt;/bean&gt;</code></pre><ul><li>value<ul><li>comp/env是固定路径，jdbc/smbms是配置的数据源名称</li></ul></li></ul><hr><h2 id="Spring自动装配"><a href="#Spring自动装配" class="headerlink" title="Spring自动装配"></a><strong>Spring自动装配</strong></h2><blockquote><p>在xml文件配置bean时如果需要注入属性则需要手动设置property的name和value属性，可以改为&lt;bean id=”a” class=”test” autowire=”byName”/&gt;来自动注入对应的属性</p></blockquote><p>autowire属性：</p><ul><li>no<ul><li>默认值，不进行自动装配</li></ul></li><li>byName<ul><li>根据属性名称自动装配。自动查找对应的id，找到就注入，否则什么都不做</li></ul></li><li>byType<ul><li>根据属性的类型自动匹配，如果找到一个则注入，找到多个则报错，没找到就什么都不做</li></ul></li><li>constructor<ul><li>和byType类型，不过他针对构造方法，如果找到一个bean的构造方法的参数类型相匹配则注入，否则什么都不做</li></ul></li></ul><blockquote><p>注意：可以写在beans标签内开启自动装配</p></blockquote><hr><h2 id="拆分Spring配置文件"><a href="#拆分Spring配置文件" class="headerlink" title="拆分Spring配置文件"></a><strong>拆分Spring配置文件</strong></h2><blockquote><p>根据模块不同分为四部分：公共部分，dao，service，web</p></blockquote><p>例如：<br><br>applicationContext.xml负责公共部分，例如事务控制，dataSource，注入映射器等<br><br>applicationContext-dao.xml只负责配置dao层的bean<br><br>applicationContext-service.xml只负责配置service层的bean和注入（可以开启自动装配。一般是根据名称自动装配）<br></p><hr><h2 id="合并多个配置文件"><a href="#合并多个配置文件" class="headerlink" title="合并多个配置文件"></a><strong>合并多个配置文件</strong></h2><ol><li>在ClassPathXMLApplicationContext()里传入多个配置文件，如：ClassPathXMLApplicationContext(“applicationContext.xml”,”applicationContext-dao.xml”)。多个配置文件用’,’分隔</li><li>在公共部分加入&lt;import resource=””/&gt;来加载多个配置文件，如：&lt;import resource=”applicationContext-dao.xml”/&gt;</li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis和Spring整合</title>
      <link href="/2020/04/24/mybatis-he-spring-zheng-he/"/>
      <url>/2020/04/24/mybatis-he-spring-zheng-he/</url>
      
        <content type="html"><![CDATA[<h2 id="SqlMapConfig-xml配置"><a href="#SqlMapConfig-xml配置" class="headerlink" title="SqlMapConfig.xml配置"></a><strong>SqlMapConfig.xml配置</strong></h2><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration  PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;  &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt;   &lt;settings&gt;    &lt;!--开启Mybatis支持延迟加载--&gt;    &lt;setting name=&quot;lazyLoadingEnabled&quot; value=&quot;true&quot;/&gt;    &lt;!--开启Mybatis支持延迟加载--&gt;    &lt;setting name=&quot;aggressiveLazyLoading&quot; value=&quot;false&quot;/&gt;    &lt;!-- 配置log为log4j --&gt;    &lt;setting name=&quot;logImpl&quot; value=&quot;STDOUT_LOGGING&quot;/&gt;  &lt;/settings&gt;  &lt;typeAliases&gt;&lt;!-- 扫描实体类 --&gt;      &lt;package name=&quot;cn.jbit.entity&quot;&gt;&lt;/package&gt;  &lt;/typeAliases&gt;  &lt;mappers&gt;&lt;!-- 自动扫描xml文件 --&gt;    &lt;package name=&quot;cn.jbit.dao&quot;/&gt;  &lt;/mappers&gt;&lt;/configuration&gt;</code></pre><hr><h2 id="applicationContext-mybatis-xml配置"><a href="#applicationContext-mybatis-xml配置" class="headerlink" title="applicationContext-mybatis.xml配置"></a><strong>applicationContext-mybatis.xml配置</strong></h2><p>连接数据库相关的信息</p><pre><code>&lt;bean id=&quot;dataSource&quot; class=&quot;org.apache.commons.dbcp.BasicDataSource&quot; destroy-method=&quot;close&quot;&gt;  &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;  &lt;property name=&quot;url&quot;&gt;    &lt;value&gt;&lt;![CDATA[jdbc:mysql://localhost:3306/system?useUnicode=true&amp;characterEncoding=utf-8]]&gt;&lt;/value&gt;  &lt;/property&gt;  &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;  &lt;property name=&quot;password&quot; value=&quot;root&quot;/&gt;&lt;/bean&gt;</code></pre><h2 id="配置SqlSessionFactoryBean"><a href="#配置SqlSessionFactoryBean" class="headerlink" title="配置SqlSessionFactoryBean"></a><strong>配置SqlSessionFactoryBean</strong></h2><pre><code>&lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;  &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;  &lt;property name=&quot;configLocation&quot; value=&quot;classpath:mybatis-config.xml&quot;/&gt;  &lt;property name=&quot;mapperLocations&quot;&gt;  &lt;list&gt;    &lt;value&gt;classpath:cn/subms/dao/**/*.xml&lt;/value&gt;  &lt;/list&gt;  &lt;/property&gt;&lt;/bean&gt;</code></pre><hr><h2 id="配置实现类-impl"><a href="#配置实现类-impl" class="headerlink" title="配置实现类(impl)"></a><strong>配置实现类(impl)</strong></h2><p>设置bean的id</p><pre><code>@Component(&quot;userDaoImpl &quot;)public class UserDaoImpl implements UserDao{  //自动配置sqlSessionFactory。或者可以指定sqlSessionTemplate创建的bean  @Autowired  private SqlSessionTemplate sqlSession;  public list&lt;User&gt; getUserList(User user){    return sqlSession.selectList(&quot;cn.jbit.dao.UserDao.getUserList&quot;,user);  }}</code></pre><hr><p>写在applicationContext-mybatis.xml配置中</p><pre><code>&lt;bean id=&quot;sqlSessionTemplate&quot; class=&quot;org.mybatis.spring.SqlSessionTemplate&quot;&gt;  &lt;constructor-arg name=&quot;sqlSessionFactory&quot; ref=&quot;sqlSessionFactory&quot;/&gt;&lt;/bean&gt;</code></pre><hr><p>配置服务层(Service)</p><pre><code>@Component(&quot;userServiceImpl&quot;)public class UserServiceImpl{//自动配置@Autowiredprivate IUserDao userDao;  public void addUser(){    userDao.addUser();  }}</code></pre><hr><h2 id="注入映射器的实现"><a href="#注入映射器的实现" class="headerlink" title="注入映射器的实现"></a><strong>注入映射器的实现</strong></h2><h3 id="为什么要注入映射器的实现"><a href="#为什么要注入映射器的实现" class="headerlink" title="为什么要注入映射器的实现"></a><em>为什么要注入映射器的实现</em></h3><blockquote><p>原本每次使用方法都需要创建一次映射器(sqlSession.getMapper(UserDao.class).getgetUserList(user))，注入映射器后只需要创建一次即可。使用注入映射后无需创建daoimpl，直接用注解在service的dao对象上自动注入即可</p></blockquote><h2 id="声明式事务"><a href="#声明式事务" class="headerlink" title="声明式事务"></a><strong>声明式事务</strong></h2><p>注意：默认只有RuntimeException异常能触发事务回滚;<br><br>抛出异常：throw new RuntimeException(“抛出异常”);<br></p><blockquote><p>首先声明tx和aop的命名空间</p></blockquote><pre><code>xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;xsi:schemalocation=&quot;http://www.springframework.org/schema/tx    http://www.springframework.org/schema/tx/spring-tx-3.1.xsd&quot;</code></pre><p>定义事务管理器</p><pre><code>&lt;bean id=&quot;txManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!-- 定义事务增强 --&gt;&lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;txManager&quot;&gt;  &lt;tx:attributes&gt;    &lt;tx:method name=&quot;add*&quot; timeout=&quot;-1&quot;/&gt;  &lt;/tx:attributes&gt;&lt;/tx:advice&gt;</code></pre><ul><li><p>tx:method</p><ul><li>timeout：默认值为-1，事务超时时间。当为-1时表示事务不会超时。里面的数字表示超时的时间，用秒做单位</li></ul></li><li><p>propagation</p><ol><li>默认值为REQUIRED，表示所有匹配的方法都在一个事务中，如果不在事务中则新建一个事务。一般增删改使用默认值</li><li>supports。表示如果在事务中则按照事务的方式进行处理，如果不在事务中就按正常的方式进行处理。一般用于查询</li></ol><hr></li></ul><p>配置切面决定那些包下面的哪些方法参与事务增强</p><pre><code>&lt;aop:config&gt;  &lt;aop:pointcut expression=&quot;execution(* cn.jbit.service..*.*(..))&quot; id=&quot;myPoint&quot;/&gt;  &lt;!-- 织入事务增强 --&gt;  &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut-ref=&quot;myPoint&quot;/&gt;&lt;/aop:config&gt;</code></pre><ul><li>expression<ul><li>决定那些包下面的哪些方法参与事务增强</li></ul></li><li>advice-ref<ul><li>表示织入哪个增强id</li></ul></li><li>pointcut-ref<ul><li>决定哪些方法加入增强<br>当配置完事务管理器后，如果指定多条增删改语句，要么都执行，要么都不执行。这就是事务控制</li></ul></li></ul><hr><h2 id="使用注解完成事务管理"><a href="#使用注解完成事务管理" class="headerlink" title="使用注解完成事务管理"></a><strong>使用注解完成事务管理</strong></h2><pre><code>&lt;bean id=&quot;txManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;  &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt;&lt;/bean&gt;&lt;tx:annotation-driven transaction-manager=&quot;txManager&quot;/&gt;</code></pre><p>在需要事务增强的类名上加上注解：@Transactional表示该类下的所有方法都织入事务增强<br>在类中的方法上加上：@Transactional(propagation=Propagation.SUPPORTS)表示只有该方法织入事务增强</p><blockquote><p>注意：注解和配置切面不可以同时使用，否则会报错</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mybatis </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring(二)</title>
      <link href="/2020/04/18/spring-er/"/>
      <url>/2020/04/18/spring-er/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是AOP"><a href="#什么是AOP" class="headerlink" title="什么是AOP"></a><strong>什么是AOP</strong></h2><blockquote><p>AOP是面向切面(Aspect Orinted Programming)编程。是软件编程思想发展到一定程度的产物。是面向对象编程的补充。一般适用于具有横切逻辑的场合，如访问控制，事务管理，性能监控</p></blockquote><h2 id="AOP的特点"><a href="#AOP的特点" class="headerlink" title="AOP的特点"></a><strong>AOP的特点</strong></h2><blockquote><p>能够在不改变原代码的基础上织入新的功能</p></blockquote><h2 id="AOP的使用"><a href="#AOP的使用" class="headerlink" title="AOP的使用"></a><strong>AOP的使用</strong></h2><h3 id="xml配置"><a href="#xml配置" class="headerlink" title="xml配置"></a><em>xml配置</em></h3><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;    xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans         https://www.springframework.org/schema/beans/spring-beans.xsd         http://www.springframweork.org/schema/aop         http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;  &lt;aop:aspectj-autoproxy proxy-target-class=&quot;true&quot;/&gt;&lt;/beans&gt;</code></pre><blockquote><p>和AOP相关的配置都放在&lt;aop:cnofig&gt;标签中</p></blockquote><pre><code>&lt;aop:cnofig&gt;  &lt;aop:pointcut id=&quot;&quot; expression=&quot;execution(public void setUser(cn.jbit.entity.User))&quot;/&gt;&lt;/aop:cnofig&gt;</code></pre><blockquote><p>配置切入点的标签&lt;aop:pointcut&gt;的expression属性可以配置切入点表达式，用来织入与表达式匹配的方法</p></blockquote><pre><code>expression=&quot;expression(public void setUser(User user))&quot;</code></pre><p>expression：切入点标识符，括号中是一个切入点表达式。常用的模糊查询表达式如下：<br>public * setUser(User user)：匹配所有类型的返回值<br><br>public void *(User user)：匹配所有的方法名<br><br>public void setUser(..)：匹配所有的参数个数和类型<br><br> * com.service.*.*(..)：匹配com.service包下的所有类和方法<br><br> * com.service..*.*(..)：匹配com.service包和子包下的所有类和方法<br></p><hr><blockquote><p>将先执行的方法a和后执行的方法b织入</p></blockquote><pre><code>&lt;bean id=&quot;testa&quot; class=&quot;方法a和方法b所在的类路径&quot;/&gt;&lt;aop:config&gt;  &lt;aop:pointcut id=&quot;pointcutTest/切入点id&quot; expression=&quot;execution(public void setUser(cn.jbit.entity.User))&quot;/&gt;  &lt;aop:aspect ref=&quot;testa&quot;&gt;    &lt;!--将方法a作为前置增强并引用需要增强的方法切入点id--&gt;    &lt;aop:before method=&quot;a&quot; pointcut-ref=&quot;pointcutTest&quot;/&gt;    &lt;!--将方法b作为后置增强并引用需要增强的方法切入点id--&gt;    &lt;aop:after-returning method=&quot;b&quot; pointcut-ref=&quot;pointcutTest&quot; returning=&quot;result&quot;/&gt;  &lt;/aop:aspect&gt;&lt;/aop:config&gt;</code></pre><hr><h2 id="AOP常用的增强方式"><a href="#AOP常用的增强方式" class="headerlink" title="AOP常用的增强方式"></a><strong>AOP常用的增强方式</strong></h2><h3 id="异常抛出增强"><a href="#异常抛出增强" class="headerlink" title="异常抛出增强"></a><em>异常抛出增强</em></h3><blockquote><p>特点是在目标抛出异常时，织入增强处理。可为其他异常模块提供统一，可插拔的异常处理方案<br>包含增强方法的JavaBean</p></blockquote><pre><code>pubic class test1{  public void afterThrowing(JoinPoint jp,RuntimeException e){    system.out.print(jp.getSignature().getName()+&quot;方法异常：&quot;+e);  }}</code></pre><p>xml配置如下</p><pre><code>&lt;!--声明增强方法所在的bean--&gt;&lt;bean id=&quot;theLogger&quot; class=&quot;test1路径&quot;/&gt;&lt;!--配置切面--&gt;&lt;aop:config&gt;  &lt;!--定义切入点(需要增强的方法所在)--&gt;  &lt;aop:pointcut id=&quot;&quot; expression=&quot;execution(* server.UserServer.*(..))&quot;/&gt;  &lt;!--引用增强方法--&gt;  &lt;aop:aspect ref=&quot;增强方法的bean&quot;&gt;    &lt;aop:after-throwing method=&quot;增强方法名&quot; pointcut-ref=&quot;切入点id&quot; throwing=&quot;e&quot;/&gt;  &lt;/aop:aspect&gt;&lt;/aop:config&gt;</code></pre><blockquote><p>注意：op:after-throwing标签即为异常增强</p></blockquote><hr><h3 id="最终增强"><a href="#最终增强" class="headerlink" title="最终增强"></a><em>最终增强</em></h3><blockquote><p>最终增强的特点是无论方法是抛出异常还是正常退出，该增强都会执行。类似finally语句块，一般用于释放资源</p></blockquote><p>语法和异常抛出增强基本一致，只需要更改&lt;aop:aspect&gt;标签内的子标签即可</p><pre><code>&lt;aop:after method=&quot;增强方法名&quot; pointcut-ref=&quot;切入点id&quot;/&gt;</code></pre><hr><h3 id="环绕增强"><a href="#环绕增强" class="headerlink" title="环绕增强"></a><em>环绕增强</em></h3><blockquote><p>环绕增强在目标的前后都可以执行织入增强处理。在环绕增强中，可以获取和修改传递的参数，返回值。可以对他进行异常处理，甚至可以决定方法是否被执行</p></blockquote><pre><code>public class test1{  public void testa(ProceedingJoinPoint jp) throws Throwable{    system.out.print(&quot;方法执行前&quot;);    try{      Object result = jp.proceed();//执行方法并获得返回值      return result;    }catch(Throwable e){      system.out.print(&quot;方法异常：&quot;+e);      throw e;    }finally{      system.out.print(&quot;方法执行结束&quot;);    }  }}</code></pre><p>xml配置</p><pre><code>&lt;aop:around method=&quot;增强方法名&quot; pointcut-ref=&quot;切入点id&quot;/&gt;</code></pre><hr><h2 id="使用注解进行操作"><a href="#使用注解进行操作" class="headerlink" title="使用注解进行操作"></a><strong>使用注解进行操作</strong></h2><h2 id="实现控制反转"><a href="#实现控制反转" class="headerlink" title="实现控制反转"></a><em>实现控制反转</em></h2><p>开启注解扫描：</p><pre><code>&lt;context:component-scan base-package=&quot;cn.jbit&quot;/&gt;</code></pre><p>自动扫描带有@Service等注解的文件配置成bean</p><blockquote><p>在需要定义bean的类名上面加上注解即可创建对应的bean。效果等同于：&lt;bean id=”名称” class=”路径”/&gt;<br>注解：</p></blockquote><ul><li>@Repository(“名称”)：用于标注dao类(XXXDao.java)</li><li>@Service(“名称”)：用于标注业务类(XXXServerImpl.java)</li><li>@Controller(“名称”)：用于标注控制器类</li><li>@Component(“名称”)：用于标注控制器类(XXXDaoImpl.java)</li></ul><hr><h3 id="完成属性的装配"><a href="#完成属性的装配" class="headerlink" title="完成属性的装配"></a><em>完成属性的装配</em></h3><p>使用：在需要配置的属性名上面加入注解即可<br></p><pre><code>@Autowired</code></pre><p>该注解自动为属性注入所依赖内容。此时可以省略属性的set方法<br></p><p>如果有一个以上的类型自动匹配时，则可以使用注解指定需要的bean名称<br><br>例：</p><pre><code>@Autowired@Qualifier(&quot;bean名称&quot;)private UserDao userDao;</code></pre><p>也可以直接指定某个bean</p><pre><code>@Rrsource(&quot;&quot;)</code></pre><hr><h3 id="使用注解配置的xml"><a href="#使用注解配置的xml" class="headerlink" title="使用注解配置的xml"></a><em>使用注解配置的xml</em></h3><p>使用注解即可为指定特定的名称的bean注入属性</p><pre><code>@Resource(name=&quot;name&quot;)</code></pre><p>如果没有指定name，只是@Resource。则会自动匹配与属性名相同的bean注入</p><hr><h4 id="配置切面"><a href="#配置切面" class="headerlink" title="配置切面"></a><strong>配置切面</strong></h4><p>配置xml文件</p><pre><code>&lt;bean class=&quot;切面所在的路径&quot;/&gt;&lt;aop:aspectj-autoproxy/&gt;</code></pre><ol><li>使用@Aspect注解在类上添加切面</li><li>使用@Before(“execution(* cn.jbit.dao..*(..))”)将方法定义为切面增强方法</li><li>@Before为前值增强，@AfterReturning(pointcut = “execution(* cn.jbit.dao..*(..))”, returning = “returnValue”)为后置增强。returning为方法接收的返回值名称。如String a则为returning = “a”<blockquote><p>如果多个方法需要匹配同一个表达式，则可以简化。</p></blockquote></li></ol><p>如前置增强和后置增强都需要匹配dao包和其子包(execution(* cn.jbit.dao..*(..))，则可以</p><pre><code>@Pointcut(&quot;execution(* cn.jbit.dao..*(..)&quot;)public void test(){}@Before(&quot; test()&quot;)public void before(){  //前值增强}@AfterReturning(pointcut = &quot;test()&quot;, returning = &quot;a&quot;)public void aterReturning(Object a){  //后置增强}</code></pre><hr><h4 id="配置增强类型"><a href="#配置增强类型" class="headerlink" title="配置增强类型"></a><strong>配置增强类型</strong></h4><p>异常增强：</p><pre><code>@AfterThrowing(pointcut = &quot;test()&quot; , throwing = &quot;e&quot;)public void afterThrowing(RuntimeException e){  //异常增强}</code></pre><p>最终增强：</p><pre><code>@After(&quot;test()&quot;)</code></pre><p>环绕增强：</p><pre><code>@Around(&quot;test()&quot;)public void around(ProceedingJoinPoint jp){  //调用方法：jp,getSignature().getName();  //传入参数：Arrays.toString(jp.getArgs);  Object obj = jp.proceed();//执行方法并返回返回值}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> AOP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Oracle(三)</title>
      <link href="/2020/04/17/oracle-san/"/>
      <url>/2020/04/17/oracle-san/</url>
      
        <content type="html"><![CDATA[<h2 id="使用PL-SQL的好处"><a href="#使用PL-SQL的好处" class="headerlink" title="使用PL/SQL的好处"></a>使用PL/SQL的好处</h2><ol><li>具有编程语言的特点。能把一组sql语句放到一个模块中。使其更具有模块化程序的特点。</li><li>可采用过程性语言控制程序的结构。可以增加逻辑判断，如判断，循环等</li><li>可对程序中的错误进行自行处理。使程序遇见错误时不会立即中断</li><li>具有更好的可以执行，可移植到另一个oracle数据库中</li><li>减少了网络的交互，有助于提高程序性能</li></ol><hr><h2 id="PL-SQL结构"><a href="#PL-SQL结构" class="headerlink" title="PL/SQL结构"></a>PL/SQL结构</h2><pre><code>[declare]--声明部分：在此声明PL/SQL用到的变量，类型及游标。以及局部的存储过程和函数begin--执行部分：过程以及sql语句，程序的主要部分[exception]--异常处理部分：错误处理end;--注意：执行部分不能省略</code></pre><hr><h2 id="运算符关系表达式"><a href="#运算符关系表达式" class="headerlink" title="运算符关系表达式"></a><strong>运算符关系表达式</strong></h2><center>一般运算符</center><table><thead><tr><th align="center">运算符</th><th align="center">意义</th></tr></thead><tbody><tr><td align="center">=</td><td align="center">等于</td></tr><tr><td align="center">&lt;&gt;,!=,~-,^=</td><td align="center">不等于</td></tr><tr><td align="center">&lt;</td><td align="center">小于</td></tr><tr><td align="center">&gt;</td><td align="center">大于</td></tr><tr><td align="center">&lt;=</td><td align="center">小于等于</td></tr><tr><td align="center">&gt;=</td><td align="center">大于等于</td></tr><tr><td align="center">+</td><td align="center">加</td></tr><tr><td align="center">-</td><td align="center">减</td></tr><tr><td align="center">*</td><td align="center">乘</td></tr><tr><td align="center">/</td><td align="center">除</td></tr><tr><td align="center">:=</td><td align="center">赋值</td></tr><tr><td align="center">=&gt;</td><td align="center">关系号</td></tr><tr><td align="center">..</td><td align="center">范围运算符</td></tr><tr><td align="center">||</td><td align="center">字符连接符</td></tr></tbody></table><center>逻辑运算符</center><table><thead><tr><th align="center">运算符</th><th align="center">意义</th></tr></thead><tbody><tr><td align="center">is null</td><td align="center">是空值</td></tr><tr><td align="center">between and</td><td align="center">介于两者之间</td></tr><tr><td align="center">in</td><td align="center">在一列键值中</td></tr><tr><td align="center">and</td><td align="center">与</td></tr><tr><td align="center">or</td><td align="center">或者</td></tr><tr><td align="center">not</td><td align="center">取反值</td></tr></tbody></table><hr><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a><strong>数据类型</strong></h2><h3 id="变量的声明"><a href="#变量的声明" class="headerlink" title="变量的声明"></a><em>变量的声明</em></h3><pre><code>variable_name data_type[(size)][:=init_value];</code></pre><ul><li>variable_name：变量名</li><li>data_type：变量的sql或PL/SQL数据类型</li><li>size：变量的范围</li><li>init_value：初始变量值</li></ul><hr><h3 id="常量的声明"><a href="#常量的声明" class="headerlink" title="常量的声明"></a><em>常量的声明</em></h3><pre><code>variable_name constant data_type[:=init_value];</code></pre><hr><h3 id="常量和变量的声明和赋值"><a href="#常量和变量的声明和赋值" class="headerlink" title="常量和变量的声明和赋值"></a><em>常量和变量的声明和赋值</em></h3><pre><code>declare     --声明变量和赋值常量    v_ename varcahr2(20);    c_rate_incr constant number(8) := 10;    --常量begin    --执行部分    v_ename := ‘test’;end;</code></pre><hr><h3 id="PL-SQL数据类型"><a href="#PL-SQL数据类型" class="headerlink" title="PL/SQL数据类型"></a><em>PL/SQL数据类型</em></h3><blockquote><p>按数据类型可分为：标量数据类型，LOB数据类型，属性类型</p></blockquote><blockquote><p>标量数据类型：和oracle数据类型类似，只是数据长度有所变化。同时新增了boolean数据类型，boolean的值可为：true,false,null</p></blockquote><blockquote><p>LOB数据类型：用于存储大的数据对象。主要支持：bfile,blob,clob,nclob</p></blockquote><blockquote><p>属性类型：用于引用变量或数据库列的数据类型，以及表示表中一行的数据类型。如%type,%rowtype</p></blockquote><ul><li><p>%type：定义一个变量时如果数据类型和已创建的变量(尤其是表的某一列)数据类型一致时可使用。<br><br>优点：</p><ol><li>可以不必知道引用的数据类型</li><li>引用的数据类型改变时可以同时改变，容易保持一致。不用修改程序</li></ol></li><li><p>%rowtype：返回一个数据类型。如果数据类型和数据库表的数据结构一致，可使用。<br><br>优点：</p><ol><li>可以不必知道所引用的数据库中列的个数和数据类型</li><li>所引用的列的个数和数据类型可改变。容易保持一致<blockquote><p>使用语法 </p></blockquote></li></ol></li></ul><pre><code>--v_name的数据类型是tableUser表的id列数据类型v_name tableUser.id%type := 10;--将表的一行数据类型赋值给v_rec。可以v_rec tableUser%rowtype;</code></pre><hr><h2 id="控制语句"><a href="#控制语句" class="headerlink" title="控制语句"></a><strong>控制语句</strong></h2><blockquote><p>控制语句又可分为：条件控制，循环控制，顺序控制</p></blockquote><h3 id="条件控制"><a href="#条件控制" class="headerlink" title="条件控制"></a><em>条件控制</em></h3><blockquote><p> 包括if语句和case语句</p></blockquote><h4 id="if语法"><a href="#if语法" class="headerlink" title="if语法"></a>if语法</h4><pre><code>if&lt;布尔表达式&gt; then     PL/SQL和SQL语句end if;</code></pre><pre><code>if&lt;布尔表达式&gt; then     PL/SQL和SQL语句else     其他语句end if;</code></pre><pre><code>if&lt;布尔表达式&gt; then     PL/SQL和SQL语句elsif &lt;布尔表达式&gt; then    其他语句else     其他语句end if;</code></pre><h4 id="case语法"><a href="#case语法" class="headerlink" title="case语法"></a>case语法</h4><pre><code>case 条件表达式    when 条件表达式结果1 then        语句1    when 条件表达式结果2 then         语句2    [else 语句段]end case;</code></pre><pre><code>case     when 条件表达式1 then        语句1    when 条件表达式2 then         语句2    [else 语句段]end case;</code></pre><hr><h3 id="循环控制"><a href="#循环控制" class="headerlink" title="循环控制"></a><em>循环控制</em></h3><blockquote><p>用于重复执行一系列语句，包括loop，while，for</p></blockquote><h4 id="loop语法"><a href="#loop语法" class="headerlink" title="loop语法"></a>loop语法</h4><pre><code>loop    要执行的语句    exit when&lt;条件语句&gt; --条件满足退出循环end loop;</code></pre><h4 id="while语法"><a href="#while语法" class="headerlink" title="while语法"></a>while语法</h4><pre><code>while &lt;布尔表达式&gt; loop    要执行的语句end loop;</code></pre><h4 id="for语法"><a href="#for语法" class="headerlink" title="for语法"></a>for语法</h4><pre><code>for循环计数器 in [reverse] 下限...上限 loop    执行的语句end loop;</code></pre><hr><h3 id="顺序控制"><a href="#顺序控制" class="headerlink" title="顺序控制"></a><em>顺序控制</em></h3><p>null语句：是一个可执行语句。相当于一个占位符或不执行任何操作的空语句</p><blockquote><p>例：如果在if else语句里。如果值给else语句块添加sql语句，if语句块不写内容则会报语法错误。这时候就需要在if语句块里加入null</p></blockquote><pre><code>if v_id=1 then    null;--如果删除null会报语法错误else    dbms_output.put_line(‘’)end if;</code></pre><hr><h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a><strong>异常处理</strong></h2><blockquote><p>异常类型可大概分为：预定义异常，非预定义异常，用户自定义异常</p></blockquote><h3 id="预定义异常"><a href="#预定义异常" class="headerlink" title="预定义异常"></a><em>预定义异常</em></h3><pre><code>beginexception     when &lt;exception_name&gt; then        sequence_of_statements;    when others then    --其他异常        sequence_of_statements;    end;</code></pre><hr><h3 id="用户自定义异常"><a href="#用户自定义异常" class="headerlink" title="用户自定义异常"></a><em>用户自定义异常</em></h3><blockquote><p>在定义部分定义异常情况</p></blockquote><pre><code>declare    &lt;异常名称&gt; exception;</code></pre><blockquote><p>在执行部分抛出异常</p></blockquote><pre><code>begin    raise &lt;异常名称&gt;</code></pre><blockquote><p>在异常处理部分接收异常</p></blockquote><pre><code>exception    when &lt;异常名称&gt; then    dbms_output.put_line(‘错误类型：’||sqlcode||sqlerrm)</code></pre><hr><h3 id="自定义错误信息"><a href="#自定义错误信息" class="headerlink" title="自定义错误信息"></a><em>自定义错误信息</em></h3><pre><code>raise_application_error(error_name,error_message);</code></pre><blockquote><p>error_name：异常编号。编号必须为-20999~-20000之间的负整数<br>error_message：异常消息文本。长度可达2048字节<br>注意：该自定义错误信息直接写在执行部分即可</p></blockquote><hr><h2 id="游标"><a href="#游标" class="headerlink" title="游标"></a><strong>游标</strong></h2><h3 id="什么是游标"><a href="#什么是游标" class="headerlink" title="什么是游标"></a><strong>什么是游标</strong></h3><blockquote><p>游标是系统为用户开设的一个数据缓冲区，存放sql语句的执行结果。在执行一个有增删改查的PL/SQL块时，oracle会在内存中分配一个缓冲区，将执行结果放在这个缓冲区中。而游标是指向该缓冲区的一个指针</p></blockquote><h3 id="游标分类"><a href="#游标分类" class="headerlink" title="游标分类"></a><strong>游标分类</strong></h3><blockquote><p>在Oracle中，游标可分为：静态游标和动态游标。静态游标是在编译时知道明确的select语句的游标。静态游标又分为隐式游标和显式游标</p></blockquote><h3 id="显式游标"><a href="#显式游标" class="headerlink" title="显式游标"></a><em>显式游标</em></h3><pre><code>cursor cursor_name [(parameter[,parameter]...)][return return_type] is select statement;</code></pre><ul><li>cursor_name：游标名称</li><li>parameter：指定输入参数，不能输入参数长度，例如varchar2(200)</li><li>return_type：定义提取的行的类型</li><li>select statement：查询语句</li></ul><p>打开游标：</p><pre><code>open cursor_name[(parameter)]</code></pre><p>提取游标：</p><pre><code>fetch cursor_name into variables;</code></pre><ul><li>variables：变量名,该方法是将读取出来的内容存放在变量内</li></ul><hr><p>关闭游标：</p><pre><code>close cursor_name;</code></pre><p>示例：</p><pre><code>declare--根据列的类型创建变量    v_name scott.students.stu_name%type;    v_id scott.students.stu_id%type;--创建游标    cursor students_cursor is select stu_name,stu_id from scott.students;begin    --开启游标    open students_cursor;    --循环遍历游标的值    loop    --将单次遍历出来的值存储到变量内    fetch students_cursor into v_name,v_id;        exit when students_cursor%notfound;            DBMS_OUTPUT.put_line(&#39;第&#39;||students_cursor%rowcount||&#39;个用户&#39;||v_name||v_id);    end loop;    --关闭游标    close students_cursor;end;</code></pre><p>显示游标属性：</p><ul><li>%found：只有DML语句影响一行或多行的时候才返回true</li><li>%notfound：如果DML语句没有影响行则返回true</li><li>%rowcount：返回DML影响的行数</li><li>%isopen：返回游标是否已打开<br>使用显示游标更新</li></ul><pre><code>--在声明部分锁定需要修改的表cursor cursor_name is select_statement for update[of columns];</code></pre><ul><li>cursor_name：名称</li><li>select_statement：修改的表查询语句</li><li>of：列名，写上要修改的表的列名<blockquote><p>注意：如果是单表查询就不需要写of<br>在使用for update子句声明游标后使用下列语法更新行</p></blockquote></li></ul><pre><code>update table_name set column_name = column_value where current of cursor_name;</code></pre><ul><li>cursor_name：游标名<blockquote><p>注意：使用前先打开游标，然后通过loop循环修改值</p></blockquote></li></ul><hr><h3 id="循环游标"><a href="#循环游标" class="headerlink" title="循环游标"></a><em>循环游标</em></h3><blockquote><blockquote><p>可简化显示游标的处理代码。循环游标隐式打开游标，自动从活动集获取行，在处理完后自动关闭游标。循环游标自动创建%rowtype类型的变量用作记录索引。</p></blockquote></blockquote><pre><code>--语法for record_index in cursor_name loop     executable_statementsend loop;--示例for table_index in cursor_test loop    cursor_test.nameend loop;</code></pre><ul><li>record_index：是PL/SQL声明的记录变量此变量的属性声明为%rowtype类型。作用域在for循环内。</li><li>cursor_name：游标名</li></ul><blockquote><p>该游标有如下特性：</p></blockquote><ol><li>从游标提取了所有记录之后自动终止</li><li>提取和处理游标中的每一条记录</li><li>如果提取记录之后%notfound返回true则循环终止</li><li>如未有返回行则不进入循环<blockquote><p>no_data_found和%notfound的区别</p></blockquote></li><li>select … into 语句返回0条和多条记录时触发no_data_found</li><li>当update或delete语句的where未找到时触发%notfound</li><li>在提取循环中用%notfound或%found来确定循环的退出条件，而不用no_data_found</li></ol><hr><h2 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a><strong>存储过程</strong></h2><h3 id="子程序的组成"><a href="#子程序的组成" class="headerlink" title="子程序的组成"></a>子程序的组成</h3><p>子程序是已命名的PL/SQL块，存储在数据库中。可以在任何数据库客户端和应用程序中调用。</p><ul><li><p>声明部分</p><ul><li>包括类型，游标，常量，变量，异常和嵌套子程序的声明。退出子程序后将不存在。</li></ul></li><li><p>可执行部分</p><ul><li>包括赋值，控制执行过程和操纵oracle语句。</li></ul></li><li><p>异常处理部分</p><ul><li>包括异常处理程序。负责处理存储过程中的异常</li></ul><hr></li></ul><p>优点</p><ol><li>模块化(可将程序分解为可管理的，明确的逻辑模块)</li><li>可重用性(子程序在创建并执行后可在任意数量的应用程序中执行)</li><li>可维护性(可简化维护操作。)<br>安全性(用户可设置权限。这样不仅使数据更安全，而且可以保证)</li></ol><hr><h3 id="存储过程的用法"><a href="#存储过程的用法" class="headerlink" title="存储过程的用法"></a><em>存储过程的用法</em></h3><blockquote><p>创建存储过程</p></blockquote><pre><code>--语法create [or replace] procedure procedure_name    [(procedure_list)]{is|as}    [local_declarations]begin    executable_statement    [exception]    [exception_handlers]    end [procedure_name];--示例create or replace procedure add_student(    id student.id&amp;type,                        --输入参数，id    name student.name&amp;type default ‘张三’;    --输入参数，姓名。默认为张三    stu_date student.stu_date&amp;type;            --输入参数，时间)isbegin    insert into student values(id,name,stu_date);end;</code></pre><ul><li>procedure_name：存储过程的名称</li><li>procedure_list：参数列表，可选</li><li>local_declarations：局部声明，可选</li><li>executable_statement：可执行语句</li><li>exception_handlers：异常处理，可选</li><li>or replace：可选，如果不包含这个表示创建新的一个存储过程。如果已存在该存储过程则会报错。如果包含这个则表示如果系统中没有则创建新的存储过程。如果有则替换原来的存储过程<blockquote><p>调用存储过程</p></blockquote></li></ul><pre><code>exec[ute] procedure_name (procedure_list)</code></pre><ul><li>execute：执行命令，可简写成exec</li><li>procedure_name：存储空间名称</li><li>procedure_list：传递的参数<blockquote><p>注意：传递参数可按默认顺序传递，也可以用名称传递和混合传递。名称传递：exec add_student (id=&gt;10,name=&gt;’张三’,stu_date=&gt;’2019-01-01’)</p></blockquote></li></ul><h3 id="在PL-SQL调用存储过程"><a href="#在PL-SQL调用存储过程" class="headerlink" title="在PL/SQL调用存储过程"></a><em>在PL/SQL调用存储过程</em></h3><p>直接使用名称调用即可。注意参数的传递。传递方式和sql一样，分为默认传递，名称传递，混合传递。<br>    注意：使用混合传递时，第一个使用名称传递的列后面的所有列都需要使用名称传递</p><blockquote><p>存储过程的参数模式</p></blockquote><p>调用程序是通过参数向被调用的存储过程传递参数的传递的方式分为三种：in，out，in out即输入参数，输入参数，输入/输出参数<br>在创建参数的时候在参数名后面加上传递方式即可改变参数模式</p><blockquote><p>存储过程的访问权限</p></blockquote><p>由于创建存储过程后只有创建的用户或者管理员才能使用。所有如果其他人需要使用的话必须获得execute权限<br>授予权限</p><pre><code>grant execute on procedure_name to user/public</code></pre><ul><li>procedure_name：需要授权的存储过程名称</li><li>user/public：需要授权的用户。或者所有人都可以访问</li></ul><p>撤销权限</p><pre><code>revoke execute on procedure_name from user</code></pre><blockquote><p>删除存储过程</p></blockquote><pre><code>drop procedure procedure_name</code></pre><hr><h3 id="存储过程规则"><a href="#存储过程规则" class="headerlink" title="存储过程规则"></a><em>存储过程规则</em></h3><ol><li>存储过程中不可用直接使用DDL语句。可以通过动态sql实现，但不建议频繁的使用DDL语句</li><li>存储过程必须有相应的出错处理功能</li><li>存储过程中在引用表字段时需要使用%type和%rowtype</li><li>必须在存储过程中做异常捕获。并将异常信息通过os_Msg输出</li><li>-19999~-1的异常为Oracle定义的异常代码</li><li>存储过程必须包含两个输出参数，即on_Flag(number)和os_Msg(varchar2)分别用于标识过程的执行状态和提示信息(包括异常状态下的异常信息)其中on_Flag包含三种取值情况：0标识执行成功但无提示；大于0表示执行成功且有提示；小于0表示执行失败并有提示</li><li>when others必须放在异常处理代码的最后。最为默认处理器没有显示处理的异常</li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Oracle </tag>
            
            <tag> PL/SQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Oracle(二)</title>
      <link href="/2020/03/28/oracle-er/"/>
      <url>/2020/03/28/oracle-er/</url>
      
        <content type="html"><![CDATA[<h2 id="表空间"><a href="#表空间" class="headerlink" title="表空间"></a><strong>表空间</strong></h2><h3 id="表空间的作用"><a href="#表空间的作用" class="headerlink" title="表空间的作用"></a><em>表空间的作用</em></h3><ol><li>对不同用户分配不同的表空间，不同的对象模式分配不同的表空间。方便对用户数据的操纵，对象模式的管理</li><li>可以将不懂的数据文件存放在不同的磁盘中，有利于提高I/O的性能以及有利于备份和恢复数据等</li></ol><hr><h3 id="表空间的分类"><a href="#表空间的分类" class="headerlink" title="表空间的分类"></a><em>表空间的分类</em></h3><center>表空间的分类</center><table><thead><tr><th align="center">类别</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">永久性表空间</td><td align="center">一般保存表，视图，过程和索引等数据。system,sysaux,users(默认),exampe</td></tr><tr><td align="center">临时表空间</td><td align="center">保存系统中短期存在的数据，如排序数据等</td></tr><tr><td align="center">撤销表空间</td><td align="center">用来帮助回退未提交的事务数据，已提交了的数据是不可以恢复的。一般不需要搭建临时和撤销表空间。除非把他们移动到磁盘中提高性能。</td></tr></tbody></table><hr><h3 id="创建表空间"><a href="#创建表空间" class="headerlink" title="创建表空间"></a><em>创建表空间</em></h3><pre><code>--语法create tablespace tabledatafile ‘filename&#39; [ size integer[K|M]][autoextend[off|no]];--实例create tablespace testTabledatafile ‘d:\file\tabTest\a.DBF&#39; size 10M autoextend no;</code></pre><ul><li>table<ul><li>表空间名称</li></ul></li><li>datafile <ul><li>指定组成表空间的一个或多个数据文件。当有多个数据文件时用’，’分隔</li></ul></li><li>filename<ul><li>文件路径和名称</li></ul></li><li>size<ul><li>文件大小。用K指定千字节大小，M指定兆字节大小</li></ul></li><li>autoextend<ul><li>用来启动或禁止数据文件的自动扩展。使用off时会禁用自动扩展。当表空间剩余容量为0时会使数据不能存储到数据库中</li></ul></li></ul><hr><h3 id="删除表空间"><a href="#删除表空间" class="headerlink" title="删除表空间"></a><em>删除表空间</em></h3><pre><code>drop tablespace table_name including contents and datafile;  --删除前最好对数据库备份</code></pre><ul><li>table_name<ul><li>需要删除的表空间名称</li></ul></li></ul><hr><h2 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a><strong>用户管理</strong></h2><h3 id="创建新用户"><a href="#创建新用户" class="headerlink" title="创建新用户"></a><em>创建新用户</em></h3><blockquote><p>每个新用户创建时都会有一个默认表空间和一个临时表空间，如果没有指定，users为默认表空间，temp为临时表空间</p></blockquote><pre><code>--语法create user testUserIDENTIFIED BY passWord[default tablespace tabName][temporary tablespace tab]--实例create user SchemingCatIDENTIFIED BY abcddefault tablespace worktbstemporary tablespace temp</code></pre><ul><li>testUser<ul><li>用户名</li></ul></li><li>passWord<ul><li>用户登录密码</li></ul></li><li>tabName<ul><li>默认表空间</li></ul></li><li>tab<ul><li>临时表空间<blockquote><blockquote><p>注意：如果创建的用户无法登陆，则需要授权create session权限（登陆权限）。如果需要建表则根据需求给与connect（临时用户）或resource（正式用户）</p></blockquote></blockquote></li></ul></li></ul><hr><h3 id="修改用户名密码"><a href="#修改用户名密码" class="headerlink" title="修改用户名密码"></a><em>修改用户名密码</em></h3><pre><code>--语法alter user testUser identified by pwd</code></pre><ul><li>testUser<ul><li>修改的用户</li></ul></li><li>pwd<ul><li>修改的密码</li></ul></li></ul><hr><h3 id="删除用户"><a href="#删除用户" class="headerlink" title="删除用户"></a><em>删除用户</em></h3><pre><code>--语法drop user testUser</code></pre><ul><li>testUser<ul><li>删除的用户</li></ul></li></ul><hr><h2 id="数据库权限"><a href="#数据库权限" class="headerlink" title="数据库权限"></a><strong>数据库权限</strong></h2><blockquote><p>可分为系统权限和对象权限</p></blockquote><h3 id="系统权限"><a href="#系统权限" class="headerlink" title="系统权限"></a><em>系统权限</em></h3><blockquote><p>可以在系统中执行的特定操作。如创建表，创建表空间等都属于系统权限<br>常见权限如下：</p></blockquote><ul><li>create session<ul><li>连接到数据库</li></ul></li><li>create table<ul><li>创建表</li></ul></li><li>create view<ul><li>创建视图</li></ul></li><li>create sequence<ul><li>创建序列</li></ul></li></ul><hr><h3 id="对象权限"><a href="#对象权限" class="headerlink" title="对象权限"></a><em>对象权限</em></h3><blockquote><p>用户可访问和操纵的特定对象。可以通过赋予用户某个特殊的对象来获得某个对象的管理权限，对视图，序列，存储过程，如对某张表的增删改查等</p></blockquote><p>获取权限的两种路径：1. 管理员直接向用户授予权限；2. 管理员将权限授权给角色，然后将角色授予一个或多个用户</p><blockquote><p>为了高效实用，通常是将角色授予用户。其中常用的有：connect，resource，dba等。一般只授予connect和resource。因为dba有所有的系统权限，可以给其他用户，角色授予权限</p></blockquote><p>常用的系统预订角色</p><ul><li>connect<ul><li>需要连接上数据库的用户，特别是不需要创建表的用户</li></ul></li><li>resource<ul><li>更加可靠和正式的数据库用户都能授予该角色，可以创建表，触发器，过程等</li></ul></li><li>dba<ul><li>数据库管理员角色，拥有数据库最高权限，拥有dba角色的用户可以撤销其他用户甚至dba的权限</li></ul></li></ul><hr><pre><code>--授予语法grant 权限|角色 to 用户--授予某张表的权限grant insert[,update][,select][,delete] on 表 to 用户--取消授权revoke 权限|角色 from 用户</code></pre><blockquote><p>如果要授予或取消多个权限/角色则需要用’，’将其分隔</p></blockquote><hr><h2 id="序列"><a href="#序列" class="headerlink" title="序列"></a><strong>序列</strong></h2><h3 id="什么是序列"><a href="#什么是序列" class="headerlink" title="什么是序列"></a><em>什么是序列</em></h3><blockquote><p>序列用来生成唯一，连续的整数的数据库对象。序列可按升序或降序排列</p></blockquote><hr><h3 id="序列的创建"><a href="#序列的创建" class="headerlink" title="序列的创建"></a><em>序列的创建</em></h3><pre><code>--语法create sequence sequence_name[start with integer][increment by integer][maxvalue integer|nomaxvalue][minvalue integer|nominvalue][cycle|nocycle][cache integer|nocache]--实例create sequence namestart with 1increment by 1maxvalue 100cyclecache 20--这组序列的意思是生成一个叫name的序列，从1开始生成，每次序列增加1。序列最多生成到100。序列生成到100后再次从1开始循环生成。缓存20个序列号</code></pre><ul><li>start with<ul><li>指定生成的第一个序列号，对于升序代表的意思是数字开始的最小值，对于降序的意思是数字的最大值</li></ul></li><li>increment by<ul><li>定序号之间的间隔，默认为1。如果n为正数，则为升序，如果n为负数，则为降序</li></ul></li><li>maxvalue/nomaxvalue<ul><li>序列可生成的最大值/如果指定nomaxvalue，升序的默认最大值为10的27次方，降序的最大值为-1</li></ul></li><li>minvalue/nominvalue<ul><li>序列的最小值。minvalue必须小于等于start with。并且必须小于maxvalue/如果指定了nominvalue，升序的最小值为1，降序的最小值为-1026。这是默认值</li></ul></li><li>cycle/nocycle<ul><li>序列在达到最小值或最大值后将从头开始生成/序列达到最小值或最大之后将不再重头开始。这是默认值</li></ul></li><li>cache/nocache<ul><li>可预先分配一组序号。并保留在内存中，这样可以更快的访问序列号。当用完缓存中的所有序列号时，将重新生成一组序列号放在缓存中/不会预先生成序列号。如果创建时忽略了cache integer|nocache则会默认生成并缓存20个序列号</li></ul></li></ul><hr><h3 id="访问序列"><a href="#访问序列" class="headerlink" title="访问序列"></a><em>访问序列</em></h3><blockquote><p>通过nextval和currval伪列爱访问该序列的值。可以从伪列中选择值，但不能修改值。</p></blockquote><ul><li>nextval<ul><li>返回序列下一个值。当第一次使用时，将返回序列的初始值。在下次引用时，自动使用increment by来增加序列值，并返回新值</li></ul></li><li>currval<ul><li>返回序列当前值，即最后一次引用nextval时返回的值。</li></ul></li></ul><hr><h3 id="更改序列"><a href="#更改序列" class="headerlink" title="更改序列"></a><em>更改序列</em></h3><pre><code>--语法alter sequence [schema.]name[increment by integer][maxvalue integer|nomaxvalue][minvalue integer|nominvalue][cycle|nocycle][cache integer|nocache]</code></pre><ul><li>schema<ul><li>如果不是创建序列的用户修改序列则需要加上创建的用户</li></ul></li></ul><hr><h3 id="删除序列"><a href="#删除序列" class="headerlink" title="删除序列"></a><em>删除序列</em></h3><pre><code>--语法drop sequence [schema.]name</code></pre><hr><h3 id="使用序列"><a href="#使用序列" class="headerlink" title="使用序列"></a><em>使用序列</em></h3><blockquote><p>序列生成的数值只能保证在单个对象里实例是唯一的，所以不适合<strong>并行</strong>或<strong>远程环境</strong>里的主关键字。因为各个环境的序列肯能会生成相同的数字，从而导致<strong>冲突</strong>的发生。所以在不需要并行的环境中可以选择序列作为主关键字<br><br>可以使用sys_guid()函数生成32位唯一编码作为主键，适用于并行环境开发</p></blockquote><pre><code>--使用自增长的序列作为主键insert into user values(name.nextval,&#39;张三&#39;,18)</code></pre><blockquote><blockquote><p>注意：在迁移数据库的时候需要注意时。由于迁移后表中已存在数据，所以需要修改序列的初始值，否则会插入重复的数据</p></blockquote></blockquote><hr><h2 id="同义词"><a href="#同义词" class="headerlink" title="同义词"></a><strong>同义词</strong></h2><h3 id="同义词的用途"><a href="#同义词的用途" class="headerlink" title="同义词的用途"></a><em>同义词的用途</em></h3><ol><li>简化sql语句</li><li>隐藏对象名称和持有者</li><li>为分布式数据库的远程对象提供了位置透明性</li><li>提供对对象的公共访问<blockquote><p>注意：访问公共同义词必须经过授权：create select on 同义词名称 to public</p></blockquote></li></ol><hr><h3 id="同义词的分类"><a href="#同义词的分类" class="headerlink" title="同义词的分类"></a><em>同义词的分类</em></h3><blockquote><p>同义词分为私有同义词和公有同义词</p></blockquote><h4 id="私有同义词"><a href="#私有同义词" class="headerlink" title="私有同义词"></a>私有同义词</h4><blockquote><p>只能被当前模式的用户访问。且私有同义词不可以当前模式的对象名称相同。要在当前模式下创建私有同义词，用户必须拥有create synonym系统权限。要在其他用户模式下创建私有同义词，用户必须拥有create any synonym系统权限</p></blockquote><pre><code>--语法create [or replace] synonym [schema.]namefor [schema.]object_name--实例create synonym namefor objName</code></pre><ul><li>or replace<ul><li>表示在同义词存在的情况下替换该同义词</li></ul></li><li>name<ul><li>同义词名称</li></ul></li><li>object_name<ul><li>创建同义词的对象名称</li></ul></li></ul><blockquote><p>使用时直接使用同义词即可。例：select * from objName等于select * from name</p></blockquote><h4 id="公有同义词"><a href="#公有同义词" class="headerlink" title="公有同义词"></a>公有同义词</h4><blockquote><p>可被所有数据库用户访问。创建公有有同义词需要有create public synonym权限</p></blockquote><pre><code>--语法create [or replace] public synonym namefor [schema.]object_name</code></pre><p>公有同义词和私有同义词的区别：</p><ol><li>私有同义词只能在当前模式下访问，且名称不能和当前模式的用户同名。公有同义词可被所有用户访问</li><li>如对象和公有同义词重名时，默认调用对象。当私有同义词和公有同义词重名时默认调用私有同义词</li></ol><hr><h3 id="删除同义词"><a href="#删除同义词" class="headerlink" title="删除同义词"></a><em>删除同义词</em></h3><pre><code>--语法drop [public] synonym [schema.]name</code></pre><p>注意：删除公有同义词时需要加上public</p><hr><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a><strong>索引</strong></h2><h3 id="什么是索引"><a href="#什么是索引" class="headerlink" title="什么是索引"></a><em>什么是索引</em></h3><blockquote><p>索引是与表关联的可选结构。是一种快速访问数据的途径。可提高数据库性能</p></blockquote><hr><h3 id="索引的分类"><a href="#索引的分类" class="headerlink" title="索引的分类"></a><em>索引的分类</em></h3><table><thead><tr><th align="center">物理分类</th><th align="center">逻辑分类</th></tr></thead><tbody><tr><td align="center">分区或非分区索引</td><td align="center">单例或组合索引</td></tr><tr><td align="center">B树索引（标准索引/默认）</td><td align="center">唯一或非唯一索引</td></tr><tr><td align="center">正常或反向键索引</td><td align="center">基于函数索引</td></tr><tr><td align="center">图位索引</td><td align="center"></td></tr></tbody></table><hr><h4 id="B树索引"><a href="#B树索引" class="headerlink" title="B树索引"></a>B树索引</h4><blockquote><p>B树索引也称为标准索引</p></blockquote><pre><code>create [unique] index index_name on table_name(column_list) [tablespace tablespace_name]</code></pre><ul><li>unique<ul><li>指定唯一索引，默认情况下非唯一索引</li></ul></li><li>index_name<ul><li>索引名称</li></ul></li><li>table_name<ul><li>创建索引的表名</li></ul></li><li>column_list<ul><li>创建索引的列名的列表。可以创建多列，用’，’分隔</li></ul></li><li>tablespace_name<ul><li>为索引指定表空间</li></ul></li></ul><blockquote><p>唯一索引：索引的列中任意两行都没有重复值。索引的关键字只能指向表中的一行。创建主键约束和唯一约束时会创建与之对应的唯一索引</p></blockquote><blockquote><p>非唯一索引：单个关键字可以有多个与之关联的行</p></blockquote><hr><h4 id="反向键索引"><a href="#反向键索引" class="headerlink" title="反向键索引"></a>反向键索引</h4><p>优点</p><ol><li>将索引数据分散在多个索引块中</li><li>减少I/O瓶颈的发生<blockquote><p>反向键索引在保持顺序的情况下同时反转索引列的字节。反向键索引通过翻转索引键的数据值来实现</p></blockquote></li></ol><pre><code>create index index_name_keyName on tabName(keyName) reverse</code></pre><ul><li>index_name_keyName<ul><li>索引名</li></ul></li><li>keyName<ul><li>列名</li></ul></li></ul><pre><code>--主键创建反向键索引alter table tabName add constraint keyName primapt key(keyName) using index index_name_keyName</code></pre><hr><h4 id="位图索引"><a href="#位图索引" class="headerlink" title="位图索引"></a>位图索引</h4><p>优点</p><ol><li>最适于低基数列(即列的值是优先的，理论上不会无穷大的)。例如性别，只会有男，女。不会有更多的类型</li><li>对于大批即时查询，可以减少响应的时间</li><li>相比其他索引技术，占用空间明显减少</li><li>即使在配置很低的终端硬件上时，也能获得显著的性能<blockquote><p>注意：位图索引不应用在频繁发生insert，update，delete操作的表上。最适于数据仓库和决策支持系统</p></blockquote></li></ol><pre><code>--语法create bitmap index index_bit_job on tableName(keyName);</code></pre><hr><h4 id="其他索引"><a href="#其他索引" class="headerlink" title="其他索引"></a>其他索引</h4><blockquote><p>组合索引：在表内多列上创建索引<br><br>基于函数的索引：若使用的函数或表达式涉及正在索引的表中的一列或多列，则创建基于函数的索引。可以改为B数索引或位图索引</p></blockquote><pre><code>--语法create index index_name on tabName(upper(keyName))</code></pre><blockquote><p>注意：创建组合索引时将唯一性高(该列放的大部分数据时唯一的)的列放在第一位</p></blockquote><hr><h3 id="创建索引的原则"><a href="#创建索引的原则" class="headerlink" title="创建索引的原则"></a><em>创建索引的原则</em></h3><ol><li>频繁搜索的列可以作为索引</li><li>经常排序，分组的列作为索引</li><li>常用作连接的列(主键/外键)可作为索引</li><li>将索引放在一个单独的表空间中，不要放在有回退段，临时段和表的表空间中</li><li>对大型索引来说，考虑使用nologging子句创建大型索引</li><li>根据业务数据发生的频率，定期重新生成或重新组织索引，并进行碎片整理</li><li>仅包含几个不同值的列不可创建B数索引，可根据需求创建位图索引</li><li>不要在仅包含几行的表中创建索引</li></ol><hr><h3 id="删除索引"><a href="#删除索引" class="headerlink" title="删除索引"></a><em>删除索引</em></h3><pre><code>--语法drop index index_name</code></pre><p>什么时候删除索引</p><ol><li>应用程序不再需要索引</li><li>执行批量加载前。大量加载数据前删除索引，加载完后重建索引有以下好处：提高家在性能；更有效的使用索引控件；</li><li>索引已损坏</li></ol><hr><h3 id="重建索引"><a href="#重建索引" class="headerlink" title="重建索引"></a><em>重建索引</em></h3><pre><code>--将反向键改为B数索引语法alter index index_name rebuild noreveres</code></pre><p>什么时候重建索引</p><ol><li>用户表移动到新的表空间后，表上的所有不是自动转移。因此需要手动将索引移到指定表空间</li><li>索引中包含已删除的表项。对表频繁的删除，造成索引空间的浪费。</li><li>将现有的正常所有转换成反向键索引</li></ol><hr><h2 id="表分区"><a href="#表分区" class="headerlink" title="表分区"></a><strong>表分区</strong></h2><h3 id="什么是表分区"><a href="#什么是表分区" class="headerlink" title="什么是表分区"></a><em>什么是表分区</em></h3><blockquote><p>将一个表中的所有行分为几部分，并将这几部分存储在不同的位置，被分区的表称为分区表。分成的每一个部分称为一个分区</p></blockquote><hr><h3 id="表分区的优点"><a href="#表分区的优点" class="headerlink" title="表分区的优点"></a><em>表分区的优点</em></h3><ol><li>改善表的查询性能。分区后执行查询sql时只访问特点的分区而并未整个表</li><li>表更容易管理。因为分区表的数据存储在多个部分中。按区加载和删除更加容易</li><li>便于备份和恢复。可以独立的备份和恢复每个分区</li><li>提高数据安全性，将不同的分区分布在不同的磁盘。可以减小磁盘损坏时对所有数据同时损坏的可能性</li></ol><hr><h3 id="什么时候分区"><a href="#什么时候分区" class="headerlink" title="什么时候分区"></a><em>什么时候分区</em></h3><ol><li>数据大于2GB</li><li>已有的数据和新增的数据有明显的界限划分<blockquote><p>注意：要分区的表不能有LONG和LONG RAW类型的列</p></blockquote></li></ol><hr><h3 id="分区表的分类"><a href="#分区表的分类" class="headerlink" title="分区表的分类"></a><em>分区表的分类</em></h3><blockquote><p>可分为：范围分区，列表分区。散列分区，复合分区，间隔分区和虚拟分区等。间隔分区和虚拟分区是oracle 11g的新特性</p></blockquote><ol><li>范围分区<blockquote><p>范围分区是应用较广的表分区方式，他以列的值范围作为分区的划分条件。将记录存放到列值的所在range分区中</p></blockquote></li></ol><blockquote><p>注意：在分区时，某些分区暂时无法预测范围，则可以创建maxvalue分区，所有不指定范围的记录都会被储存到这个分区中</p></blockquote><pre><code>--语法partition by range(tabName_keyName)(partition a values less than(value),partition a values less than(maxvalue))</code></pre><ul><li>a<ul><li>第几区的名称</li></ul></li><li>less than<ul><li>小于</li></ul></li><li>value<ul><li>分区的条件。</li></ul></li><li>maxvalue<ul><li>超出最大值后的分区<blockquote><p>例：partition a values less than(to.date(‘2020-01-01’,’yyyy-MM-dd’))：意思就是如果时间小于2020-01-01就将该列放在a分区</p></blockquote></li></ul></li></ul><p>查看第n分区</p><pre><code>select * from user partition(n)</code></pre><p>删除第N分区</p><pre><code>delete from table partition(n)</code></pre><hr><ol start="2"><li>间隔分区<blockquote><p>范围分区的一种增强功能。可以实现范围分区的自动化</p></blockquote></li></ol><pre><code>partition by range(tabName_keyName)interval(numtoyminterval(3,&#39;month&#39;))(partition p1 values less than (to_date(‘2020-01-01&#39;,&#39;yyyy-MM-dd&#39;)))</code></pre><ul><li>interval<ul><li>间隔，按照后面括号中的定义间隔添加分区</li></ul></li><li>numtoyminterval(3,’month’)<ul><li>每3个月为一个分区。numtoyminterval(n,’b’) b可以为day,year或month，那样就表示为n天，n年或n月为一个分区</li></ul></li></ul><blockquote><p>使用该方法在查询数据时需要先知道自动生成的分区名称</p></blockquote><pre><code>--获取分区情况select table_name,partition_name from user_tab_partitions where table_name=upper(‘tabName_keyName&#39;)</code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Oracle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Oracle(一)</title>
      <link href="/2020/03/28/oracle-yi/"/>
      <url>/2020/03/28/oracle-yi/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是Oracle"><a href="#什么是Oracle" class="headerlink" title="什么是Oracle"></a>什么是Oracle</h1><blockquote><p>Oracle Database，又名Oracle RDBMS，或简称Oracle。是甲骨文公司的一款关系数据库管理系统。</p></blockquote><hr><h2 id="Oracle的特点"><a href="#Oracle的特点" class="headerlink" title="Oracle的特点"></a>Oracle的特点</h2><ol><li>支持多用户，大事务量的事务处理</li><li>在保存安全性和完整性方面性能优秀</li><li>支持分布式数据处理，将不同物理位置上的数据库用通信网络连接起来，组成一个逻辑上统一的数据库，完成数据处理任务</li><li>具有可以移植性，可在多个操作平台使用，而Sql Server只能在Windows运行</li></ol><hr><h2 id="常用的数据类型"><a href="#常用的数据类型" class="headerlink" title="常用的数据类型"></a><strong>常用的数据类型</strong></h2><h3 id="字符串数据类型"><a href="#字符串数据类型" class="headerlink" title="字符串数据类型"></a><em>字符串数据类型</em></h3><blockquote><p>字符串数据常用的有：char，varchar2，nchar</p></blockquote><ul><li>char<ul><li>需要使用固定长度的字符串时使用</li><li>长度可为1-2000字节，如在未指定大小则默认1字节</li><li>如果输入的字节小于指定长度则用空格填充至指定长度，如果值大于指定长度则报错</li></ul></li><li>varchar2<ul><li>支持可变长度字符串</li><li>大小为1-4000字节。在定义时应指定大小</li><li>如果输入的字节长度小于指定的字节长度则不会有任何变化，如果值大于指定长度则报错</li></ul></li><li>nchar<ul><li>国家字符集，用法和char相同</li><li>如果开发的项目需要国际化，那么数据类型选择nchar</li><li>nchar用来存储Unicode字符集类型，即双字节字符类型。如果插入’a’，char占用的字节数是1，nchar占用的字节数是2。如果插入中文，char会报错，而nchar不会</li></ul></li></ul><hr><h3 id="数值数据类型"><a href="#数值数据类型" class="headerlink" title="数值数据类型"></a><em>数值数据类型</em></h3><blockquote><p>数值数据常用的有：number</p></blockquote><ul><li>该类型可以存储正数，负数，零，定点数和精度为38位的浮点数</li></ul><p>用法：</p><pre><code>name number(p=38,s=0)name number(p)          //定点数name number(p,s)        //浮点数</code></pre><blockquote><p>p为精度，表示数字的有效数位，在1-38之间。从左边第一个不为0的数算起，小数点和负号不计入有效位数。s为范围,表示小数点右边数字的位数,在-84~+127之间.</p></blockquote><blockquote><p>规则：首先精确到小数点后面s位,并且四舍五入.如果精确后值的有效数≤p则正确，否则报错</p></blockquote><p>例：</p><ol><li>变量：123.14 number(4,2) 精确到小数点后面s位：123.14；有效数位为5，123.14大于规定的有效数位，报错</li><li>变量：123.1 number(5,2) 精确到小数点后面s位：123.10；有效数位为5，123.14等于规定的有效数位，输出123.10</li><li>变量：0.1 number(3,4) 精确到小数点后面s位：0.1000；有效数位为4，0.1000大于规定的有效数位，报错（左边第一个不为0的数算起）</li><li>变量：0.00001 number(3,4)  精确到小数点后面s位：0.0000；有效数位为0，0.0000小于规定的有效数位，输出0.0000</li></ol><hr><h3 id="日期时间数据类型"><a href="#日期时间数据类型" class="headerlink" title="日期时间数据类型"></a><em>日期时间数据类型</em></h3><blockquote><p>数值数据常用的有：date，timestamp</p></blockquote><ul><li>date<ul><li>使用7字节固定长度，每个字节分别存储：世纪，年，月，日，时，分，秒</li><li>函数sysdate是返回当前日期和时间</li></ul></li><li>timestamp<ul><li>用于存储：世纪，年，月，日，时，分，秒。秒精确到小数点后6位</li><li>函数systimestamp是返回当前日期，时间和时区</li></ul></li></ul><hr><h3 id="LOB数据类型"><a href="#LOB数据类型" class="headerlink" title="LOB数据类型"></a><em>LOB数据类型</em></h3><blockquote><p>又称大对象数据类型可以存储4GB的非结构化数据，如声音剪辑和视频剪辑等。LOB可以对数据高效，随机，分段的访问。LOB可以是外部的，也可以是内部的。取决于相对于数据库的位置</p></blockquote><blockquote><p>Oracle中的LOB数据类型有：CLOB，BLOB，BFILE和NCLOB</p></blockquote><ul><li>CLOB(Character LOB，字符LOB)<ul><li>存储大量字符文件可存储单字节字符数据和多字节字符数据</li><li>主要存储非结构化的XML文档，如新闻，内容介绍等含大量文本内容的文档</li></ul></li><li>BLOB(Binary LOB，二进制LOB)<ul><li>存储较大的二进制对象，如音频，视频剪辑和声音剪辑等</li></ul></li><li>BFILE(Binary File，二进制文件)<ul><li>可将二进制文件存储在数据库外部的操作系统文件中</li><li>BFILE列存储一个BFILE定位器，指向位于服务器文件系统的上的二进制文件，支持的大小为4GB</li></ul></li><li>NCLOB<ul><li>用于存储较大的nchar字符数据</li><li>NCLOB同时支持固定宽度字符和可变宽度字符(Unicode 字符数据)。大字符对象的大小不大于4GB</li><li>NCLOB的使用方法和CLOB类似</li></ul></li></ul><hr><h2 id="Oracle中的伪列"><a href="#Oracle中的伪列" class="headerlink" title="Oracle中的伪列"></a><strong>Oracle中的伪列</strong></h2><blockquote><p>伪列像是Oracl中的一个列，但他从未存储在表中。可以查询，但不能添加，删除和修改</p></blockquote><blockquote><p>常用的伪列有：rowid，rownum</p></blockquote><ul><li>rowid<ul><li>数据库中的每行都有一个行地址，rowid伪列返回该行地址</li><li>可用rowid来定位表中的一行。通常情况，rowid可以唯一的标识数据库中的一行<blockquote><p>用法：使用sql查看rowid的值：select rowid from user.emp</p></blockquote></li></ul></li><li>rownum<ul><li>返回的数值代表行的次序，第一行返回1，第二行返回2.以此类推</li><li>可以将此伪列用作where的条件判断，也可以用作显示的列<blockquote><p>使用sql限制返回的行数：select * from user.emp where rownum&lt;11</p></blockquote></li></ul></li></ul><blockquote><p>返回查询表的所有数据和对应的行数：select *,rownum from user.emp</p></blockquote><hr><h2 id="sql语言"><a href="#sql语言" class="headerlink" title="sql语言"></a><strong>sql语言</strong></h2><h3 id="数据库定义语言-DDL"><a href="#数据库定义语言-DDL" class="headerlink" title="数据库定义语言(DDL)"></a><em>数据库定义语言(DDL)</em></h3><blockquote><p>数据库定义语言为：create(创建),alter(更改),truncate(截断),drop(删除)</p></blockquote><ul><li>create</li></ul><pre><code>create Table [schema.] table (column datatype [,column datatype ])(创建表)</code></pre><p>schema：对象所有者，即模式名称。如果用户在自己的模式中创建表则不用指定<br>table：表名<br>column：列名<br>datatype：该列的数据类型即宽度<br>表的命名规范：</p><ol><li>首字符为字母</li><li>不能使用保留字作为表名</li><li>表名的最大字符为30</li><li>同一用户模式下表名不能相同</li><li>可以使用下划线，字母和数字</li><li>但是不能使用空格和单引号<blockquote><p>创建表后添加主键（主键必须not null）：alter table 表名 add constraint yy primary key(主键1，主键2);</p></blockquote></li></ol><hr><h3 id="数据库操纵语言-DML"><a href="#数据库操纵语言-DML" class="headerlink" title="数据库操纵语言(DML)"></a><em>数据库操纵语言(DML)</em></h3><blockquote><p>数据库定义语言为：insert(插入),select(选择),delete(删除),update(更新)</p></blockquote><ul><li>insert</li></ul><pre><code>--插入多条数据insert allinto 表名 values()into 表名 values()select 1 from dual;</code></pre><ul><li>distinct</li></ul><pre><code>--自动合并重复的行select distinct name from user.emp</code></pre><ul><li>使用现有的表创建新表</li></ul><pre><code>create table &lt;newTable&gt; as select {*|column(s)} from &lt;oldtable&gt; [where]</code></pre><blockquote><p>如果where条件为false，则不会复制表数据，只会复制表结构</p></blockquote><ul><li>取出列不重复的数据记录</li></ul><pre><code>select name,age from user.emp group by name having (count(name||age)&lt;2)</code></pre><hr><h3 id="事务控制语言-TCL"><a href="#事务控制语言-TCL" class="headerlink" title="事务控制语言(TCL)"></a><em>事务控制语言(TCL)</em></h3><blockquote><p>事务控制语言为：commit(提交),savepoint(保存点),rollback(回滚)</p></blockquote><ul><li>commit：提交事务</li><li>rollback：事务回滚</li><li>savepoint：在事务中创建存储点</li><li>rollback to&lt;name&gt;：将事务回滚到存储点</li></ul><hr><h2 id="sql操作符"><a href="#sql操作符" class="headerlink" title="sql操作符"></a><strong>sql操作符</strong></h2><blockquote><p>sql操作符可分为：算数操作符，比较操作符，逻辑操作符，集合操作符，连接字符串</p></blockquote><h3 id="算数操作符"><a href="#算数操作符" class="headerlink" title="算数操作符"></a>算数操作符</h3><blockquote><p>+，-，*，/</p></blockquote><h3 id="比较操作符"><a href="#比较操作符" class="headerlink" title="比较操作符"></a>比较操作符</h3><blockquote><p>=，！=，&lt;，&gt;，&lt;=，&gt;=，between…and(值是否在两个值之间)，or，in，like，is null</p></blockquote><h3 id="逻辑操作符"><a href="#逻辑操作符" class="headerlink" title="逻辑操作符"></a>逻辑操作符</h3><blockquote><p>and，not，or</p></blockquote><h3 id="集合操作符"><a href="#集合操作符" class="headerlink" title="集合操作符"></a>集合操作符</h3><blockquote><p>union，union all，intersect，minus</p></blockquote><ul><li>union<ul><li>union(并集)操作符返回两个查询选定的所有不重复的行<blockquote><p>例：select * from user union select * from student –获取两个表的所有不重复的行</p></blockquote></li></ul></li><li>union all<ul><li>union all(并集all)合并两个查询选定的所有行，包括重复的行<blockquote><p>例：select * from user union all select * from student –获取两个表的所有行</p></blockquote></li></ul></li><li>intersect<ul><li>intersect(交集)只返回两个表都有的行<blockquote><p>例：select * from user intersect select * from student –返回两个表都有的行</p></blockquote></li></ul></li><li>minus<ul><li>minus(减集)只返回被第一个查询选定的行而未被第二个查询选中的行</li></ul></li></ul><p>连接字符串</p><blockquote><p>||：用于将两个或多个字符串合并成一个字符串，或者将一个字符串和一个数值合并在一起。可以用于在查询语句中将多个列拼接在一起</p></blockquote><hr><h2 id="sql函数"><a href="#sql函数" class="headerlink" title="sql函数"></a><strong>sql函数</strong></h2><blockquote><p>sql函数可分为：单行函数，聚合函数，分析函数</p></blockquote><blockquote><blockquote><p>单行函数：字符函数，日期函数，数字函数，转换函数，其他函数<br><br><br>聚合函数：也称为分组函数。基于数据库的多行进行运算，返回一个结果。如对多行记录的某个字段求和，求最大值运算<br><br><br>分析函数：对一个查询结果中的每个结果进行分组运算</p></blockquote></blockquote><h3 id="转换函数"><a href="#转换函数" class="headerlink" title="转换函数"></a><em>转换函数</em></h3><blockquote><p>将一种数据类型转换成另一种数据类型</p></blockquote><table><thead><tr><th align="center">函数</th><th align="center">功能</th><th align="center"><center>实例</center></th><th align="center">结果</th></tr></thead><tbody><tr><td align="center">to_char()</td><td align="center">转换成字符串</td><td align="center">TO_CHAR(1234.5,’$9999.9’)</td><td align="center">$1234.5</td></tr><tr><td align="center">to_date()</td><td align="center">转换成日期类型</td><td align="center">TO_DATE(‘1980-01-01’,’yyyy-mm-dd’)</td><td align="center">01-1月-80</td></tr><tr><td align="center">to_number()</td><td align="center">转换成数值类型</td><td align="center">TO_NUMBER(‘1234.5’)</td><td align="center">1234.5</td></tr></tbody></table><blockquote><p>TO_CHAR(d| n [,fmt])</p></blockquote><p>d是日期，n是数字fmt是指定的日期或数字的格式。根据格式转换成varchar2数据类型。如果省略了fmt，日期将为默认日期格式转换。常用与格式化日期类型<br>例：</p><pre><code>TO_CHAR(date,&#39;YYYY&#39;年&#39;fmMM&#39;月&#39;fmDD&#39;日&#39; HH24:MI:SS&#39;) --使用fm避免空格和数字填充时间</code></pre><hr><blockquote><p>TO_DATE(CHAR[,fmt])</p></blockquote><p>将varchar或者char类型转换成日期格式。常用与将字符串类型的数据转换成日期格式</p><pre><code>TO_DATE(&#39;2020-01-01&#39;,&#39;yyyy-MM-dd&#39;)</code></pre><hr><h3 id="其他函数"><a href="#其他函数" class="headerlink" title="其他函数"></a><em>其他函数</em></h3><table><thead><tr><th align="center">函数</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">NVL(a,b)</td><td align="center">如果a的值为null则返回b的值</td></tr><tr><td align="center">NVL2(a,b,c)</td><td align="center">如果a的值为null则返回c的值，否则返回b的值</td></tr><tr><td align="center">DECODE(a,b,c,d,e,else)</td><td align="center">如果a等于b则返回c；如果a等于d则返回e，否则返回else</td></tr></tbody></table><hr><h3 id="分析函数"><a href="#分析函数" class="headerlink" title="分析函数"></a><em>分析函数</em></h3><blockquote><p>函数名([参数1]) over ([分区子句][排序子句])</p></blockquote><ul><li>函数名<ul><li>需要分析的函数名称</li></ul></li><li>参数<ul><li>函数需要传入的参数</li></ul></li><li>分区子句(PARTITION BY)<ul><li>根据列的值将数据分成不同的分区</li></ul></li><li>排序子句(ORDER BY)<ul><li>每个分区按照什么列进行排序</li></ul></li></ul><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a><em>函数</em></h3><ul><li>row_number<ul><li>返回唯一的值，遇见相同的数据时，按照排名顺序依次增加</li></ul></li><li>dense_rank<ul><li>返回唯一的值，遇见相同的数据时，所有数据的排名都是一致的</li></ul></li><li>rank<ul><li>返回位置的值，遇见相同的数据时，所有数据的排名都是一致的，同时会在最后一条相同记录和下一条不同记录的排名之间空出排名</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Oracle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring(一)</title>
      <link href="/2020/02/17/spring-yi/"/>
      <url>/2020/02/17/spring-yi/</url>
      
        <content type="html"><![CDATA[<h2 id="Spring是什么"><a href="#Spring是什么" class="headerlink" title="Spring是什么"></a><strong>Spring是什么</strong></h2><p>Spring是分层的Java SE/EE应用，full-stack（全栈式）轻量级开源框架。以IOC和AOP为内核</p><h2 id="Spring两大核心"><a href="#Spring两大核心" class="headerlink" title="Spring两大核心"></a><strong>Spring两大核心</strong></h2><p>Spring的两大核心分别是IOC和AOP</p><ul><li>IOC<ul><li>Inverse Of Control/反转控制/控制反转<br></li><li>降低程序间的耦合</li></ul></li><li>AOP<ul><li>Aspect Oriented Programming/面向切面编程<br></li><li>在不改变原有代码的基础上织入新的功能</li></ul></li></ul><h2 id="Spring的优势"><a href="#Spring的优势" class="headerlink" title="Spring的优势"></a><strong>Spring的优势</strong></h2><p>轻量级，开源，方便解耦，声明式（配置）事务的支持，AOP的支持，方便测试，方便集成其他框架</p><hr><h2 id="程序的耦合和解耦"><a href="#程序的耦合和解耦" class="headerlink" title="程序的耦合和解耦"></a><strong>程序的耦合和解耦</strong></h2><h3 id="什么是耦合"><a href="#什么是耦合" class="headerlink" title="什么是耦合"></a><em>什么是耦合</em></h3><p>简单的说，程序之间的依赖叫做耦合</p><ol><li>类之间的依赖</li><li>方法之间的依赖</li></ol><hr><h3 id="什么是解耦"><a href="#什么是解耦" class="headerlink" title="什么是解耦"></a><em>什么是解耦</em></h3><p>降低程序之间的依赖/降低耦合；叫做解耦</p><blockquote><p>开发中应做到：编译时不依赖，运行时才依赖</p></blockquote><hr><h2 id="IOC的概念和作用"><a href="#IOC的概念和作用" class="headerlink" title="IOC的概念和作用"></a><strong>IOC的概念和作用</strong></h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a><em>概念</em></h3><h4 id="什么是IOC？为什么叫控制反转？"><a href="#什么是IOC？为什么叫控制反转？" class="headerlink" title="什么是IOC？为什么叫控制反转？"></a><em>什么是IOC？为什么叫控制反转？</em></h4><blockquote><p>IOC是通过Bean工厂来实例化对象。由之前自己创建对象到将创建对象的权利交给工厂或框架来做，这就叫做控制反转</p></blockquote><h4 id="IOC的作用"><a href="#IOC的作用" class="headerlink" title="IOC的作用"></a><em>IOC的作用</em></h4><blockquote><p>削减计算机的耦合，但不能彻底消除耦合</p></blockquote><h4 id="为什么使用IOC"><a href="#为什么使用IOC" class="headerlink" title="为什么使用IOC"></a><em>为什么使用IOC</em></h4><blockquote><p>通常的实例化对象如果出现类名的变动，由于类之间的高耦合。需要将实例化全部修改一遍，而用了IOC解耦后只需要修改配置文件即可</p></blockquote><hr><h3 id="基于xml的IOC环境搭建"><a href="#基于xml的IOC环境搭建" class="headerlink" title="基于xml的IOC环境搭建"></a><em>基于xml的IOC环境搭建</em></h3><blockquote><p>首先获取Spring的常用jar包(可去maven官网下载，或使用maven项目)</p></blockquote><ul><li>commons-logging</li><li>mysql-connector</li><li>spring-aop</li><li>spring-beans</li><li>spring-context</li><li>spring-core</li><li>spring-expression</li><li>spring-jcl<blockquote><p>配置applicationContext.xml文件</p></blockquote></li></ul><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans        https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;    &lt;!-- 将实例化对象交给Spring --&gt;    &lt;bean id=&quot;UserDaoImpl&quot; class=&quot;cn.jbit.news.dao.Impl.UserDaoImpl&quot;&gt;&lt;/bean&gt;    &lt;bean id=&quot;UserServetImpl&quot; class=&quot;cn.jbit.news.servet.impl.UserServetImpl&quot;&gt;&lt;/bean&gt;&lt;/beans&gt;</code></pre><blockquote><p>创建对应的bean，可以通过对应的方法创建对象。这样就降低了程序之间的耦合</p></blockquote><h4 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a><em>创建对象</em></h4><h5 id="立即加载"><a href="#立即加载" class="headerlink" title="立即加载"></a>立即加载</h5><blockquote><p>创建对象是采用立即加载，读取完配置文件所有对象就已经被创建</p></blockquote><pre><code>ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;applicationContext.xml/文件位置&quot;);IUserDao userDao = (IUserDao)ac.getBean(&quot;xml配置的id&quot;);</code></pre><p>提示：(IUserDao)ac.getBean(“xml配置的id”);和ac.getBean(“xml配置的id”,IUserDao.class);是一样的</p><hr><h5 id="延迟加载"><a href="#延迟加载" class="headerlink" title="延迟加载"></a>延迟加载</h5><blockquote><p>创建对象是采用延迟加载，等实例化时才创建对象</p></blockquote><pre><code>Resource resource = new ClassPathResource(&quot;bean.xml&quot;);BeanFactory factory = new XmlBeanFactory(resource);IUserDao userDao = (IUserDao)factory.getBean(&quot;UserDaoImpl&quot;);</code></pre><h4 id="Spring对Bean的管理"><a href="#Spring对Bean的管理" class="headerlink" title="Spring对Bean的管理"></a><em>Spring对Bean的管理</em></h4><ol><li><p>采用默认构造函数</p><blockquote><p>在Spring配置文件中使用bean标签，配上id和class属性后，且没有其他属性和标签时，采用的就是默认构造函数创建bean对象。如这时候类中无默认构造函数则对象无法创建</p></blockquote><pre><code> &lt;bean id=&quot;UserDaoImpl&quot; class=&quot;cn.jbit.news.dao.Impl.UserDaoImpl&quot;&gt;&lt;/bean&gt;</code></pre></li><li><p>使用普通工厂中的方法创建对象（使用某个类中的方法创建对象，并存入Spring容器）</p><blockquote><p>例：A工厂有一个方法返回了B对象，如果这时候想获取B对象，但是由于A工厂没有默认构造函数。所以只能采用第二张方法来创建bean对象</p></blockquote><pre><code> &lt;bean id=”工厂名称” class=”工厂全限定类名”&gt;&lt;/bean&gt; &lt;bean id=”B对象名称” factory-bean=”工厂名称/id” factory-method=”工厂里返回B对象的方法名”&gt;&lt;/bean&gt;</code></pre></li><li><p>使用工厂中的静态方法创建对象（使用某个类中的静态方法创建对象，并存入Spring容器）</p><pre><code> &lt;bean id=”B对象名称” class=”工厂全限定类名” factory-method=”工厂里返回B对象的方法名”&gt;&lt;/bean&gt;</code></pre></li></ol><h4 id="bean对象的作用范围调整"><a href="#bean对象的作用范围调整" class="headerlink" title="bean对象的作用范围调整"></a><em>bean对象的作用范围调整</em></h4><blockquote><p>bean标签的scope属性</p></blockquote><blockquote><p>作用：指定bean的作用范围;取值：(常用的是单例和多例)</p></blockquote><ul><li>singleton：<ul><li>单例（默认值）</li></ul></li><li>prototype：<ul><li>多例</li></ul></li><li>request：<ul><li>作用于web应用的请求范围</li></ul></li><li>session：<ul><li>作用于web应用的会话范围</li></ul></li></ul><h4 id="bean的生命周期"><a href="#bean的生命周期" class="headerlink" title="bean的生命周期"></a><em>bean的生命周期</em></h4><blockquote><p>单例对象</p></blockquote><p>出生：容器被创建时<br><br>活着：只要容器在，对象一直活着<br><br>死亡：容器销毁 <br></p><blockquote><p>多例对象</p></blockquote><p>出生：对象被使用时<br><br>活着：对象在使用过程中一直活着<br><br>死亡：对象长时间不使用，且没有被别的对象引用时，由java的垃圾回收器回收<br></p><hr><h2 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a><strong>依赖注入</strong></h2><h3 id="常用的注入方式"><a href="#常用的注入方式" class="headerlink" title="常用的注入方式"></a><em>常用的注入方式</em></h3><blockquote><p>能注入的数据有三类:1.基本类型和String;2.其他bean类型(在配置文件中或注解配置过的bean);3.负责类型/集合类型</p></blockquote><blockquote><p>注入的方式</p></blockquote><ol><li>使用构造函数</li><li>使用set方法（常用）</li><li>使用注解</li><li>p命名空间注入</li></ol><h4 id="构造函数注入"><a href="#构造函数注入" class="headerlink" title="构造函数注入"></a><em>构造函数注入</em></h4><ol><li>在类中定义可注入的变量</li><li>创建有参的构造器<blockquote><p>经常变化的数据不适合注入</p></blockquote></li></ol><p>标签：constructor-arg<br><br>位置：bean内部<br><br>属性：<br></p><ul><li>type：<ul><li>用于指定要注入的数据类型，该类型也是构造函数中的某个参数类型</li></ul></li><li>index：<ul><li>用于指定注入的数据给构造函数中指定索引位置的参数赋值，索引从0开始</li></ul></li><li>name：<ul><li>用于指定给构造函数中指定名称的参数赋值（常用）</li></ul></li><li>value：<ul><li>用于提供基本类型和String类型的数据</li></ul></li><li>ref：<ul><li>用于指定其他的bean类型数据。它指的是在IOC核心容器中出现的bean对象。无法注入集合</li></ul></li></ul><pre><code>&lt;bean id=&quot;UserDaoImpl&quot; class=&quot;cn.jbit.news.dao.Impl.UserDaoImpl&quot;&gt;    &lt;constructor-arg name=”age/构造函数中的数据名称” value=”赋值”&gt;&lt;/constructor-arg&gt;    &lt;constructor-arg name=”Time” ref=”time”&gt;&lt;/constructor-arg&gt;&lt;/bean&gt;&lt;bean id=”time” class=”java.util.Date”&gt;&lt;/bean&gt;</code></pre><p>优点<br><br>    在获取bean对象时，注入数据时必须的操作，否则对象无法创建成功<br><br>缺点<br><br>    改变了bean对象的实例化方式。如果在实例化时用不到这些参数也必须提供</p><blockquote><p>注意：使用时需创建有参和无参构造器。如果constructor-arg没有指定name，则按有参构造器的参数顺序依次赋值</p></blockquote><h4 id="使用set方法"><a href="#使用set方法" class="headerlink" title="使用set方法"></a><em>使用set方法</em></h4><ol><li>类里提供set方法</li></ol><p>标签：property<br><br>位置：bean内<br><br>属性<br></p><ul><li>name：<ul><li>类中的set方法去掉set后名称</li></ul></li><li>value：<ul><li>用于提供基本类型和String类型的数据</li></ul></li><li>ref：<ul><li>用于指定其他的bean类型数据。它指的是在IOC核心容器中出现的bean对象。无法注入集合</li></ul></li></ul><pre><code>&lt;bean id=&quot;UserDaoImpl&quot; class=&quot;cn.jbit.news.dao.Impl.UserDaoImpl&quot;&gt;    &lt;property name=”age/set方法中去掉set后的名称” value=”赋值”&gt;&lt;/property&gt;    &lt;property name=”Time” ref=”time”&gt;&lt;/property&gt;    &lt;/bean&gt;&lt;bean id=”time” class=”java.util.Date”&gt;&lt;/bean&gt;</code></pre><p>优势<br><br>    创建对象时没有限制，可以使用默认构造函数<br><br>缺点<br><br>    如果某个成员必须有值，则获取对象有可能set方法没有执行<br></p><h4 id="p命名空间注入"><a href="#p命名空间注入" class="headerlink" title="p命名空间注入"></a><em>p命名空间注入</em></h4><p>属性：p<br><br>位置：bean的属性<br><br>用法：p:属性=”value”<br></p><pre><code>&lt;bean id=&quot;UserDaoImpl&quot; class=&quot;cn.jbit.news.dao.Impl.UserDaoImpl&quot; p:name=&quot;张三&quot;&gt;</code></pre><p>注意：</p><ol><li>在beans标签里加入属性xmlns:p=”<a href="http://www.springframework.org/schema/p&quot;" target="_blank" rel="noopener">http://www.springframework.org/schema/p&quot;</a></li><li>多个p直接用空格分隔</li><li>如果需要引用bean属性，则使用p:属性-rep=”bean属性的id”</li></ol><h3 id="注入复杂数据"><a href="#注入复杂数据" class="headerlink" title="注入复杂数据"></a><em>注入复杂数据</em></h3><ol><li>使用set注入</li></ol><p>位置：property内<br><br>用于给list集合结构注入的标签：list,array,set<br><br>用于给map集合结构注入的标签：map,props<br></p><blockquote><p>结构相同，标签可以互换</p></blockquote><pre><code>&lt;bean id=&quot;UserDaoImpl&quot; class=&quot;cn.jbit.news.dao.Impl.UserDaoImpl&quot;&gt;    &lt;property name=”集合的set名称”&gt;        &lt;array&gt;            &lt;value&gt;aaa&lt;/value&gt;            &lt;value&gt;bbb&lt;/value&gt;            &lt;value&gt;ccc&lt;/value&gt;        &lt;/array&gt;    &lt;/property&gt;    &lt;property name=”集合的set名称”&gt;        &lt;list&gt;            &lt;value&gt;aaa&lt;/value&gt;            &lt;value&gt;bbb&lt;/value&gt;            &lt;value&gt;ccc&lt;/value&gt;        &lt;/list&gt;    &lt;/property&gt;    &lt;property name=”集合的set名称”&gt;        &lt;map&gt;            &lt;entry key=”” value=””&gt;&lt;/entry&gt;        &lt;/map&gt;    &lt;/property&gt;&lt;/bean&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> IOC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringMVC</title>
      <link href="/2020/02/13/springmvc/"/>
      <url>/2020/02/13/springmvc/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是MVC"><a href="#什么是MVC" class="headerlink" title="什么是MVC"></a>什么是MVC</h1><blockquote><p>全名ModelViewController，是模型(model)视图(view)控制器(controller)的缩写。是一种用于设计创建Web应用程序表现层(servlet)的模式</p></blockquote><hr><h2 id="web-xml配置"><a href="#web-xml配置" class="headerlink" title="web.xml配置"></a><strong>web.xml配置</strong></h2><ol><li><font size="4"><strong><a href="#配置控制器">前端控制器</a></strong></font> <em>(核心)</em></li><li><font size="4"><strong><a href="#请求参数">编码过滤器</a></strong></font> <em>(处理参数提交乱码)</em></li></ol><hr><h2 id="springmvc-xml配置"><a href="#springmvc-xml配置" class="headerlink" title="springmvc.xml配置"></a><strong>springmvc.xml配置</strong></h2><ol><li><font size="4"><strong><a href="#注解扫描">注解扫描</a></strong></font> <em>(可以使用注解:RequestMapping,ResponseBody…)</em></li><li><font size="4"><strong><a href="#视图解析器对象">视图解析器对象</a></strong></font> <em>(将返回的字符串作为相应地址/返回的字符串作为跳转的文件名)</em></li><li><font size="4"><strong><a href="#响应参数">SpringMVC框架注解支持</a></strong></font> <em>(处理返回参数的乱码)</em></li><li><font size="4"><strong><a href="#静态资源映射">静态资源映射</a></strong></font> <em>(js文件加载失败)</em></li><li><font size="4"><strong><a href="#配置文件解析器">文件上传解析器</a></strong></font> <em>(让File控件能上传文件)</em></li><li><font size="4"><strong><a href="#配置拦截器">拦截器</a></strong></font> <em>(在请求处理之前或之后或者视图渲染之后进行操作)</em></li></ol><hr><h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a><strong>环境配置</strong></h2><h3 id="配置控制器"><a href="#配置控制器" class="headerlink" title="配置控制器"></a><strong>配置控制器</strong></h3><blockquote><p>在Web.xml文件内添加控制器</p></blockquote><pre><code>&lt;servlet&gt;    &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt;    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;    &lt;init-param&gt;        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;        &lt;!-- src根目录下的xml --&gt;        &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt;    &lt;/init-param&gt;    &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;    &lt;/servlet&gt;    &lt;servlet-mapping&gt;        &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt;    &lt;url-pattern&gt;/&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;</code></pre><blockquote><p>根据springmvc.xml创建的位置不同，param-value的路径也不同。如果不加这个标签，默认路径在WEB-INF。如：</p></blockquote><pre><code>&lt;param-value&gt;classpath:resources/springmvc.xml&lt;/param-value&gt;</code></pre><hr><h3 id="配置springmvc-xml"><a href="#配置springmvc-xml" class="headerlink" title="配置springmvc.xml"></a><strong>配置springmvc.xml</strong></h3><blockquote><p>Web项目在src目录下创建springmvc.xml文件，maven项目在resource目录下创建</p></blockquote><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;    xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;    xmlns:context=&quot;http://www.springframework.org/schema/context&quot;    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;    xsi:schemaLocation=&quot;        http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd        http://www.springframework.org/schema/mvc        http://www.springframework.org/schema/mvc/spring-mvc.xsd        http://www.springframework.org/schema/context        http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;&lt;/beans&gt;</code></pre><hr><h3 id="开启注解扫描"><a href="#开启注解扫描" class="headerlink" title="开启注解扫描"></a><strong>开启注解扫描</strong></h3><pre><code>&lt;context:component-scan base-package=&quot;cn.SpringMVC.controller(servlet路径)&quot;/&gt;</code></pre><hr><h3 id="视图解析器对象"><a href="#视图解析器对象" class="headerlink" title="视图解析器对象"></a><strong>视图解析器对象</strong></h3><pre><code>&lt;bean id=&quot;viewResolver&quot; class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;    &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/pages/(跳转的文件位置)&quot;/&gt;    &lt;property name=&quot;suffix&quot; value=&quot;.jsp(跳转的文件后缀)&quot;/&gt;&lt;/bean&gt;</code></pre><hr><h3 id="配置类"><a href="#配置类" class="headerlink" title="配置类"></a><strong>配置类</strong></h3><blockquote><p>使用注解：@Controller；@RequestMapping；@ResponseBody；</p></blockquote><ol><li>在类名上面添加<font color="red"><strong>@Controller</strong></font></li><li>在方法名上添加@RequestMapping(path=”访问名称”)/可简写成@RequestMapping()</li></ol><p>注意：</p><ul><li>方法的返回值通常为String，List，对象</li><li><font color="red"><strong>@RequestMapping(name=”/index”,method=RequestMethod.GET)</strong></font>：<br><br>name：字符串即为跳转的页面名称<br><br>method：指定该方法为post的提交方式还是get提交方式，只有对应的提交方式才能进入对应的方法。所以可以通过不同的提交方式进入同名称，提交方式不同的方法内</li><li><font color="red"><strong>@ResponseBody()</strong></font>；返回的字符串即为json格式的字符串</li></ul><hr><h2 id="接收参数"><a href="#接收参数" class="headerlink" title="接收参数"></a><strong>接收参数</strong></h2><blockquote><p>当传递的参数名和方法的参数名对不上时，方法的参数不会被赋值。需要在方法参数前面加上：@RequestParam(“传递的参数名”)</p></blockquote><h3 id="返回值为String"><a href="#返回值为String" class="headerlink" title="返回值为String"></a><strong>返回值为String</strong></h3><ul><li>接收get，post数据<ul><li>方法可以写成public void getUser(User user){}</li><li>传递的参数会自动封装到对应的对象里去</li><li>如果传递的参数是对象内的对象属性，可以使用：对象属性.属性的方法进行传递,例：card.cardNO=123</li></ul></li><li>接收json数据<ul><li>在方法前面加上 <strong><font color="red">@RequestBody</font></strong> 就可以将接收的json格式的参数对应到方法的参数内</li></ul></li></ul><hr><h3 id="返回值为List，对象"><a href="#返回值为List，对象" class="headerlink" title="返回值为List，对象"></a><strong>返回值为List，对象</strong></h3><blockquote><p>只需在方法上面加上@ResponseBody。该方法会将返回的List，对象转化成json格式的字符串，然后返回</p></blockquote><hr><h2 id="处理中文乱码"><a href="#处理中文乱码" class="headerlink" title="处理中文乱码"></a><strong>处理中文乱码</strong></h2><h3 id="请求参数"><a href="#请求参数" class="headerlink" title="请求参数"></a><strong>请求参数</strong></h3><blockquote><p>传递参数时，如果是中文，有时候会出现乱码。这时候需要在web.xml里添加编码过滤器来解决乱码问题</p></blockquote><pre><code>&lt;filter&gt;    &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt;    &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;        &lt;init-param&gt;            &lt;param-name&gt;encoding&lt;/param-name&gt;            &lt;param-value&gt;utf-8&lt;/param-value&gt;        &lt;/init-param&gt;        &lt;init-param&gt;            &lt;param-name&gt;forceEncoding&lt;/param-name&gt;            &lt;param-value&gt;true&lt;/param-value&gt;        &lt;/init-param&gt;    &lt;/filter&gt;    &lt;filter-mapping&gt;        &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt;    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt;</code></pre><hr><h3 id="响应参数"><a href="#响应参数" class="headerlink" title="响应参数"></a><strong>响应参数</strong></h3><blockquote><p>由于返回字符串和返回对象，lsit集合的字符编码不同，所以返回对象，list集合不用进行乱码配置。只有返回字符串才需要对乱码进行修改</p></blockquote><ul><li>方法一<blockquote><p>将方法的注释上改为：@RequestMapping(value=”访问名称”,produces=”application/html;charset=utf-8”)</p></blockquote></li><li>方法二<blockquote><p>对servlet.xml进行全局配置</p></blockquote></li></ul><pre><code>&lt;mvc:annotation-driven&gt;    &lt;mvc:message-converters register-defaults=&quot;true&quot;&gt;        &lt;bean class=&quot;org.springframework.http.converter.StringHttpMessageConverter&quot;&gt;            &lt;property name=&quot;supportedMediaTypes&quot; value=&quot;text/plain;charset=UTF-8&quot;/&gt;        &lt;/bean&gt;    &lt;/mvc:message-converters&gt;&lt;/mvc:annotation-driven&gt;</code></pre><hr><h2 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a><strong>Ajax</strong></h2><blockquote><p>SpringMVC的Ajax使用方法和普通方法没有区别。需要注意的是加载js或者jquery文件时会报错。可配置静态资源解析器来解决这个问题。</p></blockquote><hr><h2 id="静态资源映射"><a href="#静态资源映射" class="headerlink" title="静态资源映射"></a><strong>静态资源映射</strong></h2><blockquote><p>springmvc.xml里加入</p></blockquote><pre><code>&lt;mvc:resources location=&quot;/js/&quot; mapping=&quot;/js/*&quot;/&gt;</code></pre><p>注意：<font color="red">文件夹位置一定要和WEB-INF同级</font>，否则会报错not mapping for Get/项目/js文件夹/js文件</p><hr><h3 id="转发"><a href="#转发" class="headerlink" title="转发"></a><strong>转发</strong></h3><p><strong><center>原版</center></strong></p><pre><code>@RequestMapping(num1)public void test1(HttpServletRequest request,HttpServletResponse response){    //重定向    Response.sendRedirect(&quot;跳转地址.jsp&quot;);}</code></pre><p><strong><center>SpringMVC</center></strong></p><pre><code>@RequestMapping(num2)public String Test2(){    //转发;    return &quot;&quot;;}</code></pre><hr><h3 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a><strong>重定向</strong></h3><p><strong><center>原版</center></strong></p><pre><code>@RequestMapping(num1)public void test1(HttpServletRequest request,HttpServletResponse response){    //转发    Request.getRequestDispatcher(跳转地址.jsp).forward(request,response);}</code></pre><p><strong><center>SpringMVC</center></strong></p><pre><code>@RequestMapping(num2)public String Test2(){    //重定向;    return &quot;redirect:地址.jsp&quot;;}</code></pre><hr><p>注意：</p><ul><li>转发：字符串返回结果默认为转发</li><li>重定向：如果后缀有.jsp则跳转到页面，如果没有后缀则可以跳转到RequestMapping的方法内</li></ul><blockquote><p>提示：<br>如果不同的servlet有相同的方法名，使用转发或重定向时会出现冲突。这时候可以在类的上面加入@RequestMapping(类名)。这时跳转当前的servlet方法不需要加上类名，从ajax或jsp访问方法则需要加上’类名/方法’。这样可以防止多个servle出现重名方法。<br>当给类起名后，返回字符串的文件名前面需要加’/‘</p></blockquote><hr><h2 id="传递参数"><a href="#传递参数" class="headerlink" title="传递参数"></a><strong>传递参数</strong></h2><blockquote><p>当需要吧数据存放至Request或者Session时可以使用原版的方法或者Model</p></blockquote><p><strong>原版</strong>：</p><ul><li>使用HttpServletRequest的setAttribute(“key”,”value”)进行传递</li><li><em>Model*</em>:</li><li>使用Model的addAttribute(“key”,”value”)进行传递</li></ul><hr><h2 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a><strong>文件上传</strong></h2><h3 id="配置文件解析器"><a href="#配置文件解析器" class="headerlink" title="配置文件解析器"></a><strong>配置文件解析器</strong></h3><blockquote><p>在springmvc.xml里加入</p></blockquote><pre><code>&lt;bean id=&quot;multipartResolver&quot; class=&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;&gt;    &lt;!-- 设置字符编码集 --&gt;    &lt;property name=&quot;defaultEncoding&quot; value=&quot;utf-8&quot;&gt;&lt;/property&gt;    &lt;!-- 设置文件大小 --&gt;    &lt;property name=&quot;maxUploadSize&quot; value=&quot;1024000&quot;&gt;&lt;/property&gt;&lt;/bean&gt;</code></pre><hr><h3 id="上传单个文件"><a href="#上传单个文件" class="headerlink" title="上传单个文件"></a><strong>上传单个文件</strong></h3><p><strong>Jsp页面</strong></p><pre><code>&lt;form action=&quot;跳转地址&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt;    &lt;input type=&quot;file&quot; name=&quot;file&quot;/&gt;    &lt;input type=&quot;submit&quot; name=&quot;上传按钮&quot;/&gt;&lt;/form&gt;</code></pre><p><strong>servlet页面</strong></p><pre><code>public String uoload(MultipartFile 表单名){}</code></pre><hr><h3 id="上传多个文件"><a href="#上传多个文件" class="headerlink" title="上传多个文件"></a>上传多个文件</h3><p><strong>Jsp页面</strong></p><pre><code>&lt;form action=&quot;跳转地址&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt;    &lt;input type=&quot;file&quot; name=&quot;file&quot;/&gt;    &lt;input type=&quot;file&quot; name=&quot;file&quot;/&gt;    &lt;input type=&quot;file&quot; name=&quot;file&quot;/&gt;    &lt;input type=&quot;file&quot; name=&quot;file&quot;/&gt;    &lt;input type=&quot;submit&quot; name=&quot;上传按钮&quot;/&gt;&lt;/form&gt;</code></pre><p><strong>servlet页面</strong></p><pre><code>public String uoload(MultipartFile[] 表单名){    for(MultipartFile multipartFile : 表单名){    //遍历文件名    System.out.print(multipartFile.getOriginalFilename());    }}</code></pre><hr><h2 id="拦截器和拦截器站"><a href="#拦截器和拦截器站" class="headerlink" title="拦截器和拦截器站"></a><strong>拦截器和拦截器站</strong></h2><h3 id="什么是拦截器"><a href="#什么是拦截器" class="headerlink" title="什么是拦截器"></a><strong>什么是拦截器</strong></h3><blockquote><p>拦截器是一个SpringMVC控件，用来对数据进行一些处理</p></blockquote><hr><h3 id="拦截器有什么用"><a href="#拦截器有什么用" class="headerlink" title="拦截器有什么用"></a><strong>拦截器有什么用</strong></h3><ol><li>在请求进入处理器之前做一些操作</li><li>在处理器完成任务之后做一些操作</li><li>在视图渲染之后做一些操作</li></ol><hr><h3 id="拦截器站是什么"><a href="#拦截器站是什么" class="headerlink" title="拦截器站是什么"></a><strong>拦截器站是什么</strong></h3><blockquote><p>多个拦截器组成一个拦截器</p></blockquote><hr><h3 id="配置拦截器"><a href="#配置拦截器" class="headerlink" title="配置拦截器"></a><strong>配置拦截器</strong></h3><blockquote><p>在springmvc.xml里写入</p></blockquote><pre><code>&lt;mvc:interceptors&gt;    &lt;mvc:interceptor&gt;        &lt;!-- SpringMVC开头的路径都拦截 --&gt;        &lt;mvc:mapping path=&quot;/Springmvc/**&quot;/&gt;        &lt;!-- 拦截器路径 --&gt;        &lt;bean class=&quot;cn.SpringMVC.interceptor.FirstInterceptor&quot;&gt;&lt;/bean&gt;    &lt;/mvc:interceptor&gt;&lt;/mvc:interceptors&gt;</code></pre><blockquote><p>配置多个拦截器<br>将下列代码复制粘贴至&lt;mvc:interceptors&gt;标签内，修改拦截器路径即可</p></blockquote><pre><code>&lt;mvc:interceptor&gt;    &lt;!-- SpringMVC开头的路径都拦截 --&gt;    &lt;mvc:mapping path=&quot;/Springmvc/**&quot;/&gt;    &lt;!-- 拦截器路径 --&gt;    &lt;bean class=&quot;cn.SpringMVC.interceptor.FirstInterceptor&quot;&gt;&lt;/bean&gt;&lt;/mvc:interceptor&gt;</code></pre><hr><h3 id="使用拦截器"><a href="#使用拦截器" class="headerlink" title="使用拦截器"></a><strong>使用拦截器</strong></h3><p>关键方法：</p><ul><li>Boolean preHandle()    //进入控制器之前的操,作如果返回true则进入控制器或下一个控制器</li><li>Void postHandle() //控制器完成任务后的操作</li><li>Void afterCompletion()    //视图渲染之后的操作</li></ul><p>创建拦截器</p><ol><li>创建interceptor包，然后创建拦截器FirstInterceptor.java</li><li>实现HandlerInterceptor接口</li><li>重写HandlerInterceptor的关键方法<br>提示：<blockquote><p>可使用抽象方法secondInterceptor实现HandlerInterceptor的两个无返回值的方法，后续拦截器只需要继承secondInterceptor并实现preHandle就行</p></blockquote></li></ol><hr><h3 id="拦截器站的运行顺序"><a href="#拦截器站的运行顺序" class="headerlink" title="拦截器站的运行顺序"></a><strong>拦截器站的运行顺序</strong></h3><blockquote><p>控制器完成任务之前按照配置文件的顺序加载preHandle。等控制器执行完成之后执行顺序将反过来，最后配置的最先运行</p></blockquote><hr><h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a><strong>异常处理</strong></h2><h3 id="局部异常"><a href="#局部异常" class="headerlink" title="局部异常"></a><strong>局部异常</strong></h3><blockquote><p>出错后跳转到error.jsp页面.该方法只能在一个控制器起作用</p></blockquote><pre><code>@ExceptionHandlerpublic String handleException(Exception exception){    Exception.printStackTrace();    return &quot;error&quot;;}</code></pre><hr><h3 id="全局异常"><a href="#全局异常" class="headerlink" title="全局异常"></a><strong>全局异常</strong></h3><ul><li>注解<ol><li>创建一个类</li><li>在类名上加上注解：@ControllerAdvice</li><li>创建一个局部异常处理方法</li></ol></li><li>配置xml文件<blockquote><p>使用配置文件解决异常</p></blockquote></li></ul><pre><code>&lt;bean class=&quot;org.springframework.web.servlet.handler.SimpleMappingExceptionResolver.class&quot;&gt;    &lt;property name=&quot;exceptionMappings&quot;&gt;        &lt;props key=&quot;java.lang.Exception&quot;&gt;            &lt;prop key=&quot;java.lang.Exception&quot;&gt;error&lt;/prop&gt;        &lt;/props&gt;    &lt;/property&gt;&lt;/bean&gt;</code></pre><hr><h2 id="额外增加的注解"><a href="#额外增加的注解" class="headerlink" title="额外增加的注解"></a><strong>额外增加的注解</strong></h2><h3 id="RequestParam"><a href="#RequestParam" class="headerlink" title="@RequestParam"></a><em>@RequestParam</em></h3><p>该注解有三个参数</p><ul><li><p>value</p><ul><li>传入的参数名</li></ul></li><li><p>required</p><ul><li>该参数是否为必须的，默认为true。表示传入的参数必须包含对应的参数名，如果不存在就抛出异常。false表示传入的参数名可以没有指定的value。</li></ul></li><li><p>defaultValue</p><ul><li>默认参数名。不推荐使用</li></ul><hr></li></ul><h3 id="ModelAttribute"><a href="#ModelAttribute" class="headerlink" title="@ModelAttribute"></a><em>@ModelAttribute</em></h3><pre><code>public void test(@ModelAttribute(&quot;user&quot;)User user){    return &quot;index&quot;;}</code></pre><blockquote><p>该注解将属性添加到模型中，效果等同于：</p></blockquote><pre><code>public void test(User user, Model model){    model.addAttribue(&quot;user&quot;,user);    return &quot;index&quot;;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ajax </tag>
            
            <tag> 入门 </tag>
            
            <tag> 框架 </tag>
            
            <tag> SpringMVC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis框架(三)</title>
      <link href="/2020/02/01/mybatis-kuang-jia-san/"/>
      <url>/2020/02/01/mybatis-kuang-jia-san/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是延迟加载"><a href="#什么是延迟加载" class="headerlink" title="什么是延迟加载"></a>什么是延迟加载</h2><blockquote><p>在真正使用数据时才发起查询，不用的时候不查询。按需加载（也叫做懒查询）</p></blockquote><hr><h2 id="什么是立即加载"><a href="#什么是立即加载" class="headerlink" title="什么是立即加载"></a>什么是立即加载</h2><blockquote><p>只要一调用方法，不管数据是否正在使用。马上发起查询</p></blockquote><hr><h2 id="怎么使用延迟加载"><a href="#怎么使用延迟加载" class="headerlink" title="怎么使用延迟加载"></a>怎么使用延迟加载</h2><blockquote><p>在一对多，多对多中，通常采用延迟加载。在多对一，一对一中，通常采用立即加载</p></blockquote><hr><h3 id="一对一使用延迟加载"><a href="#一对一使用延迟加载" class="headerlink" title="一对一使用延迟加载"></a>一对一使用延迟加载</h3><ol><li>将&lt;select&gt;里的多表查询语句改成单表查询。查询sql写成select * from 账户表</li><li>将&lt;resultMap&gt;的子标签&lt;association&gt;清空，然后添加属性select=”用户表.xml的mapper标签的属性namespace属性.用户表的根据用户id查询所有信息的方法”(&lt;association&gt;标签的column属性即为查询的用户id)</li><li>在SqlMapConfig.xml的&lt;configuration&gt;标签下 添加标签</li></ol><pre><code>&lt;settings&gt;    &lt;!--开启Mybatis支持延迟加载--&gt;    &lt;setting name=&quot;lazyLoadingEnabled&quot; value=&quot;true&quot;/&gt;    &lt;!--开启Mybatis支持延迟加载--&gt;    &lt;setting name=&quot;aggressiveLazyLoading&quot; value=&quot;false&quot;/&gt;&lt;/settings&gt;</code></pre><hr><h3 id="一对多使用延迟加载"><a href="#一对多使用延迟加载" class="headerlink" title="一对多使用延迟加载"></a>一对多使用延迟加载</h3><ol><li>将&lt;select&gt;里的多表查询语句改成单表查询。查询sql写成select * from 用户表</li><li>将&lt;resultMap&gt;的子标签&lt;collection&gt;清空，然后添加属性column=”传入用户的id” 和select=”账户表.xml的mapper标签的属性namespace属性.账户表根据用户id查询所有信息的方法”</li><li>在SqlMapConfig.xml的&lt;configuration&gt;标签下 添加标签</li></ol><pre><code>&lt;settings&gt;    &lt;!--开启Mybatis支持延迟加载--&gt;    &lt;setting name=&quot;lazyLoadingEnabled&quot; value=&quot;true&quot;/&gt;    &lt;!--开启Mybatis支持延迟加载--&gt;    &lt;setting name=&quot;aggressiveLazyLoading&quot; value=&quot;false&quot;/&gt;&lt;/settings&gt;</code></pre><hr><h2 id="Mybatis中的缓存"><a href="#Mybatis中的缓存" class="headerlink" title="Mybatis中的缓存"></a>Mybatis中的缓存</h2><h3 id="什么是缓存"><a href="#什么是缓存" class="headerlink" title="什么是缓存"></a>什么是缓存</h3><blockquote><p>存在于内存中的临时数据，在下次使用时将直接调用缓存的数据</p></blockquote><h3 id="为什么使用缓存"><a href="#为什么使用缓存" class="headerlink" title="为什么使用缓存"></a>为什么使用缓存</h3><blockquote><p>减少和数据库的交互次数，提高执行效率</p></blockquote><h3 id="什么数据能使用缓存，什么数据不能使用"><a href="#什么数据能使用缓存，什么数据不能使用" class="headerlink" title="什么数据能使用缓存，什么数据不能使用"></a>什么数据能使用缓存，什么数据不能使用</h3><blockquote><p><strong>适用于</strong>：<em>经常查询并且不经常改变的。数据的正确与否对最终结果影响不大的</em></p></blockquote><blockquote></blockquote><blockquote><p><strong>不适用于</strong>：<em>经常改变的数据。数据的正确与最终影响很大的</em></p></blockquote><h3 id="一级缓存和二级缓存"><a href="#一级缓存和二级缓存" class="headerlink" title="一级缓存和二级缓存"></a>一级缓存和二级缓存</h3><h4 id="一级缓存"><a href="#一级缓存" class="headerlink" title="一级缓存"></a>一级缓存</h4><ul><li>Mybatis中sqlSession对象的缓存</li><li>当执行查询后，查询的结果会同时存入到SqlSession里。然后提供一块区域。该区域的结构是一个Map。当我们再次查询同样的数据，Mybatis会先去SqlSession中查看，如果有的话会拿出来使用</li><li>当SqlSession消失时一级缓存就消失了</li><li>当调用SqlSession的增，删，改，commit()，colse()等方法时会清空一级缓存</li></ul><h4 id="二级缓存"><a href="#二级缓存" class="headerlink" title="二级缓存"></a>二级缓存</h4><ul><li>Mybatis中SqlSessionFactory对象的缓存。由同一个SqlSessionFactory对象创建的SqlSession共享缓存</li></ul><blockquote><p>二级缓存的使用步骤</p></blockquote><ol><li><p><strong>让Mybatis框架支持二级缓存（在SqlMapConfig.xml中配置）</strong></p><p>在configuration标签中添加</p></li></ol><pre><code>    &lt;settings&gt;&lt;setting name=”cacheEnabled”  value=”true”&gt;&lt;/settings&gt;</code></pre><ol start="2"><li><strong>让当前映射文件支持二级缓存（在Dao.xml中配置）</strong></li></ol><p>在Mapper标签中添加</p><pre><code>&lt;cache/&gt;</code></pre><ol start="3"><li><strong>让当前操作支持二级缓存（在select标签中配置）</strong></li></ol><p>在select标签内加入属性</p><pre><code>useCache=”true”</code></pre><blockquote><p>二级缓存虽然不用再次查询数据库，但是因为每次拿取都会将数据存储到一个新的对象中</p></blockquote><hr><h2 id="Mybatis中的注解开发"><a href="#Mybatis中的注解开发" class="headerlink" title="Mybatis中的注解开发"></a>Mybatis中的注解开发</h2><h3 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h3><blockquote><p>创建SqlMapConfig.xml</p></blockquote><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration  PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;  &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt;    &lt;propeties resoure=”jdbcConfig.properties”&gt;&lt;/propeties&gt;    &lt;package name=”实体类全路径名”&gt;&lt;/package&gt;    &lt;environments default=&quot;mysql&quot;&gt;        &lt;environment id=&quot;mysql&quot;&gt;            &lt;transactionManager type=&quot;JDBC&quot;/&gt;            &lt;dataSource type=&quot;POOLED&quot;&gt;                &lt;property name=&quot;driver&quot; value=&quot;${Driver/propeties里的Driver名称}&quot;/&gt;                &lt;property name=&quot;url&quot; value=&quot;${url}&quot;/&gt;                &lt;property name=&quot;username&quot; value=&quot;${username}&quot;/&gt;                &lt;property name=&quot;password&quot; value=&quot;${userpassword}&quot;/&gt;            &lt;/dataSource&gt;        &lt;/environment&gt;    &lt;/environments&gt;    &lt;mappers&gt;        &lt;package name=”dao的文件夹全路径”&gt;&lt;/package&gt;    &lt;/mappers&gt;&lt;/configuration&gt;</code></pre><h3 id="单表CRUD操作（代理Dao方式）"><a href="#单表CRUD操作（代理Dao方式）" class="headerlink" title="单表CRUD操作（代理Dao方式）"></a>单表CRUD操作（代理Dao方式）</h3><blockquote><p>使用注解的时候存在dao.xml控制台会报错。如果写注解就要删除dao.xml</p></blockquote><blockquote></blockquote><blockquote><p>四个常用注解：@Select,@Insert,@Update,@Delete</p></blockquote><p>使用：</p><blockquote><p>在接口的方法上面直接使用 @Select(value=”Sql”)</p></blockquote><ul><li>如果只传sql，value可以省略。直接写@Select(“sql”)</li><li>如果需要传参则和xml的使用方法一致，使用#{name}即可</li><li>如果传入到数据库出现中文乱码，在数据库url后面加上：?characterEncoding=utf8&amp;autoReconnect=true&amp;useSSL=false</li></ul><h3 id="实体类属性名和数据库列名的相对应"><a href="#实体类属性名和数据库列名的相对应" class="headerlink" title="实体类属性名和数据库列名的相对应"></a>实体类属性名和数据库列名的相对应</h3><blockquote><p>使用@Results()注解</p></blockquote><p>例：</p><pre><code>@Select(“select * from user”)@Results(id=”名称，其他方法可以通过id引用这个注解”,value={    @Result(id=true/如果是主键则将id设为true,property=”实体类属性名”,column=”数据库列名”),    @Result(property=”实体类属性名”,column=”数据库列名”),    @Result(property=”实体类属性名”,column=”数据库列名”),})public void addUser(User user);</code></pre><ul><li>其他方法想引用@Results注解需要在开头加上@ResultMap(value={“Id名称”});</li><li>只有一个数据，value可以省略，只写@ResultMap(“Id名称”);</li></ul><h3 id="多表查询操作"><a href="#多表查询操作" class="headerlink" title="多表查询操作"></a>多表查询操作</h3><ul><li>多对一，一对一</li></ul><pre><code>@Select(“select * from user”)@Results(id=”名称，其他方法可以通过id引用这个注解”,value={    @Result(id=true/如果是主键则将id设为true;,property=”实体类属性名”,column=”数据库列名”),    @Result(property=”实体类属性名”,column=”数据库列名”),    @Result(property=”实体类属性名”,column=”数据库列名”),    @Result(property=”实体类对象属性名”,column=”根据id查询的条件”,one=@One(select=”全路径名(dao的package内容).dao接口.根据id查询的方法名”,fetchType=FetchType.EAGER(立即加载))),})</code></pre><ul><li>一对多，多对多</li></ul><pre><code>@Select(“select * from user”)@Results(id=”名称，其他方法可以通过id引用这个注解”,value={    @Result(id=true/如果是主键则将id设为true,property=”实体类属性名”,column=”数据库列名”),    @Result(property=”实体类属性名”,column=”数据库列名”),    @Result(property=”实体类属性名”,column=”数据库列名”),    @Result(property=”实体类对象属性名”,column=”根据id查询的条件”,many=@Many(select=”全路径名(dao的package内容).dao接口.根据id查询的方法名”,fetchType=FetchType.LAZY(稍后加载))),    })</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 入门 </tag>
            
            <tag> Mybatis </tag>
            
            <tag> 框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis框架(二)</title>
      <link href="/2020/01/18/mybatis-kuang-jia-er/"/>
      <url>/2020/01/18/mybatis-kuang-jia-er/</url>
      
        <content type="html"><![CDATA[<h2 id="获取新添加的ID"><a href="#获取新添加的ID" class="headerlink" title="获取新添加的ID"></a><strong>获取新添加的ID</strong></h2><blockquote><p>将&lt;selectKey&gt;标签写在&lt;insert&gt;标签里。这样就能在对象执行添加方法后将新增ID添加到调用的对象内</p></blockquote><pre><code>&lt;selectKey keyProperty=&quot;id/对应实体类&quot; keyColumn=&quot;数据库id/对应数据库的列名&quot; resultType=&quot;数据类型/int&quot; order=&quot;AFTER(之后)/BEFORE(之前)(先执行还是后执行)&quot;&gt;    Select last_insert_id()&lt;/selectKey&gt;</code></pre><hr><h2 id="传递属性的封装"><a href="#传递属性的封装" class="headerlink" title="传递属性的封装"></a><strong>传递属性的封装</strong></h2><blockquote><p>如果方法需要传递多个参数，例如2个对象。这时候如果使用之前的方法就不合适，因为parameterType只能传递一个路径/一个参数，所以这时候就要使用QueryVo和OGNL表达式完成该操作。</p></blockquote><p><font size="2">OGNL:<strong>Object</strong>(对象)<strong>Graphic</strong>(图)<strong>Navigation</strong>(导航)<strong>Language</strong>(语言)</font></p><blockquote><p>之前传递一个路径时直接使用对象属性就可以获取参数，而使用OGNL后则需要使用对象.属性的方法获取属性。这样就可以同时使用对象1.属性和对象2.属性了。所以OGNL就是创建一个类，在类中将实体类作为一个属性，并提供对应的get和set方法。然后在<strong>parameterType</strong>只需要传入该类的路径即可做到传递多个属性的操作。在dao的传递方法中记得将传递参数改为该类。</p></blockquote><p>例：</p><ol><li>在(实体类)src/main/java/entiy中创建QueryVo.java</li><li>将所有实体类作为属性在QueryVo.java中创建。并进行封装。</li><li>将dao接口的方法参数改为QueryVo：void addUser(QueryVo vo);</li><li>将<insert>标签中的parameterType属性路径改为QueryVo.java的路径：src.main.java.entiy.QueryVo</li><li>然后在sql语句中调用对应的参数：insert into user values(#{对象1.属性},#{对象2.属性})</li><li>在测试类的调用方法时使用QueryVo作为参数传递：</li><li>QueryVo vo = new QueryVo()</li><li>Vo.setUser(user/对象);//将对象存储至QueryVo</li><li>User.adduser(vo)    //调用添加方法并将QueryVo传递过去</li></ol><hr><h2 id="输出结果的封装"><a href="#输出结果的封装" class="headerlink" title="输出结果的封装"></a>输出结果的封装</h2><blockquote><p>一般用于查询操作。实体类属性名和数据库列名不一致的解决方法</p></blockquote><ul><li>在sql语句写别名，用as将数据库列名和实体类属性名一一对应</li><li>使用<resultMap>标签</li></ul><pre><code>//该标签写在dao.xml的\&lt;mapper\&gt;下&lt;resultMap id=&quot;自己起的名称&quot; type=&quot;实体类的路径名&quot;&gt;    &lt;!-- 主键字段对应 --&gt;    &lt;id property=&quot;实体类的属性名&quot; column=&quot;数据库列名&quot;&gt;&lt;/id&gt;    &lt;!-- 非主键字段对应 --&gt;    &lt;result property=&quot;实体类的属性名&quot; column=&quot;数据库列名&quot;&gt;&lt;/result&gt;&lt;/resultMap&gt;</code></pre><blockquote><p>将&lt;select&gt;的resultType去掉，换成resultMap=”上面的id名称”</p></blockquote><p><font size="4"><strong>注意：这种执行效率不如第一种起别名的方法，但是比上一种开发效率更快。因为写过一次之后其他的操作可以直接调用。而第一种需要写一次sql语句起一次别名。根据个人喜好选择其中一种</strong></font></p><hr><h2 id="package"><a href="#package" class="headerlink" title="package"></a>package</h2><blockquote><p>使用该标签可以给路径起别名。这样可以节约每次必须写全路径名的时间<br>在SqlMapConfig.xml的configuration标签里进行配置</p></blockquote><pre><code>&lt;typeAliases&gt;    &lt;package name=&quot;src.main.java.entity&quot;&gt;&lt;/package&gt;&lt;/typeAliases&gt;</code></pre><p>这样在使用resultType标签或者parameterType标签时就可以直接使用src/main/java/entity下面的类名了。例如调用src/main/java/entity/user可以简写成parameterType=”user</p><blockquote><p>在<mappers>加入<package >标签可以省略resource或class</p></blockquote><pre><code>&lt;package name=&quot;src.main.java.dao&quot;&gt;&lt;/package&gt;即可使用dao文件夹下的所有dao.xml配置</code></pre><hr><h2 id="Mybatis连接处和事务"><a href="#Mybatis连接处和事务" class="headerlink" title="Mybatis连接处和事务"></a>Mybatis连接处和事务</h2><h3 id="Mybatis连接池"><a href="#Mybatis连接池" class="headerlink" title="Mybatis连接池"></a>Mybatis连接池</h3><hr><p><strong>什么是连接池？</strong></p><blockquote><p>连接池就是用于存储多个连接的一个<strong>容器</strong>。该容器是一个<strong>集合对象</strong>。该集合<strong>必须是安全的线程</strong>，不能两个线程拿到同一连接。该集合还必须实现队列的特效：<strong>先进先出</strong><br>连接池中有多个连接，需要时从连接池拿取。用完后将连接返还给连接池等待下次使用</p></blockquote><p><strong>为什么要用连接池？</strong></p><blockquote><p>每次不用新建一个连接。可以减少获取连接所消耗的时间</p></blockquote><p><strong>Mybatis中的连接池</strong></p><blockquote><p>在主配置文件SqlMapConfig.xml中的dataSource标签。Type属性表示采用什么连接池方式</p></blockquote><center><font size="2">Type的取值</font></center><table><thead><tr><th align="center">取值</th><th align="center"><center>说明</center></th></tr></thead><tbody><tr><td align="center">POOLED</td><td align="center">采用传统的javax.sql.DataSource规范中的连接池。Mybatis中有针对规范的实现。<strong>每次从池中获取连接，运行完后将连接返还</strong></td></tr><tr><td align="center">UNPOOLED</td><td align="center">采用传统的连接方式。虽然也是采用的javax.sql.DataSource，但是没有池的概念。也就是说<strong>每次用都是获取的一个新的连接</strong></td></tr><tr><td align="center">JNDI</td><td align="center">采用的是服务器提供的JNDI技术实现，来获取DataSource对象不同的服务器拿到的DataSource各不同。如果不是web或者maven的war工程，是不能使用的</td></tr></tbody></table><h3 id="Mybatis事务控制"><a href="#Mybatis事务控制" class="headerlink" title="Mybatis事务控制"></a>Mybatis事务控制</h3><p><font size="5">什么是事务？</font></p><blockquote><p>是数据库操作的最小工作单元，是作为单个逻辑工作单元执行的一系列操作；这些操作作为一个整体一起向系统提交，要么都执行、要么都不执行；事务是一组不可再分割的操作集合（工作逻辑单元）</p></blockquote><blockquote><p>缩略：是一组不可分割的操作集合。一系列操作要么都执行，要么都不执行</p></blockquote><hr><p><font size="5">事务的四大特性ACID是什么？</font></p><blockquote><p>原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持续性（Durability）</p></blockquote><ul><li><strong>原子性</strong>：一系列操作要么都不做，要么都做</li><li><strong>一致性</strong>：一系列操作如果全部提交成功则数据库处于一致性状态，如果有一个提交失败则初一不一致状态</li><li><strong>隔离性</strong>：各个事务之间应该是隔离的，并发执行的各个事务之间不能互相干扰</li><li><strong>持续性</strong>：一旦事务提交它对数据库的操作应该是永久性的。接下来的其他操作或故障不应该对执行结果有任何影响</li></ul><hr><p><font size="5">不考虑隔离性会产生的3个问题是什么？</font></p><blockquote><p>脏读，不可重复读，幻象读</p></blockquote><ul><li><strong>脏读</strong>：一个事务正在访问并修改数据的途中另一个事务使用了这个正在修改的数据，这个时候另一个事务所读取的数据称为脏数据。依照脏数据所做的操作肯定是不正确的</li><li><strong>不可重复读</strong>：一个事务两次读取同一个数据，读取到第二次的时候如果这时候第二个事务修改了数据。这时候第一个事务两次读取的数据时不一样的。这种情况称为不可重复读</li><li><strong>幻象读</strong>：一个事务先后读取一个范围的记录，但两次读取的纪录数不同，我们称之为幻象读（两次执行同一条 select 语句会出现不同的结果，第二次读会增加一数据行，并没有说这两次执行是在同一个事务中）</li></ul><hr><p><font size="5">解决方法：四种隔离性分别是什么？</font></p><center><font size="2">√：可能会出现&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;×：不会出现</font></center><table><thead><tr><th align="center">隔离级别</th><th align="center">脏读</th><th align="center">不可重复读</th><th align="center">幻想毒</th></tr></thead><tbody><tr><td align="center">read uncommited（读未提交）</td><td align="center">√</td><td align="center">√</td><td align="center">√</td></tr><tr><td align="center">read commited（读提交）</td><td align="center">×</td><td align="center">√</td><td align="center">√</td></tr><tr><td align="center">read repeatable（读重复）</td><td align="center">×</td><td align="center">×</td><td align="center">√</td></tr><tr><td align="center">serializable（序列化）</td><td align="center">×</td><td align="center">×</td><td align="center">×</td></tr></tbody></table><ul><li>read uncommited：是最低的事务隔离级别，它允许另外一个事务可以看到这个事务未提交的数据。</li><li>read commited：保证一个事物提交后才能被另外一个事务读取。另外一个事务不能读取该事物未提交的数据。</li><li>repeatable read：这种事务隔离级别可以防止脏读，不可重复读。但是可能会出现幻象读。它除了保证一个事务不能被另外一个事务读取未提交的数据之外还避免了以下情况产生（不可重复读）。</li><li>serializable：这是花费最高代价但最可靠的事务隔离级别。事务被处理为顺序执行。除了防止脏读，不可重复读之外，还避免了幻象读。</li></ul><hr><p><strong>Mybatis中的事务</strong></p><blockquote><p>通过sqlsession对象的commit方法和rollback方法实现事务的提交和回滚</p></blockquote><blockquote><p>将SqlSessionFactory.openSession()方法给传一个true，即为SqlSessionFactory.openSession(true)就可以实现自动提交，不需要每次都手动提交了。该方法一般用于单表操作。多表操作一般用手动提交防止误操作</p></blockquote><hr><h2 id="Mybatis基于XML配置的动态SQL语句使用"><a href="#Mybatis基于XML配置的动态SQL语句使用" class="headerlink" title="Mybatis基于XML配置的动态SQL语句使用"></a>Mybatis基于XML配置的动态SQL语句使用</h2><h3 id="常用标签"><a href="#常用标签" class="headerlink" title="常用标签"></a>常用标签</h3><blockquote><p>&lt;if&gt;，&lt;where&gt;，&lt;forerch&gt;，&lt;sql&gt;</p></blockquote><h4 id="lt-if-gt"><a href="#lt-if-gt" class="headerlink" title="&lt;if&gt;"></a><strong>&lt;if&gt;</strong></h4><blockquote><p>写在&lt;select&gt;标签的sql语句里用作判断</p></blockquote><pre><code>&lt;select id=&quot;getAll&quot; resulType=&quot;src.main.java.user&quot; parameterType=&quot;src.main.java.user&quot;&gt;    Select * from user where 1=1    &lt;if test=&quot;name!=null&quot;&gt;        name=#{name}    &lt;/if&gt;&lt;/select&gt;</code></pre><p>说明：如果名字不等于空，则查询条件为1=1并且名字等于输入的名字</p><hr><h4 id="lt-where-gt"><a href="#lt-where-gt" class="headerlink" title="&lt;where&gt;"></a><strong>&lt;where&gt;</strong></h4><blockquote><p>写在&lt;select&gt;标签的sql语句里用作判断。如果有多个if需要加入可以使用where</p></blockquote><pre><code>&lt;select id=&quot;getAll&quot; resulType=&quot;src.main.java.user&quot; parameterType=&quot;src.main.java.user&quot;&gt;    Select * from user    &lt;where&gt;        &lt;if test=&quot;name!=null&quot;&gt;            name=#{name}        &lt;/if&gt;        &lt;if test=&quot;sex!=null&quot;&gt;            sex=#{sex}        &lt;/if&gt;    &lt;/where&gt;&lt;/select&gt;</code></pre><p>说明：如果名称不为空就将名称作为查询条件，如果性别不为空就将性别作为查询条件。如果两个都不为空就将两个都作为查询条件。多个条件之间用and进行拼接</p><hr><h4 id="lt-forerch-gt"><a href="#lt-forerch-gt" class="headerlink" title="&lt;forerch&gt;"></a><strong>&lt;forerch&gt;</strong></h4><blockquote><p>多用于子查询(in)</p></blockquote><pre><code>//实现Sql语句：select * from user where id in(1,2,3,4,5)select * from user&lt;where&gt;    &lt;if test=&quot;list!=null and list.size()&gt;0&quot;&gt;    //为了防止list集合为空的情况发生        &lt;foreach collection=&quot;lsit/需要遍历的集合&quot; open=&quot;and id in(/where条件的前半部分，表示循环后的内容都添加到这个后面&quot; close=&quot;)/表示where条件的结尾，所有循环结束之后添加的内容 &quot; item=&quot;id/遍历出来的内容临时存放地方&quot; separator=&quot;,/循环添加的内容直接用什么分隔&quot;&gt;            #{id/遍历出来的内容,item起的名字}        &lt;/foreach&gt;    &lt;/if&gt;&lt;/where&gt;</code></pre><blockquote><p>若传入的是list集合，collection的值为list；若传入的是数组，collection的值为array；若传入的是多参数，则需要封装为一个Map进行处理</p></blockquote><hr><h4 id="lt-sql-gt"><a href="#lt-sql-gt" class="headerlink" title="&lt;sql&gt;"></a><strong>&lt;sql&gt;</strong></h4><blockquote><p>当有多个查询的方法时，会写很多次select * from user。他们的区别一般都是where条件不同。这时候可以使用sql标签将重复的语句抽象出来</p></blockquote><pre><code>&lt;sql id=&quot;selectAll&quot;&gt;    Select * from user&lt;/sql&gt;</code></pre><blockquote><p>使用时：&lt;include refid=”selectAll”&gt;&lt;/include&gt;</p></blockquote><hr><h2 id="Mybatis中的多表操作"><a href="#Mybatis中的多表操作" class="headerlink" title="Mybatis中的多表操作"></a>Mybatis中的多表操作</h2><blockquote><p>创建一对多，一对一的实体类时需要的步骤</p></blockquote><ol><li>让有主外键关系的用户表和账户表分别创建实体类<ul><li>让用户和账户的实体类能体现一对多的关系(在用户实体类中创建List的泛型账户实体类) (在账户类中创建一个用户类的属性)</li></ul></li><li>建立两个配置文件<ul><li>用户的配置文件</li><li>账户的配置文件</li></ul></li><li>实现配置<ul><li>当查询用户时能获取多个属于该用户的账户</li><li>当查询账户时能获取属于这个账户的全部用户信息</li></ul></li></ol><p>注意：所有实体类都需要无参构造器，否则报错：Error querying database. Cause: org.apache.ibatis.executor.ExecutorException: No constructor found in 实体类名</p><h3 id="一对多"><a href="#一对多" class="headerlink" title="一对多"></a>一对多</h3><blockquote><p>在实体类的配置文件的标签&lt;mapper&gt;里加入&lt;resultMap&gt;</p></blockquote><pre><code>&lt;resultMap id=&quot;&quot; type=&quot;&quot;&gt;    //将用户实体类里的与数据库列名对应的属性填进去    &lt;id property=&quot;实体类名&quot; column=&quot;数据库列名&quot;&gt;&lt;/id&gt;    &lt;result property=&quot;实体类名&quot; column=&quot;数据库列名&quot;&gt;&lt;/result&gt;    //将用户表对应的账户表信息封装到用户实体类的账户集合里面去    &lt;collection property=&quot;用户表里的账户实体类属性名&quot; ofType=&quot;list的泛型类型/账户实体类名&quot;&gt;        //将账户实体类里的与数据库列名对应的属性填进去        &lt;id property=&quot;实体类名&quot; column=&quot;数据库列名&quot;&gt;&lt;/id&gt;        &lt;result property=&quot;实体类名&quot; column=&quot;数据库列名&quot;&gt;&lt;/result&gt;    &lt;/collection&gt;&lt;resultMap&gt;</code></pre><h3 id="一对一"><a href="#一对一" class="headerlink" title="一对一"></a>一对一</h3><blockquote><p>在实体类的配置文件的标签&lt;mapper&gt;里加入&lt;resultMap&gt;</p></blockquote><pre><code>&lt;resultMap id=&quot;&quot; type=&quot;&quot;&gt;    //将账户实体类里的与数据库列名对应的属性填进去    &lt;id property=&quot;实体类名&quot; column=&quot;数据库列名&quot;&gt;&lt;/id&gt;    &lt;result property=&quot;实体类名&quot; column=&quot;数据库列名&quot;&gt;&lt;/result&gt;    //将账户表对应的用户表信息封装到账户实体类的用户实体类属性里    &lt;association property=&quot;账户表里的用户实体类属性名&quot; column=&quot;数据库对应的列名/起的别名&quot; javaType=&quot;用户实体类的全地址&quot;&gt;        //将用户实体类里的与数据库列名对应的属性填进去        &lt;id property=&quot;实体类名&quot; column=&quot;数据库列名&quot;&gt;&lt;/id&gt;        &lt;result property=&quot;实体类名&quot; column=&quot;数据库列名&quot;&gt;&lt;/result&gt;    &lt;/association&gt;&lt;resultMap&gt;</code></pre><h3 id="多对多"><a href="#多对多" class="headerlink" title="多对多"></a>多对多</h3><blockquote><p>多对多数据表的创建</p></blockquote><p>示例：一个角色可以有多个身份。一个身份可以是多个角色的</p><blockquote><p>创建多对多实体类的步骤</p></blockquote><ol><li>创建两个多对多关系的表。需要使用中间表。中间表包含各自的主键，在中间表中是外键</li><li>让两个实体类各自包含对方的一个集合引用</li><li>实体类的配置文件</li><li>查询用户时能获得用户的角色信息，查询角色信息时能获得用户信息</li></ol><p><strong>什么表是多对多？</strong></p><blockquote><p>当一个表除主键以外有多个相同数据的列，只有一个列和这个列相关的数据不同。那么可以将这个列和相关的列单独做一个表，然后创一个中间表作为连接。这样就是多对多的关系</p></blockquote><center><font size="2">用户表</font><table><thead><tr><th align="center">id</th><th align="center">姓名</th><th align="center">性别</th><th align="center">年龄</th><th align="center">角色</th><th align="center">角色说明</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">张三</td><td align="center">男</td><td align="center">18</td><td align="center">学生</td><td align="center">学习</td></tr><tr><td align="center">2</td><td align="center">李四</td><td align="center">男</td><td align="center">20</td><td align="center">学生</td><td align="center">学习</td></tr><tr><td align="center">3</td><td align="center">王五</td><td align="center">男</td><td align="center">22</td><td align="center">学生</td><td align="center">学习</td></tr><tr><td align="center">4</td><td align="center">马六</td><td align="center">男</td><td align="center">24</td><td align="center">学生</td><td align="center">学习</td></tr><tr><td align="center">5</td><td align="center">马六</td><td align="center">男</td><td align="center">24</td><td align="center">子女</td><td align="center">服从父母</td></tr><tr><td align="center"></center></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr></tbody></table><blockquote><p>这时候马六除了角色这一列还有和角色相关的列之外其他的数据都相同。这个时候可以将角色和角色说明单独作为一个表，然后建立一个中间表形成多对多的关系</p></blockquote><center><table><thead><tr><th align="center">id</th><th align="center">姓名</th><th align="center">性别</th><th align="center">年龄</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">张三</td><td align="center">男</td><td align="center">18</td></tr><tr><td align="center">2</td><td align="center">李四</td><td align="center">男</td><td align="center">20</td></tr><tr><td align="center">3</td><td align="center">王五</td><td align="center">男</td><td align="center">22</td></tr><tr><td align="center">4</td><td align="center">马六</td><td align="center">男</td><td align="center">24</td></tr><tr><td align="center">5</td><td align="center">马六</td><td align="center">男</td><td align="center">24</td></tr></tbody></table><p><font size="2">学生表</font></center></p><center><table><thead><tr><th align="center">id</th><th align="center">角色</th><th align="center">角色说明</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">学生</td><td align="center">上学</td></tr><tr><td align="center">2</td><td align="center">子女</td><td align="center">服从父母</td></tr></tbody></table><p><font size="2">角色表</font></center></p><center><table><thead><tr><th align="center">学生id</th><th align="center">角色id</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">1</td></tr><tr><td align="center">2</td><td align="center">1</td></tr><tr><td align="center">3</td><td align="center">1</td></tr><tr><td align="center">4</td><td align="center">1</td></tr><tr><td align="center">5</td><td align="center">1</td></tr><tr><td align="center">6</td><td align="center">2</td></tr></tbody></table><p><font size="2">中间表</font></center><br>这就是表的多对多关系。中间表需要将两个表的主键作为外键</p><blockquote><p>在实体类的配置文件的标签&lt;mapper&gt;里加入&lt;resultMap&gt;</p></blockquote><blockquote><p>创建实体类需要满足：查询用户时能获得用户的角色信息，查询角色信息时能获得用户信息（List泛型可解决问题）</p></blockquote><pre><code>&lt;resultMap id=&quot;&quot; type=&quot;&quot;&gt;    //将用户实体类里的与数据库列名对应的属性填进去    &lt;id property=&quot;实体类名&quot; column=&quot;数据库列名&quot;&gt;&lt;/id&gt;    &lt;result property=&quot;实体类名&quot; column=&quot;数据库列名&quot;&gt;&lt;/result&gt;    //将用户表对应的角色表信息封装到用户实体类的角色集合里面去    &lt;collection property=&quot;用户表里的角色实体类属性名&quot; ofType=&quot;list的泛型类型/角色实体类名&quot;&gt;        //将角色实体类里的与数据库列名对应的属性填进去        &lt;id property=&quot;实体类名&quot; column=&quot;数据库列名&quot;&gt;&lt;/id&gt;        &lt;result property=&quot;实体类名&quot; column=&quot;数据库列名&quot;&gt;&lt;/result&gt;    &lt;/collection&gt;&lt;resultMap&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 入门 </tag>
            
            <tag> Mybatis </tag>
            
            <tag> 框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis框架(一)</title>
      <link href="/2020/01/15/mybatis-kuang-jia-yi/"/>
      <url>/2020/01/15/mybatis-kuang-jia-yi/</url>
      
        <content type="html"><![CDATA[<h1 id="Mybatis的概述"><a href="#Mybatis的概述" class="headerlink" title="Mybatis的概述"></a>Mybatis的概述</h1><blockquote><p>Mybatis是由Java编写的一个持久层（Dao）框架。他封装了很多jdbc的操作细节（加载驱动，创建连接…），使开发者只需要关注sql语句。同时，它使用了ORM思想实现了结果集的封装。</p></blockquote><h2 id="什么是框架"><a href="#什么是框架" class="headerlink" title="什么是框架"></a>什么是框架</h2><blockquote><p>他是我们软件开发中的一套解决方案。不同的框架决绝不同的问题</p></blockquote><h2 id="什么是ORM"><a href="#什么是ORM" class="headerlink" title="什么是ORM"></a>什么是ORM</h2><blockquote><p>Object Relational Mappging ：对象关系映射。把数据库表和实体类的属性一一对应，让我们可以操作实体类就实现操作数据库表</p></blockquote><div align=center><img src="../../img/44824/orm.jpg" width="300px" height="300px"></div><h2 id="为什么使用框架？-使用框架的好处"><a href="#为什么使用框架？-使用框架的好处" class="headerlink" title="为什么使用框架？/使用框架的好处"></a>为什么使用框架？/使用框架的好处</h2><blockquote><p>封装了很多的细节，使开发者可以使用极简的方法实现功能。大大提高开发效率</p></blockquote><hr><h2 id="使用Mybatis的准备"><a href="#使用Mybatis的准备" class="headerlink" title="使用Mybatis的准备"></a><strong>使用Mybatis的准备</strong></h2><h3 id="Mybatis环境搭建"><a href="#Mybatis环境搭建" class="headerlink" title="Mybatis环境搭建"></a>Mybatis环境搭建</h3><ul><li>创建Web项目<blockquote><p>右键空白处创建新项目——选择Maven——勾选Create a simple project(skip archetype selection)——输入Group(项目路径 如cn.Mybatis)，Artfact id（项目名称）——Finish</p></blockquote></li><li>加载jar包<blockquote><p>打开pom.xml——添加&lt;packaging]&gt;jar&lt;packaging&gt;（打包方式：jar）——添加&lt;dependencies&gt;标签。在&lt;dependencies&gt;标签内加入下列代码</p></blockquote></li></ul><pre><code>//加载Mybatis的jar包&lt;dependency&gt;    &lt;groupId&gt;org.mybatis&lt;/groupId&gt;    &lt;artifactId&gt;mybatis&lt;/artifactId&gt;    &lt;version&gt;3.4.5&lt;/version&gt;&lt;/dependency&gt;//加载数据库的jar包&lt;dependency&gt;    &lt;groupId&gt;mysql&lt;/groupId&gt;    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;    &lt;version&gt;5.1.6&lt;/version&gt;&lt;/dependency&gt;//加载日志的jar包&lt;dependency&gt;    &lt;groupId&gt;log4j&lt;/groupId&gt;    &lt;artifactId&gt;log4j&lt;/artifactId&gt;    &lt;version&gt;1.2.12&lt;/version&gt;&lt;/dependency&gt;//单元测试的jar包&lt;dependency&gt;    &lt;groupId&gt;junit&lt;/groupId&gt;    &lt;artifactId&gt;junit&lt;/artifactId&gt;    &lt;version&gt;4.10&lt;/version&gt;&lt;/dependency&gt;</code></pre><p>配置完后稍等，左侧菜单可能会报错。等待程序自己加载jar包</p><h3 id="创建实体类和Dao接口"><a href="#创建实体类和Dao接口" class="headerlink" title="创建实体类和Dao接口"></a>创建实体类和Dao接口</h3><blockquote><p>在项目路径src/main/java/里创建Dao。在创建实体类时注意实现Serializable接口。导入io的包</p></blockquote><h3 id="创建Mybatis主配置文件SqlMapConfig-xml"><a href="#创建Mybatis主配置文件SqlMapConfig-xml" class="headerlink" title="创建Mybatis主配置文件SqlMapConfig.xml"></a>创建Mybatis主配置文件SqlMapConfig.xml</h3><blockquote><p>在项目路径scr/main/resources/里创建SqlMapConfig.xml文件。并写入约束（可去官网查找复制）：</p></blockquote><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration  PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;  &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt;  &lt;environments default=&quot;mysql&quot;&gt;    &lt;environment id=&quot;mysql&quot;&gt;      &lt;transactionManager type=&quot;JDBC&quot;/&gt;      &lt;dataSource type=&quot;POOLED&quot;&gt;        &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;        &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/chatbbs&quot;/&gt;        &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;        &lt;property name=&quot;password&quot; value=&quot;root&quot;/&gt;      &lt;/dataSource&gt;    &lt;/environment&gt;  &lt;/environments&gt;  &lt;mappers&gt;    &lt;mapper resource=&quot;Mybatis/test1/Dao/bbsuserDao.xml&quot;/&gt;  &lt;/mappers&gt;&lt;/configuration&gt;</code></pre><hr><h2 id="准备Dao的配置文件"><a href="#准备Dao的配置文件" class="headerlink" title="准备Dao的配置文件"></a>准备Dao的配置文件</h2><h3 id="创建Dao的映射配置文件xml"><a href="#创建Dao的映射配置文件xml" class="headerlink" title="创建Dao的映射配置文件xml"></a>创建Dao的映射配置文件xml</h3><blockquote><p>在项目路径Dao接口下创建和Dao接口一样的映射配置文件Dao.xml。并写入约束：</p></blockquote><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;Mybatis.test1.Dao.bbsuserDao&quot;&gt;    &lt;!-- 执行的sql语句 --&gt;    &lt;select id=&quot;getAll&quot; resultType=&quot;用来接收的对象全路径名&quot;&gt;        select * from bbsuser    &lt;/select&gt;&lt;/mapper&gt;</code></pre><p>环境搭建的注意事项：</p><ol><li>创建userDao.xml和userDao.java时名称是为了和之前学习时保持一致。在Mybatis中把持久层的操作接口文件和映射也叫做：Mapper。所以userDao和userMapper是一样的</li><li>映射配置文件的mapper标签namespace属性的取值必须是dao的全限定类名（cn.jbit.dao.userDao）</li><li>映射配置文件的操作配置(select标签)，id的属性取值必须是dao接口的方法名</li></ol><hr><h2 id="使用Mybatis"><a href="#使用Mybatis" class="headerlink" title="使用Mybatis"></a>使用Mybatis</h2><blockquote><p>在指定路径src/test/java下创建运行文件</p></blockquote><pre><code>//1.读取配置文件InputStream in = Resources.getResourceAsStream(&quot;SqlMapConfig.xml&quot;);//2.创建SqlSessionFactory工厂SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(in);//3.使用工厂生产一个SqlSession对象SqlSession session = factory.openSession();//4.使用SqlSession创建Dao接口的代理对象bbsuserDao BbsuserDao = session.getMapper(bbsuserDao.class);//5.使用代理对象执行方法List&lt;bbsuser&gt; list = BbsuserDao.getAll();for(bbsuser user : list){    System.out.println(user);}//6.释放资源session.close();in.close();</code></pre><p>注意事项：</p><ol><li>做项目时2-4都可省略，只留下InputStream in = Resources.getResourceAsStream(“SqlMapConfig.xml”).getMapper(bbsuserDao.class);</li></ol><hr><h2 id="进行数据库操作"><a href="#进行数据库操作" class="headerlink" title="进行数据库操作"></a>进行数据库操作</h2><blockquote><p>当语句需要赋值的时候使用#{name}来将parameterType引用的对象属性给赋进去，例如：<br><insert id="addUser" parameterType="src/main/java/entiy/user" resultType="Integer"><br>insert into bbsuser values(#{id},#{name},#{password})<br><insert></p></blockquote><ul><li>传递参数用#{属性名}进行传递。如果是自动生成的set,get输入属性名就行，手写的set，get则需要输入set后面的方法名</li><li>1增删改数据最后需要手动提交事务sqlSession.commit();</li></ul><h3 id="增加"><a href="#增加" class="headerlink" title="增加"></a>增加</h3><pre><code>&lt;insert id=&quot;方法名&quot; parameterType=&quot;用来赋值的对象路径名&quot; resultType=&quot;用来接收的对象全路径名&quot;&gt;    Sql语句&lt;insert&gt;</code></pre><ul><li>如果结果要返回int则需要加上resultType=”integer”</li></ul><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><pre><code>&lt;delete id=&quot;方法名&quot; parameterType=&quot;Integer&quot;&gt;    Sql语句&lt;/update&gt;</code></pre><p>如果只有一个参数时，调用对象的占位符名称可以随便写，例如：#{a}或者写成#{abc}都可以</p><h3 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h3><pre><code>&lt;update id=&quot;方法名&quot; parameterType=&quot;用来赋值的对象全路径名&quot;&gt;    Sql语句&lt;/update&gt;</code></pre><h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><hr><h4 id="查询所有"><a href="#查询所有" class="headerlink" title="查询所有"></a>查询所有</h4><pre><code>&lt;select id=&quot;方法名&quot; resultType=&quot;用来接收的对象全路径名&quot;&gt;    select * from bbsuser&lt;/select&gt;</code></pre><p>如果有where条件可以加入属性:parameterType</p><h4 id="模糊查询"><a href="#模糊查询" class="headerlink" title="模糊查询"></a>模糊查询</h4><pre><code>&lt;select id=&quot;方法名&quot;  parameterType=&quot;用来赋值的对象路径名&quot; resultType=&quot;用来接收的对象全路径名&quot;&gt;    select * from bbsuser where name like #{name}&lt;/select&gt;</code></pre><ul><li>如果没有参数传递可以不用加parameterType标签</li><li>如果使用模糊查询则需要在传递参数的时候给参数加上对应的%，例如需要模糊查询姓张的学生则需要传入参数：张%</li><li>模糊查询还可以写成name like ‘%${value}%’，这样就不用再传参数的时候给参数加%了</li><li>参数加符号的方法是用的preparedStatement的占位符。而${value}用的是Statement用的是字符串的拼接，第一种因为是预处理，所以效率更高。而第二张则可能会被sql注入。所以大多使用第一种方法</li></ul><hr><h2 id="使用注解完成数据库操作"><a href="#使用注解完成数据库操作" class="headerlink" title="使用注解完成数据库操作"></a>使用注解完成数据库操作</h2><ul><li>在方法上面直接写@Select(sql语句)就可以不用配置Dao.xml直接使用。如果使用注解，SqlMapConfig.xml文件里的&lt;mapper resource=”Dao.xml路径”/&gt;就需要改成&lt;mapper class=”Dao.Java路径”/&gt;。如果使用xml文件，路径之间用”/“分隔如果使用注解，路径之间用”.”分隔</li><li>在方法上面使用@Before  表示在方法执行之前先调用该方法,只有执行@Test注解时才会调用</li><li>在方法上面使用@After  表示在方法执行之后调用该方法,只有执行@Test注解时才会调用</li><li>在方法上面使用@Test  表示执行该方法</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 入门 </tag>
            
            <tag> Mybatis </tag>
            
            <tag> 框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ajax交互拓展</title>
      <link href="/2020/01/11/ajax-jiao-hu-tuo-zhan/"/>
      <url>/2020/01/11/ajax-jiao-hu-tuo-zhan/</url>
      
        <content type="html"><![CDATA[<h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a><strong>说明</strong></h1><blockquote><p>由于通过原生JavaScript实现Ajax并处理响应相对比较复杂，还要考虑浏览器兼容性等一系列问题。JQuery中将Ajax相关的操作都进行了封装，提供了$.get()等方以简化Ajax开发。</p></blockquote><a id="more"></a><h2 id="get"><a href="#get" class="headerlink" title="$.get()"></a>$.get()</h2><pre><code>$.get(url[,data][,success][,dataType]) //语法</code></pre><center><font size="2">$.get()可选参数</font></center><table><thead><tr><th align="center">参数</th><th align="center">类型</th><th align="left"><center>说明</center></th></tr></thead><tbody><tr><td align="center">url</td><td align="center">String</td><td align="left"><font size="4" color="red"><strong>必选</strong></font>，规定请求发送到说明地方</td></tr><tr><td align="center">data</td><td align="center">PlainObject或String</td><td align="left"><font size="4" color="red"><strong>可选</strong></font>，回调函数。发送到服务器的数据</td></tr><tr><td align="center">success</td><td align="center">Function name(PlainObject data,String textStatus,jqXHR jqxhr){}</td><td align="left"><font size="4" color="red"><strong>可选</strong></font>，<em>请求成功后调用的参数</em><br/><strong>Data</strong>：<font size="4" color="red"><strong>可选</strong></font>，<em>服务器返回的结果数据<br/><strong>TextStatus</strong>：<font size="4" color="red"><strong>可选</strong></font>。描述请求状态的字符串</em><br/><strong>jqxhr</strong>：<font size="4" color="red"><strong>可选</strong></font>，<em>jqXHR是XMLHttpReauest的超集如果指定了dataType参数则必须提供此参数。如果没有试镜需要处理，可以使用null或jQuery.noop()空方法做占位符</em></td></tr><tr><td align="center">dataType</td><td align="center">String</td><td align="left"><font size="4" color="red"><strong>可选</strong></font>，<em>预计服务器返回数据类型，可用类型有：</em> <strong>XML</strong>，<strong>HTML</strong>，<strong>SCRIPT</strong>，<strong>JSON</strong>，<strong>JSONS</strong>，<strong>Text</strong></td></tr></tbody></table><blockquote><blockquote><p>例：使用get方法将name为张三的信息传递到Serverlet里去并接受返回Text类型的数据</p></blockquote></blockquote><pre><code>$.get(“ServerletUrl”,”name=张三”,function name(data){},”Text”)</code></pre><hr><h2 id="post"><a href="#post" class="headerlink" title="$.post()"></a><strong>$.post()</strong></h2><pre><code>$.post(url[,data][,success][,dataType])    //语法</code></pre><center><font size="2">$.post()可选参数</font></center><table><thead><tr><th align="center">参数</th><th align="center">类型</th><th align="left"><center>说明</center></th></tr></thead><tbody><tr><td align="center">url</td><td align="center">String</td><td align="left"><font size="4" color="red"><strong>必选</strong></font>，规定请求发送到说明地方</td></tr><tr><td align="center">data</td><td align="center">PlainObject或String</td><td align="left"><font size="4" color="red"><strong>可选</strong></font>，回调函数。发送到服务器的数据</td></tr><tr><td align="center">success</td><td align="center">Function name(PlainObject data,String textStatus,jqXHR jqxhr){}</td><td align="left"><font size="4" color="red"><strong>可选</strong></font>，<em>请求成功后调用的参数</em><br/><strong>Data</strong>：<font size="4" color="red"><strong>可选</strong></font>，<em>服务器返回的结果数据<br/><strong>TextStatus</strong>：<font size="4" color="red"><strong>可选</strong></font>。描述请求状态的字符串</em><br/><strong>jqxhr</strong>：<font size="4" color="red"><strong>可选</strong></font>，<em>jqXHR是XMLHttpReauest的超集如果指定了dataType参数则必须提供此参数。如果没有试镜需要处理，可以使用null或jQuery.noop()空方法做占位符</em></td></tr><tr><td align="center">dataType</td><td align="center">String</td><td align="left"><font size="4" color="red"><strong>可选</strong></font>，<em>预计服务器返回数据类型，可用类型有：</em> <strong>XML</strong>，<strong>HTML</strong>，<strong>SCRIPT</strong>，<strong>JSON</strong>，<strong>JSONS</strong>，<strong>Text</strong></td></tr></tbody></table><blockquote><blockquote><p>例：使用post方法将name为张三的信息传递到Serverlet里去并接受返回Text类型的数据</p></blockquote></blockquote><pre><code>$.post(“ServerletUrl”,”name=张三”,function name(data){},”Text”)</code></pre><hr><h2 id="getJSON"><a href="#getJSON" class="headerlink" title="$.getJSON()"></a><strong>$.getJSON()</strong></h2><blockquote><p>由于经常使用JSON格式作为相应内容的载体，为了简化方法调用。Jquery提供了$.getJSON()方法，需要注意的是getJSON的提交方式默认是get，也只能是get</p></blockquote><pre><code>$.getJSON(url[,data][,success]) //语法</code></pre><center><font size="2">$.getJSON()可选参数</font></center><table><thead><tr><th align="center">参数</th><th align="center">类型</th><th align="left"><center>说明</center></th></tr></thead><tbody><tr><td align="center">url</td><td align="center">String</td><td align="left"><font size="4" color="red"><strong>必选</strong></font>，规定请求发送到说明地方</td></tr><tr><td align="center">data</td><td align="center">PlainObject或String</td><td align="left"><font size="4" color="red"><strong>可选</strong></font>，回调函数。发送到服务器的数据</td></tr><tr><td align="center">success</td><td align="center">Function name(PlainObject data,String textStatus,jqXHR jqxhr){}</td><td align="left"><font size="4" color="red"><strong>可选</strong></font>，<em>请求成功后调用的参数</em><br/><strong>Data</strong>：<font size="4" color="red"><strong>可选</strong></font>，<em>服务器返回的结果数据<br/><strong>TextStatus</strong>：<font size="4" color="red"><strong>可选</strong></font>。描述请求状态的字符串</em><br/><strong>jqxhr</strong>：<font size="4" color="red"><strong>可选</strong></font>，<em>jqXHR是XMLHttpReauest的超集如果指定了dataType参数则必须提供此参数。如果没有试镜需要处理，可以使用null或jQuery.noop()空方法做占位符</em></td></tr></tbody></table><blockquote><blockquote><p>例：将name为张三的信息传递到Serverlet里去并默认用JSON格式接受数据</p></blockquote></blockquote><pre><code>$.getJSON(“ServerletUrl”,”name=张三”,function name(data){})</code></pre><hr><h2 id="在ajax中直接返回HTML内容"><a href="#在ajax中直接返回HTML内容" class="headerlink" title="在ajax中直接返回HTML内容"></a><strong>在ajax中直接返回HTML内容</strong></h2><blockquote><p>从Serverlet获取的结果在JSP页面显示出来会增加很多代码量，使用该方法可以在Serverlet页面将结果转换成Html标签，然后直接在节点上显示出来</p></blockquote><pre><code>$(selectedor).load(url[,data][,complete])   //语法 </code></pre><center><font size="2">$.getJSON()可选参数</font></center><table><thead><tr><th align="center">参数</th><th align="center">类型</th><th align="left"><center>说明</center></th></tr></thead><tbody><tr><td align="center">url</td><td align="center">String</td><td align="left"><font size="4" color="red"><strong>必选</strong></font>，规定请求发送到说明地方</td></tr><tr><td align="center">data</td><td align="center">PlainObject或String</td><td align="left"><font size="4" color="red"><strong>可选</strong></font>，回调函数。发送到服务器的数据</td></tr><tr><td align="center">complete</td><td align="center">Function name(PlainObject data,String textStatus,jqXHR jqxhr){}</td><td align="left"><font size="4" color="red"><strong>可选</strong></font>，<em>请求成功后调用的参数</em><br/><strong>Data</strong>：<font size="4" color="red"><strong>可选</strong></font>，<em>服务器返回的结果数据</em><br/><strong>TextStatus</strong>：<font size="4" color="red"><strong>可选</strong></font>,<em>描述请求状态的字符串</em><br/><strong>jqxhr</strong>：<font size="4" color="red"><strong>可选</strong></font>，<em>jqXHR是XMLHttpReauest的超集。</em></td></tr></tbody></table><blockquote><p>该方法直接将返回的HTML类型的内容直接添加到指定的元素中。该方法默认使用get方法发送请求。除非提供的data是一个对象则使用post方式发送请求</p></blockquote><hr><h2 id="使用jQuery解析表单数据"><a href="#使用jQuery解析表单数据" class="headerlink" title="使用jQuery解析表单数据"></a><strong>使用jQuery解析表单数据</strong></h2><blockquote><p>serializeArray()</p></blockquote><p>该方法会将一组表单元素中检测有效控件，将其序列化为name和value两个属性构成的JSON对象数组。该方法的规则是：</p><ol><li>元素不能被禁用</li><li>元素必须有name属性</li><li>选中的checkbox才是有效的</li><li>选中的radio才是有效的</li><li>只有出发提交时间的submit按钮才是有效的</li><li>File元素不会被序列化</li></ol><p>使用时最后一步需要将其转化成请求<font color="red">字符串</font><br/><br>该方法是将数据转为<em>JSON<em>格式 *</em>[{“name”:”张三”,”age”:”18”},{“name”:”李四”,”age”:”20”}]**。<br>如果需要把内容变成name=张三&amp;age=李四这种格式的字符串则需要用</em>$.param()*方法将其转换</p><hr><h2 id="使用FastJSON生成JSON字符串"><a href="#使用FastJSON生成JSON字符串" class="headerlink" title="使用FastJSON生成JSON字符串"></a><strong>使用FastJSON生成JSON字符串</strong></h2><blockquote><p>为什么要使用FastJSON？</p></blockquote><p>将多个对象转换成JSON格式传递给页面如果用手写会很复杂，如果使用FastJSON则能节约代码</p><blockquote><p>怎么使用FastJSON？</p></blockquote><p>在<a href="https://github.com/alibaba/fastjson/releases" target="_blank" rel="noopener">官网</a>选择对应版本jar文件和源代码下载路径<br>由于FastJSON方法大多是static修饰的，所以可以直接通过类名.方法使用。入口类com.alibaba.fastjson.JSON</p><center><font size="2">常用方法</font></center><table><thead><tr><th align="center">方法</th><th align="left"><center>说明</center></th></tr></thead><tbody><tr><td align="center">Public static String toJSONString(Object object)</td><td align="left">将java对象转换成JSON字符串，不能转换日期格式的属性，会报错</td></tr><tr><td align="center">Public static String toJSONString(Object object,boolean fprettyFormat)</td><td align="left">fprettyFormat为true时产生带格式的JSON字符串，为false与toJSONString(Object object)相同</td></tr><tr><td align="center">Public static String toJSONString(Object oject,SerializeFeatrue…featrue)</td><td align="left">可以通过featrue参数指定更多序列化规则</td></tr><tr><td align="center">Public static String toJSONStringWithDateFormat(Object object,String DateFormat,SerialiFeatrue…featrue)</td><td align="left">可以通过dateFormat参数指定日期类型的输入格式。<br/>可以转换时间类型    (yyyy-MM-dd HH:mm:ss/年月日时分秒)</td></tr></tbody></table><p><font size="5">SerializeFeatrue定义了多种序列化属性，属性及说明如下</font></p><pre><code>QuoteFiedldNames    //输出JSON的字段名时使用双引号，默认引用WriteMapNullValue   //输出值为null的字段，默认不输出WriteNullListAsEmpty    //将值为null的list字段输出为[]WriteNullStringAsEmpty  //将值为null的String字段输出为””WriteNullNumberAsEmpty  //将值为null的数值字段输出为0WriteNullBooleanAsFalse //将值为null的Boolean字段输出为falseSkipTransienFiedld  //忽略transient字段，默认及忽略PrettyFormat    //格式化JSON字符串，默认不格式化</code></pre><blockquote><p>例：JSON.toJSONStringWithDateFormat(list,”yyyy-MM-dd HH:mm:ss”,WriteMapNullValue,WriteNullListAsEmpty,WriteNullListAsEmpty);</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ajax </tag>
            
            <tag> 入门 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ajax的基本运用</title>
      <link href="/2020/01/08/ajax-de-ji-ben-yun-yong/"/>
      <url>/2020/01/08/ajax-de-ji-ben-yun-yong/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h2 id="Ajax是什么"><a href="#Ajax是什么" class="headerlink" title="Ajax是什么"></a>Ajax是什么</h2><blockquote><p>Ajax是一种技术方案，但并不是一种新技术。它依赖现有的CSS/HTML/JavaScript，而其中最核心的依赖是浏览器提供的XMLHttpRequest对象，这个对象使得浏览器可以发出HTTP请求与接收HTTP响应。实现了在页面不刷新的情况下和服务器进行数据交互。</p></blockquote><h2 id="为什么要使用Ajax-Ajax的好处"><a href="#为什么要使用Ajax-Ajax的好处" class="headerlink" title="为什么要使用Ajax / Ajax的好处"></a>为什么要使用Ajax / Ajax的好处</h2><blockquote><p>在传统的web应用中，每次请求都生成新的页面，前一个请求没响应则后一个请求不能发送。Ajax就是为了弥补的不足而诞生的。使用Ajax可以进行局部刷新数据。</p></blockquote><h2 id="ajax的常用参数"><a href="#ajax的常用参数" class="headerlink" title="$.ajax的常用参数"></a>$.ajax的常用参数</h2><table><thead><tr><th align="center"><strong><center>参数</center></strong></th><th align="center"><strong><center>类型</center></strong></th><th align="left"><strong><center>说明</center></strong></th></tr></thead><tbody><tr><td align="center">url</td><td align="center">String</td><td align="left"><strong>发送请求的地址，默认为当前地址;</strong></td></tr><tr><td align="center">type</td><td align="center">String</td><td align="left"><strong>请求方式</strong>（<em>post/get;默认get</em>）<strong>，1.9.0后可用method替换</strong>;</td></tr><tr><td align="center">data</td><td align="center">PlainObject或String或Arra</td><td align="left"><strong>发送到服务器的数据</strong>;</td></tr><tr><td align="center">dataType</td><td align="center">String</td><td align="left"><strong>预期返回的数据类型，可用的有</strong> <em>XML，HTML，Scipt，JSON，JSONP，Text</em>;</td></tr><tr><td align="center">beforeSend</td><td align="center">function(jqXHR jqxhr,PlainObject settings){}</td><td align="left"><strong>发送请求前调用的函数，返回false将终止发送参数</strong>;<br/><br/><strong>jqxhr</strong>：<em>可选，是XMLHttpRequest的超集</em>;<br/><br/><strong>settings</strong>：<em>可选，当前ajax方法的settings对象</em>;</td></tr><tr><td align="center">success</td><td align="center">function(任意类型 result,String textStatus,jqXHR jqxhr){}</td><td align="left"><strong>请求成功后调用的参数参数</strong>;<br/><br/><strong>result</strong>：<em>可选，由服务器返回的数据</em>;<br/><br/><strong>textStatus</strong>：<em>可选，描述请求状态的字符串</em>;<br/><br/><strong>jqxhr</strong>：<em>可选</em>;</td></tr><tr><td align="center">error</td><td align="center">function(jqXHR jqxhr,String textStatus,String errorThrown){}</td><td align="left"><strong>请求失败时调用的函数参数</strong><br/><br/><strong>jqxhr</strong>：<em>可选</em><br/><br/><strong>textStatus</strong>：<em>可选，错误信息</em><br/><br/><em>errorThrown*<em>：</em>可选，文本描述的Http状态</em></td></tr><tr><td align="center">complete</td><td align="center">function(任意类型 result,String textStatus){}</td><td align="left"><strong>请求完成后调用的函数（请求成功或失败均调用）</strong>;<br/><br/> <strong>jqxhr</strong>：<em>可选</em>;<br/><br/><strong>textStatus</strong>：<em>可选，描述请求状态的字符串</em>;</td></tr><tr><td align="center">timeout</td><td align="center">Number</td><td align="left"><strong>设置请求超时时间</strong></td></tr><tr><td align="center">global</td><td align="center">Boolean</td><td align="left"><strong>默认为</strong> <em>true</em> <strong>，表示是否出触发全局Ajax事件</strong></td></tr></tbody></table><center><font size="2">$.ajax 常用参数</font></center><hr><h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><pre><code>$.ajax([settings])  //[settings]:配置项，均为键值对格式</code></pre><ul><li><h2 id="JSP页面"><a href="#JSP页面" class="headerlink" title="JSP页面"></a>JSP页面</h2></li></ul><pre><code>$.ajax({    &quot;url&quot;:&quot;Serverlet&quot;,                    //提交的url(Serverlet名字)路径    &quot;type&quot;:&quot;get/post&quot;,                    //提交方式(分为get和post)    &quot;data&quot;:&quot;name=&quot;+userName,            //传递参数    &quot;dataType&quot;:&quot;text&quot;,                    //返回类型(预计返回类型，有：XML，HTML，Scipt，JSON，JSONP，Text)    &quot;success&quot;:function(data){  },        //执行成功后运行方法    &quot;error&quot;:&quot;function(data){  }&quot;        //执行失败后运行方法})</code></pre><hr><ul><li><h2 id="Serverlet类"><a href="#Serverlet类" class="headerlink" title="Serverlet类"></a>Serverlet类</h2></li></ul><blockquote><p>注意：servlet类需要继承httpservlet，然后实现get和post方法。根据提交的方式不同，进入的方法也不相同</p></blockquote><pre><code>public void doPost(HttpServletRequest request,HttpServletResponse response){    response.setContentType(&quot;text/html;charset=UTF-8&quot;);    PrintWriter out = response.getWriter();    Out.print();    //将结果返回给JSP页面    Out.flush();    Out.close();}</code></pre><hr><h2 id="JSON格式的处理"><a href="#JSON格式的处理" class="headerlink" title="JSON格式的处理"></a>JSON格式的处理</h2><ul><li><strong><font size="2">当dataType为JSON时，处理JSON格式的相应数据</font></strong></li></ul><blockquote><p>JSON（JavaScript Object Notation）是一种轻量级的数据交互格式。JSON类似于实体类对象。通常用语服务器和客户端之间传递数据</p></blockquote><ul><li><p><strong>JSON定义</strong></p><ol><li><p>定义单个对象</p><pre><code> let user = {&quot;name&quot;:&quot;张三&quot;,&quot;age&quot;:&quot;18,:&quot;sex&quot;:&quot;男&quot;}</code></pre><p> 该JSON存储了一个user对象，拥有属性name，age，sex。并拥有默认值。键值对之间 用‘:’分隔。属性之间用‘,’分隔。</p></li><li><p>定义多个对象</p><pre><code> let user = [{&quot;name&quot;:&quot;张三&quot;,&quot;age&quot;:&quot;18,:&quot;sex&quot;:&quot;男&quot;},{&quot;name&quot;:&quot;李四&quot;,&quot;age&quot;:&quot;18,:&quot;sex&quot;:&quot;男&quot;]</code></pre><p> 该JSON存储了2个对象，都有属性name,age,sex，并给了默认值。存储多个对象式需要用[]进行包裹。对象与对象之间用‘，’分隔。</p></li></ol></li></ul>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ajax </tag>
            
            <tag> 入门 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JSTL和EL</title>
      <link href="/2019/12/30/jstl-he-el/"/>
      <url>/2019/12/30/jstl-he-el/</url>
      
        <content type="html"><![CDATA[<h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a><strong>说明</strong></h1><blockquote><p>从后端接收数据并显示出来时如果使用JAVA代码展示数据会让页面变得臃肿。而使用JSTL和EL可以实现无JAVA代码嵌入的JSP页面开发的同时提高可读性</p></blockquote><a id="more"></a><h2 id="EL表达式"><a href="#EL表达式" class="headerlink" title="EL表达式"></a>EL表达式</h2><h3 id="什么是EL表达式"><a href="#什么是EL表达式" class="headerlink" title="什么是EL表达式"></a><strong>什么是EL表达式</strong></h3><blockquote><p>全称是Expression Language。它是一种借鉴了JavaScript和XPath的表达式语言。它能够使开发人员更方便的访问上下文，而无需再JSP页面嵌入Java代码。从而使开发人员不必熟悉Java也能轻松编写JSP程序</p></blockquote><h3 id="EL表达式语法"><a href="#EL表达式语法" class="headerlink" title="EL表达式语法"></a><strong>EL表达式语法</strong></h3><pre><code>${EL 表达式}//语法</code></pre><h3 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a><strong>操作符</strong></h3><ul><li>“.”操作符<blockquote><p>  可以通过”.”来访问对象的属性，例如${user.name} 就是通过EL表达式获取user对象里面的私有属性name</p></blockquote></li><li>“[]”操作符</li></ul><blockquote><p>  可以通过[]来访问对象的属性，例如${user[“name”]} 与”.”不同的是就算属性名包含”.”或者”-“等特殊字符，[]也能访问</p></blockquote><blockquote><p>  []还可以访问数组的元素，例如${list[0]} </p></blockquote><blockquote><p>  []还可以实现动态访问，例如${user[name]} 这时，name是一个变量名，通过改变变量名就可以实现获取user里面不同的属性</p></blockquote><h4 id="关系操作符"><a href="#关系操作符" class="headerlink" title="关系操作符"></a><strong>关系操作符</strong></h4><center>在表达式里可以写关系操作符来获取结果</center><table><thead><tr><th align="center">关系操作符</th><th align="center">说明</th><th align="center">示例</th><th align="center">结果</th></tr></thead><tbody><tr><td align="center">==或eq</td><td align="center">等于</td><td align="center">${“name” == “name”}</td><td align="center">true</td></tr><tr><td align="center">!=或ne</td><td align="center">不等于</td><td align="center">${“name” != “name”}</td><td align="center">false</td></tr><tr><td align="center">&lt;或者lt</td><td align="center">小于</td><td align="center">${10 &lt; 20}</td><td align="center">false</td></tr><tr><td align="center">&gt;或gt</td><td align="center">大于</td><td align="center">${10 &gt; 20}</td><td align="center">false</td></tr><tr><td align="center">==或eq</td><td align="center">小于等于</td><td align="center">${10 &lt;= 10}</td><td align="center">true</td></tr><tr><td align="center">==或eq</td><td align="center">大于等于</td><td align="center">${10 &gt;=10}</td><td align="center">true</td></tr></tbody></table><h4 id="逻辑操作符"><a href="#逻辑操作符" class="headerlink" title="逻辑操作符"></a><strong>逻辑操作符</strong></h4><pre><code>|逻辑操作符|说明|示例|结果||:--:|:--:|:--:|:--:||&amp;&amp;或and|逻辑与|如果A为true B为false 例：${A &amp;&amp; B}|False||&amp;##124;&amp;##124;或or|逻辑或|如果A为true B为false 例：${A &amp;##124;&amp;##124; B}|True||!或not|逻辑非|如果A为true 例：${!A}|False|</code></pre><h4 id="Empty操作符"><a href="#Empty操作符" class="headerlink" title="Empty操作符"></a><strong>Empty操作符</strong></h4><blockquote><p>Empty是一个前缀操纵符，用于检测一个变量是否为null 或者为empty(如长度为0的字符串变量或集合变量) 例 变量a不存在， ${Empty a} 返回为true ${not Empty a}返回为false</p></blockquote><h3 id="EL表达式隐式对象"><a href="#EL表达式隐式对象" class="headerlink" title="EL表达式隐式对象"></a><strong>EL表达式隐式对象</strong></h3><blockquote><p>JSP提供了page、request、session、application、pageContext等若干隐式对象。EL隐式对象按照途径的不同分为作用域访问对象，参数访问对象和JSP隐式对象</p></blockquote><table><thead><tr><th align="center">对象名称</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">pageScope</td><td align="center">与页面作用域(page)中的属性关联的Map类</td></tr><tr><td align="center">requestScope</td><td align="center">与请求作用于(request)中的属性关联的Map类</td></tr><tr><td align="center">sessionScope</td><td align="center">与会话作用域(session)中的属性关联的Map类</td></tr><tr><td align="center">applicationScope</td><td align="center">与应用程序作用域(application)中的属性关联的Map类</td></tr></tbody></table><center>作用域访问对象</center><blockquote><p>当使用EL表达式访问变量时，应制定查找范围。如${requestScope.name} 即在作用域范围内查找name变量。如果不指定范围，如${name} 则会按照page-request-session-application的顺序进行查找变量name</p></blockquote><hr><h2 id="JSTL"><a href="#JSTL" class="headerlink" title="JSTL"></a><strong>JSTL</strong></h2><h3 id="什么是JSTL"><a href="#什么是JSTL" class="headerlink" title="什么是JSTL"></a><strong>什么是JSTL</strong></h3><blockquote><p>JSTL的全称是Java Server Pages Standard Tag Library。它包含了开发JSP页面时经常用到的一组标准标签，这些标签提供了一种不用嵌入Java代码就能开发复杂的JSP页面的途径</p></blockquote><h3 id="为什么使用JSTL"><a href="#为什么使用JSTL" class="headerlink" title="为什么使用JSTL"></a><strong>为什么使用JSTL</strong></h3><blockquote><p>由于EL表达式不能实现逻辑控制，遍历，循环等功能。如果在开发JSP页面时除了编写Java脚本，还能使用JSTL来实现这个功能</p></blockquote><h3 id="如何使用JSTL"><a href="#如何使用JSTL" class="headerlink" title="如何使用JSTL"></a><strong>如何使用JSTL</strong></h3><blockquote><ul><li>导入jstl.jar和standard.jar两个jar包</li><li>在创建Web项目时，勾选J2EE 如果选中更低的版本则需要勾选下面的 Add JSTL Libraries to WEB-INF/lib folder</li><li>3.在需要使用JSTL的页面使用taglib指令导入标签库描述符文件：&lt;%@ taglib url=”<a href="http://java.sun.com/jsp/jstl/core&quot;" target="_blank" rel="noopener">http://java.sun.com/jsp/jstl/core&quot;</a> prefix=”c”%&gt;</li></ul></blockquote><h3 id="JSTL核心标签库"><a href="#JSTL核心标签库" class="headerlink" title="JSTL核心标签库"></a><strong>JSTL核心标签库</strong></h3><p>除了设置的变量名，都可以用EL表达式</p><h4 id="通用标签库"><a href="#通用标签库" class="headerlink" title="通用标签库"></a>通用标签库</h4><blockquote><p>通用标签库用于在JSP页面设置，显示和删除变量。它包含三个标签：&lt;c:set&gt;，&lt;c:out&gt;，&lt;c:remove&gt;</p></blockquote><h5 id="lt-c-set-gt-标签"><a href="#lt-c-set-gt-标签" class="headerlink" title="&lt;c:set&gt;标签"></a>&lt;c:set&gt;标签</h5><ol><li><strong>将a存储到范围为request的变量b中</strong></li></ol><pre><code>&lt;c:set var=&quot;b&quot; value=&quot;a&quot; scope=&quot;request&quot;&gt;</code></pre><p>Var：变量名<br>Value：变量的值<br>Scope：变量的作用域，可替换为request，session，page，application</p><ol start="2"><li><strong>将a作为变量存储到对象c里</strong></li></ol><pre><code>&lt;c:set value=&quot;a&quot; target=&quot;c&quot; property=&quot;b&quot;&gt;</code></pre><p>Value：存储到对象里面的值<br>Property：存储到对象里的名称<br>Target：存储的对象名</p><hr><h5 id="lt-c-out-gt-标签"><a href="#lt-c-out-gt-标签" class="headerlink" title="&lt;c:out&gt;标签"></a>&lt;c:out&gt;标签</h5><blockquote><p>类似JSP中的&lt;%=%&gt;</p></blockquote><pre><code>&lt;c:out value=&quot;a&quot; default=&quot;b&quot;&gt;</code></pre><p>Value：输出的变量名<br>Default：value的值为空的时候输出的内容，该属性可以不写</p><hr><h5 id="lt-c-remove-gt-标签"><a href="#lt-c-remove-gt-标签" class="headerlink" title="&lt;c:remove&gt;标签"></a>&lt;c:remove&gt;标签</h5><pre><code>&lt;c:remover var=&quot;a&quot; scope=&quot;page&quot;&gt;</code></pre><p>Var：移除的变量名<br>Scope：移除的变量范围，默认为page。可选的范围有：page，request，session，application</p><hr><h4 id="条件标签库"><a href="#条件标签库" class="headerlink" title="条件标签库"></a>条件标签库</h4><blockquote><p>JSTL的条件标签包括&lt;c:if&gt;，&lt;c:choose&gt;，&lt;c:when&gt;，&lt;c:otherwise&gt;</p></blockquote><h5 id="lt-c-if-gt"><a href="#lt-c-if-gt" class="headerlink" title="&lt;c:if&gt;"></a>&lt;c:if&gt;</h5><pre><code>&lt;c:if test=&quot;${user.flag}&quot; var=&quot;a&quot; scope=&quot;request&quot;&gt;    内容&lt;/c:if&gt;</code></pre><p>Test：判断条件当结果为true时执行里面的内容<br>Var：定义变量，用来存储判断结果。可省略<br>Scope：指定var变量的存储范围，可省略。可选值有：page，request，session，application</p><hr><h5 id="lt-c-choose-gt-，-lt-c-when-gt-，-lt-c-otherwise-gt"><a href="#lt-c-choose-gt-，-lt-c-when-gt-，-lt-c-otherwise-gt" class="headerlink" title="&lt;c:choose&gt;，&lt;c:when&gt;，&lt;c:otherwise&gt;"></a>&lt;c:choose&gt;，&lt;c:when&gt;，&lt;c:otherwise&gt;</h5><blockquote><p>和&lt;c:when&gt;，&lt;c:otherwise&gt;一起使用类似Java的 if-else if-else</p></blockquote><pre><code>&lt;c:choose var=&quot;${user.flag}&quot; scope=&quot;page&quot;&gt;    &lt;c:when test=&quot;${user.flag}&quot;&gt;        内容    &lt;/c:when&gt;    &lt;c:otherwise&gt;        内容    &lt;/c:otherwise&gt;&lt;/c:choose&gt;</code></pre><p>&lt;c:when&gt;：必须写在&lt;c:choose&gt;里面。作为Java里面的if和else if存在。必须在&lt;c:otherwise&gt;之前存在。可写多个，从上至下运行。当一个test=true时，进入代码块，其他的&lt;c:when&gt;不会执行</p><p>&lt;c:otherwise&gt;：必须写在&lt;c:choose&gt;里面。当没有&lt;c:choose&gt;执行时，执行该代码块</p><hr><h4 id="迭代标签库"><a href="#迭代标签库" class="headerlink" title="迭代标签库"></a>迭代标签库</h4><blockquote><p>用于遍历集合对象，例如list，lterator等。它包含一个标签：&lt;c:forEach&gt;</p></blockquote><h5 id="遍历集合对象"><a href="#遍历集合对象" class="headerlink" title="遍历集合对象"></a><strong>遍历集合对象</strong></h5><pre><code>&lt;c:forEach var=&quot;&quot; items=&quot;&quot; varStatus=&quot;&quot; begin=&quot;&quot; end=&quot;&quot; step=&quot;&quot;&gt;    主题&lt;/c:forEach&gt;</code></pre><p>Var：对当前成员的引用，如循环到第一个成员，则引用第一个成员。如果循环到第二个成员，则用第二个成员。以此类推<br>Items：被迭代的对象，可用EL表达式<br>VarStatus：用于存放var引用成员的相关信息，如索引。类似for循环的i<br>Begin：开始位置，默认0。可省略<br>End：结束位置。可省略<br>Step：循环的步长，默认为1。可省略</p><hr><h5 id="指定语句的执行次数"><a href="#指定语句的执行次数" class="headerlink" title="指定语句的执行次数"></a><strong>指定语句的执行次数</strong></h5><pre><code>&lt;c:forEach var=&quot;&quot; varStatus=&quot;&quot; begin=&quot;&quot; end=&quot;&quot; step=&quot;&quot;&gt;    主题&lt;/c:forEach&gt;</code></pre><p>Var：当前成员的引用<br>VarStatus：用于存放var引用成员的相关信息，如索引。类似for循环的i<br>Begin：开始位置，默认0。可省略<br>End：结束位置。可省略<br>Step：循环的步长，默认为1。可省略</p>]]></content>
      
      
      <categories>
          
          <category> JSP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JSTL </tag>
            
            <tag> EL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Tomcat的基本操作</title>
      <link href="/2019/12/29/tomcat-de-ji-ben-cao-zuo/"/>
      <url>/2019/12/29/tomcat-de-ji-ben-cao-zuo/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是Tomcat"><a href="#什么是Tomcat" class="headerlink" title="什么是Tomcat"></a>什么是Tomcat</h1><p><img src="../../img/47459/TomcatImg.jpg" alt="Tomcat"></p><blockquote><p>Tmocat是一个免费的开源的Web容器。作为Jsp的容器，是在Sun公司的JSWDK（Java Server Web Development Kit）基础上发展起来的一个JSP标准实现。</p></blockquote><a id="more"></a><hr><h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a><strong>目录</strong></h1><ul><li><h2 id="Tomcat的获取和安装"><a href="#Tomcat的获取和安装" class="headerlink" title="Tomcat的获取和安装"></a>Tomcat的获取和安装</h2><ul><li>Tomcat的获取</li><li>Tomcat的安装</li></ul></li><li><h2 id="Tomcat的目录结构"><a href="#Tomcat的目录结构" class="headerlink" title="Tomcat的目录结构"></a>Tomcat的目录结构</h2><ul><li>目录说明</li></ul></li><li><h2 id="将Tomcat部署到Myeclipse"><a href="#将Tomcat部署到Myeclipse" class="headerlink" title="将Tomcat部署到Myeclipse"></a>将Tomcat部署到Myeclipse</h2><ul><li>在Myeclipse中配置Tomcat</li><li>将Tomcat部署到Myeclipse</li></ul></li></ul><hr><h2 id="Tomcat-的获取和安装"><a href="#Tomcat-的获取和安装" class="headerlink" title="Tomcat 的获取和安装"></a><strong>Tomcat 的获取和安装</strong></h2><ul><li><p><strong>Tomcat的获取</strong></p><ul><li>从<a href="http://tomcat.apache.org/" target="_blank" rel="noopener">Apache官方网站</a>获取Tomcat最新版本。Tomcat提供了安装版本和解压缩版本的文件，可以根据需要进行下载</li></ul></li><li><p><strong>Tomcat的安装</strong></p><ul><li><p>Tomcat的安装根据提示点击下一步进行安装。需要注意的是解压缩版本在安装完毕后还要设置CATALINA_HOME环境变量，设置方法个设置Java环境变量的步骤类似</p><ol><li><p>右击我的电脑——属性——高级系统设置——环境变量——新建</p><p> <img src="../../img/47459/Path.png" alt="环境变量"></p></li><li><p>添加环境变量，变量名为CATALINA-HOME，变量值为Tomcat的安装路径</p></li></ol></li></ul></li></ul><hr><h2 id="Tomcat的目录结构-1"><a href="#Tomcat的目录结构-1" class="headerlink" title="Tomcat的目录结构"></a><strong>Tomcat的目录结构</strong></h2><table><thead><tr><th align="center">目录</th><th align="left">说明</th></tr></thead><tbody><tr><td align="center">bin</td><td align="left">存放各种平台下用于启动和停止Tomcat的脚本文件</td></tr><tr><td align="center">conf</td><td align="left">存放Tomcat服务器的各种配置文件</td></tr><tr><td align="center">lib</td><td align="left">存放Tomcat服务器所需的各种JAR文件</td></tr><tr><td align="center">loge</td><td align="left">存放Tomcat的日志文件</td></tr><tr><td align="center">temp</td><td align="left">Tomcat运行时用于存放临时文件</td></tr><tr><td align="center">webapps</td><td align="left">Web应用的发布目录</td></tr><tr><td align="center">work</td><td align="left">Tomcat吧由Jsp生成的Servlet存放与此目录下</td></tr></tbody></table><hr><h2 id="将Tomcat部署到Myeclipse-1"><a href="#将Tomcat部署到Myeclipse-1" class="headerlink" title="将Tomcat部署到Myeclipse"></a><strong>将Tomcat部署到Myeclipse</strong></h2><blockquote><p>在部署之前，需要先在Myeclipse中配置Tomcat</p></blockquote><ul><li><p>打开Myeclipse——上方任务栏中的Window——Preferences</p><p>  <img src="../../img/47459/MyeclipsePrompt.png" alt="配置"></p></li><li><p>在弹出的对话框中选择Myeclipse —— Servers —— Tomcat —— Tomcat 7.X —— 勾选右侧的单选按钮Enable —— 点击Tomcat home directory后面的Browse按钮，选择Tomcat的安装路径 —— 点击下方的Apply</p><p>  <img src="../../img/47459/MyeclipsePrompt2.png" alt="配置2"></p></li><li><p>选择Tomcat 7.X 下的JDK —— 单击ADD按钮 —— 在弹出的对话框中单击Directory —— 选择JDK安装路径 —— 单击Finish</p><p>  <img src="../../img/47459/MyeclipsePrompt3.png" alt="配置3"></p><p>  <img src="../../img/47459/MyeclipsePrompt4.png" alt="配置4"></p></li><li><p>单击Apply —— OK —— 配置完成</p><p>  <img src="../../img/47459/MyeclipsePrompt5.png" alt="配置5"></p></li></ul><blockquote><p>配置完成后开始部署</p></blockquote><ul><li><p>点击上方菜单栏中的部署图标</p><p>  <img src="../../img/47459/MyeclipsePrompt6.png" alt="配置6"></p></li><li><p>在弹出的对话框中选择部署的项目（必须是Web Project）—— 点击Add —— 在弹出的对话框中选择刚才配置的Tomcat版本（Tomcat 7.0）—— 单击Finish ——部署完毕</p><p>  <img src="../../img/47459/MyeclipsePrompt7.png" alt="配置7"></p><p>  <img src="../../img/47459/MyeclipsePrompt8.png" alt="配置8"></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 软件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 入门 </tag>
            
            <tag> Tomcat </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一篇文章</title>
      <link href="/2019/12/28/di-yi-pian-bo-ke-wen-zhang/"/>
      <url>/2019/12/28/di-yi-pian-bo-ke-wen-zhang/</url>
      
        <content type="html"><![CDATA[<h1 id="自己在创建博客过程中遇见的问题"><a href="#自己在创建博客过程中遇见的问题" class="headerlink" title="自己在创建博客过程中遇见的问题"></a><strong>自己在创建博客过程中遇见的问题</strong></h1><p><img src="../../img/32733/test1.jpg" alt="图片" title="测试图片"></p><h2 id="部署到Github时-GitBash-报错"><a href="#部署到Github时-GitBash-报错" class="headerlink" title="部署到Github时 GitBash 报错"></a>部署到Github时 GitBash 报错</h2><p> 描述：<strong>使用 hexo d 进行部署时出现了错误提示</strong></p><p> 例：</p><pre><code>暂无截图</code></pre><p> 解决方法：去Github查看是否已部署完成</p><hr><h1 id="常用hexo命令"><a href="#常用hexo命令" class="headerlink" title="常用hexo命令"></a><strong>常用hexo命令</strong></h1><p>使用hexo命令时需要通过cd进入到对应的博客位置才能正常使用</p><blockquote><pre><code>hexo cl    //清空hexo g     //重新加载hexo c     //开启本地服务hexo d     //部署到Github上</code></pre></blockquote><p>需要注意的是在用hexo d部署时，第一次输入的是在Github注册的用户名,第二次输入的密码是token。需要在Github获取才行</p><p><strong>！！！注意！！！</strong></p><p>token只会在获取后显示一次，如果第一次显示后没有保存则需要删除token后再次获取</p><h2 id="如何写一篇博客文章"><a href="#如何写一篇博客文章" class="headerlink" title="如何写一篇博客文章"></a>如何写一篇博客文章</h2><blockquote><ol><li>在BitBash或者在cmd命令窗口使用hexo n “博客标题”来在指定位置创建文章</li><li>打开创建的文件，使用工具来编写Markdown文档</li><li>将博客先部署到本机，查看博客内容是否完成</li><li>完成后重新将hexo部署到Github上</li><li>等待一段时间后刷新网页看是否创已经上传到Github上</li></ol></blockquote><h2 id="部署时一直弹出输入用户名和密码"><a href="#部署时一直弹出输入用户名和密码" class="headerlink" title="部署时一直弹出输入用户名和密码"></a>部署时一直弹出输入用户名和密码</h2><p>描述：<strong>在输入hexo d部署到Github时，每次都需要输入用户名，密码。然后在Git Bash里又要再次输入用户名和Token密码</strong></p><p>例：</p><p>   暂无图片</p><p>解决方法：在Github里面设置了ssh后就不用多次输入用户名密码，只需要在Git Bash里输入用户名和Token密码就行了</p><p><a href="http://www.baidu.com/" target="_blank" rel="noopener" title="百度一下">百度</a></p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 测试 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
